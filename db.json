{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/avatar.png","path":"css/images/avatar.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/logo.png","path":"css/images/logo.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/whale.png","path":"css/images/whale.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","path":"libs/justified-gallery/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/justified-gallery/justifiedGallery.min.css","path":"libs/justified-gallery/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/styles.css","path":"libs/open-sans/styles.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/styles.css","path":"libs/source-code-pro/styles.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/favicon.ico","path":"css/images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/horse.jpg","path":"css/images/horse.jpg","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/css/font-awesome.css","path":"libs/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/css/font-awesome.min.css","path":"libs/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","path":"libs/lightgallery/css/lg-fb-comment-box.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","path":"libs/lightgallery/css/lg-fb-comment-box.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","path":"libs/lightgallery/css/lg-fb-comment-box.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css","path":"libs/lightgallery/css/lg-transitions.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css.map","path":"libs/lightgallery/css/lg-transitions.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.min.css","path":"libs/lightgallery/css/lg-transitions.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css","path":"libs/lightgallery/css/lightgallery.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css.map","path":"libs/lightgallery/css/lightgallery.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.min.css","path":"libs/lightgallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.eot","path":"libs/lightgallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.svg","path":"libs/lightgallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.woff","path":"libs/lightgallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.ttf","path":"libs/lightgallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/loading.gif","path":"libs/lightgallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/video-play.png","path":"libs/lightgallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/vimeo-play.png","path":"libs/lightgallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/youtube-play.png","path":"libs/lightgallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.js","path":"libs/lightgallery/js/lg-autoplay.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.min.js","path":"libs/lightgallery/js/lg-autoplay.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.js","path":"libs/lightgallery/js/lg-fullscreen.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","path":"libs/lightgallery/js/lg-fullscreen.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.js","path":"libs/lightgallery/js/lg-hash.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.min.js","path":"libs/lightgallery/js/lg-hash.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.js","path":"libs/lightgallery/js/lg-pager.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.min.js","path":"libs/lightgallery/js/lg-pager.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.js","path":"libs/lightgallery/js/lg-share.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.min.js","path":"libs/lightgallery/js/lg-share.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.js","path":"libs/lightgallery/js/lg-thumbnail.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","path":"libs/lightgallery/js/lg-thumbnail.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.js","path":"libs/lightgallery/js/lg-video.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.min.js","path":"libs/lightgallery/js/lg-video.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.js","path":"libs/lightgallery/js/lg-zoom.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.min.js","path":"libs/lightgallery/js/lg-zoom.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.js","path":"libs/lightgallery/js/lightgallery.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.min.js","path":"libs/lightgallery/js/lightgallery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","path":"libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.eot","path":"libs/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff","path":"libs/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","path":"libs/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/jquery/2.1.3/jquery.min.js","path":"libs/jquery/2.1.3/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","path":"libs/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/profile_pic.jpg","path":"css/images/profile_pic.jpg","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/FontAwesome.otf","path":"libs/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.svg","path":"libs/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"ad3dc80f4dbac4c11962b65af842e325a132b871","modified":1542293809000},{"_id":"source/CNAME","hash":"3476d63984d6f43a96cd9834ed9fb4948ed6c85c","modified":1542293809000},{"_id":"themes/icarus/LICENSE","hash":"df00918fa95de563927fd92b26f14c7affdc3052","modified":1542293809000},{"_id":"themes/icarus/README.md","hash":"25c75503f044b817297995a96621c92ce037a098","modified":1542293809000},{"_id":"themes/icarus/_config.yml","hash":"fa297f83aa650787b02ab36c2d716682f925aacd","modified":1542293809000},{"_id":"themes/icarus/package.json","hash":"1bc52ef10a33df23e56bd73c927f605019c87d41","modified":1542293809000},{"_id":"source/_posts/2Sum.md","hash":"a3730cf3a5fd8d0204361ff241195f533b6ce055","modified":1542297753000},{"_id":"source/_posts/3Sum-Closest.md","hash":"64bd41fc4b24be7394d11511f0a4756a35d7880c","modified":1542299291000},{"_id":"source/_posts/3Sum.md","hash":"3ed8cf51728622c73e4810427f7b979c45c0659a","modified":1542299292000},{"_id":"source/_posts/4Sum.md","hash":"6d1eb9f7fd06dd47c95bfc3ed33edd64156cb566","modified":1542299290000},{"_id":"source/_posts/Balanced-Binary-Tree.md","hash":"b3c889a47e070518a9789d7f9aa2a8f98aed147f","modified":1542299287000},{"_id":"source/_posts/Best-Time-to-Buy-and-Sell-Stock-II.md","hash":"53c8e1abdb72d54e852a773e317bf012995877c4","modified":1542300570000},{"_id":"source/_posts/Binary-Tree-Inorder-Traversal.md","hash":"e0d6af07dc180d45e94f5b22c19e47f7d695fa8e","modified":1542299703000},{"_id":"source/_posts/Binary-Tree-Level-Order-Traversal-II.md","hash":"649ba64e7140497589e9b41f6c87d2b6800a67ff","modified":1542300121000},{"_id":"source/_posts/Binary-Tree-Level-Order-Traversal.md","hash":"e70e97f28d17693ba6878eb4aae5f53ec08238d0","modified":1542299993000},{"_id":"source/_posts/Binary-Tree-Preorder-Traversal.md","hash":"fb8672c0c50eead6adbe8338cda07e1285821b77","modified":1542299841000},{"_id":"source/_posts/Excel-Sheet-Column-Number.md","hash":"dc95446091f48113ce917d7e01f171053defce01","modified":1542298470000},{"_id":"source/_posts/Intersection-of-Two-Linked-Lists.md","hash":"6807370a34ae444ed3bf7daa6242b7c92f530432","modified":1542299306000},{"_id":"source/_posts/Linked-List-Cycle.md","hash":"da8b3e03566b0425256f981e3fc4b75ae0aeeea2","modified":1542299135000},{"_id":"source/_posts/Majority-Element.md","hash":"899d421feb778ea567e668fc222d7024ac928c8c","modified":1542298470000},{"_id":"source/_posts/Maximum-Depth-of-Binary-Tree.md","hash":"751d81e1eced809a3b32af32e81787a43eea1d9d","modified":1542300519000},{"_id":"source/_posts/Palindrome-Number.md","hash":"8fc4a5a4461ab3c9154f5369c0891f6e7c2c69df","modified":1542298470000},{"_id":"source/_posts/Remove-Duplicates-from-Sorted-List.md","hash":"273d126422b1f54b1656d4ceff5dbcb3486353f4","modified":1542299323000},{"_id":"source/_posts/Same-Tree.md","hash":"81655e168419a32e5feb16fd6cec8e6777baf0e6","modified":1542300398000},{"_id":"source/_posts/Single-Number.md","hash":"70b2b28fb850eca2359c5b17c608754c70f12848","modified":1542300647000},{"_id":"source/_posts/Unique-Binary-Search-Trees.md","hash":"2e18d17dd3fecb4630200e90e48fbc786b0aee06","modified":1542300290000},{"_id":"source/_posts/ZigZag-Conversion.md","hash":"f2e6f1307e801e8b281e57ae59cc384253ba7474","modified":1542299135000},{"_id":"source/_posts/manual-deploy-ceph.md","hash":"14fe00cb4408311c2d536b13ef4fb9b73be35273","modified":1542293809000},{"_id":"source/_posts/岛屿个数.md","hash":"062c1b1ca57c6aa7d03d387bf1134efa777e4fef","modified":1542299289000},{"_id":"source/_posts/最后一个单词的长度.md","hash":"cb15a3d8cf2465871161e061c9691cee8eb1b9cb","modified":1542299285000},{"_id":"source/_posts/有效的括号序列.md","hash":"2341287ce366d711df3a07593d703b2bd8b01fdb","modified":1542299284000},{"_id":"source/about/index.md","hash":"3094693de0d30067fca4424611d503b5f91daa37","modified":1542293809000},{"_id":"source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1542293809000},{"_id":"source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1542293809000},{"_id":"themes/icarus/languages/en.yml","hash":"ade241498b85503a8953a1deca963222f47067a7","modified":1542293809000},{"_id":"themes/icarus/languages/es.yml","hash":"d7432219be5bee4cb569331378ade61b749688e0","modified":1542293809000},{"_id":"themes/icarus/languages/id.yml","hash":"70ec9ab2ac04cf882e81377ca5ad15bf8adceca8","modified":1542293809000},{"_id":"themes/icarus/languages/fr.yml","hash":"cb3e597cbec7e8f458858c457bafd1f3a225083d","modified":1542293809000},{"_id":"themes/icarus/languages/ja.yml","hash":"ff972961e5f468a695d80d21b62c3e9032cdf561","modified":1542293809000},{"_id":"themes/icarus/languages/ko.yml","hash":"7c4ad4577dc0577ad2ca1c0410507f5e5fadf530","modified":1542293809000},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"3c5d5293575593705b9a2dfa9d97b017eb4bc8c3","modified":1542293809000},{"_id":"themes/icarus/languages/ru.yml","hash":"d1aab2b0c939d0c6020f881d664b660a01ee7327","modified":1542293809000},{"_id":"themes/icarus/languages/tr.yml","hash":"8b7eb6aec264db50dbabea89f680acca256f4cd1","modified":1542293809000},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"3dc8ec524805afd090438be717908750da439204","modified":1542293809000},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"d8d96a0a17c20af11919ce036e87379a6b163db9","modified":1542293809000},{"_id":"themes/icarus/layout/.DS_Store","hash":"de7d0a6e507b0c9077f498d187f0685511402a4d","modified":1542293809000},{"_id":"themes/icarus/layout/archive.ejs","hash":"c1ecf667f40f34d61ab33eed46bab143eb1af36d","modified":1542293809000},{"_id":"themes/icarus/layout/categories.ejs","hash":"aa95629b770cff8cca9d663aeb6b17928f070de5","modified":1542293809000},{"_id":"themes/icarus/layout/category.ejs","hash":"1d407f9176db84e83062c52ad4755aaea9e74401","modified":1542293809000},{"_id":"themes/icarus/layout/index.ejs","hash":"43e971ebc35657b18e08a049559790348a16666f","modified":1542293809000},{"_id":"themes/icarus/layout/layout.ejs","hash":"68dce13bc3e8dee1ab50ab80576ab722157e119a","modified":1542293809000},{"_id":"themes/icarus/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1542293809000},{"_id":"themes/icarus/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1542293809000},{"_id":"themes/icarus/layout/tag.ejs","hash":"f6c220d4e5c231028bc71ddc11aec97d7b5a9943","modified":1542293809000},{"_id":"themes/icarus/layout/tags.ejs","hash":"b0fcea68d7c11e5899bf0375d80997685111653f","modified":1542293809000},{"_id":"themes/icarus/scripts/meta.js","hash":"1993754a2f3dffa283fa0538eb8f056385b69ad4","modified":1542293809000},{"_id":"themes/icarus/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1542293809000},{"_id":"themes/icarus/source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1542293809000},{"_id":"themes/icarus/_source/about/index.md","hash":"2847759c65295fdc47685cc32e10ae30b2f022ae","modified":1542293809000},{"_id":"themes/icarus/_source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1542293809000},{"_id":"themes/icarus/_source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1542293809000},{"_id":"themes/icarus/layout/comment/counter.ejs","hash":"59abd552086c26cb0a6fd86d18ce380c3b1b3c55","modified":1542293809000},{"_id":"themes/icarus/layout/comment/disqus.ejs","hash":"1b32a90f400dc580f4b8298de75b94429ca6de68","modified":1542293809000},{"_id":"themes/icarus/layout/comment/duoshuo.ejs","hash":"ce46d7410a99b57704da32e9d09071cef6c9fa93","modified":1542293809000},{"_id":"themes/icarus/layout/comment/index.ejs","hash":"0913444317759c3ff0588ca3aa4a6a89b6595307","modified":1542293809000},{"_id":"themes/icarus/layout/comment/facebook.ejs","hash":"5ee16430a4435c2fead0275ff83fc98092d73d4c","modified":1542293809000},{"_id":"themes/icarus/layout/comment/isso.ejs","hash":"4f8b81ff5bb418ec11ce080d515f247bfe436014","modified":1542293809000},{"_id":"themes/icarus/layout/comment/scripts.ejs","hash":"305aa07646ab03e00d8239a811f4ec6f75751e1e","modified":1542293809000},{"_id":"themes/icarus/layout/comment/youyan.ejs","hash":"6fe807992832939caf6c3e7651d052df9520d88e","modified":1542293809000},{"_id":"themes/icarus/layout/common/footer.ejs","hash":"79ad7f2c8ab0662acfc754ad314522720d010533","modified":1542293809000},{"_id":"themes/icarus/layout/common/article.ejs","hash":"7c6ee7cbf1ce00e2bd4d1bb6c549a26d14b64d09","modified":1542293809000},{"_id":"themes/icarus/layout/common/head.ejs","hash":"44f30945882afd27c89da2173da501fb1b531488","modified":1542293809000},{"_id":"themes/icarus/layout/common/header.ejs","hash":"738c6a923b2a6de6a81c4892c8a47e03d8b34f88","modified":1542293809000},{"_id":"themes/icarus/layout/common/profile.ejs","hash":"500f05cd15633b004a967ca4802dae9120a2d613","modified":1542293809000},{"_id":"themes/icarus/layout/common/scripts.ejs","hash":"c0a1a9e53f89440c42c325d5bd8c7234652c8937","modified":1542293809000},{"_id":"themes/icarus/layout/common/sidebar.ejs","hash":"2cd62b3efaa3da7bdb6d40d33fdce8e4e28b09ba","modified":1542293809000},{"_id":"themes/icarus/layout/common/thumbnail.ejs","hash":"1b70f8a98cd8650b159bda858dbee38dbdb7f0c5","modified":1542293809000},{"_id":"themes/icarus/layout/common/timeline.ejs","hash":"6420e34e0332c9b6670011519f341340db989343","modified":1542293809000},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","hash":"6a7bee18e666e627e62541a5e30906f87ba1bfe8","modified":1542293809000},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","hash":"349f08b6521a16e79046b1f94f04317ac74f556e","modified":1542293809000},{"_id":"themes/icarus/layout/plugin/scripts.ejs","hash":"4fdb85e6730530f2d262041b41d1ead1b87dfd88","modified":1542293809000},{"_id":"themes/icarus/layout/search/baidu.ejs","hash":"3e603a702d20c53fd3bcbeb570a16a86d54781ce","modified":1542293809000},{"_id":"themes/icarus/layout/search/index-mobile.ejs","hash":"50a727ac1dfe3073eb6fa6699ba01e66f4ac41c0","modified":1542293809000},{"_id":"themes/icarus/layout/search/index.ejs","hash":"24935e32e61d4706454b174ea3bed0726ae7fb34","modified":1542293809000},{"_id":"themes/icarus/layout/search/insight.ejs","hash":"130fe3d33ac71da0b50f7fee6a87979f30938a1b","modified":1542293809000},{"_id":"themes/icarus/layout/search/swiftype.ejs","hash":"379e66d2c13526e72e4120c443f95fccf4edef71","modified":1542293809000},{"_id":"themes/icarus/layout/share/addtoany.ejs","hash":"ac180c4c84b73a04d61b17e7dc18c257e20bf59f","modified":1542293809000},{"_id":"themes/icarus/layout/share/bdshare.ejs","hash":"a1e772c5a6f174d585b0c1e574058f75dc8e2898","modified":1542293809000},{"_id":"themes/icarus/layout/share/default.ejs","hash":"ebfb919dc525b3ed61a6a5ee05ee71410eedc541","modified":1542293809000},{"_id":"themes/icarus/layout/share/index.ejs","hash":"2a2c0095b95b11e5692bd8ad6a2337aa644189a2","modified":1542293809000},{"_id":"themes/icarus/layout/share/jiathis.ejs","hash":"21ebaa51e828cba2cefbeeaccb01514643565755","modified":1542293809000},{"_id":"themes/icarus/layout/widget/archive.ejs","hash":"d9ebbb7f6ce2f25df5ae25e4a1fef3c08f7054b9","modified":1542293809000},{"_id":"themes/icarus/layout/widget/category.ejs","hash":"583bda80cf15b3ef11fefbd1b502897dfff40100","modified":1542293809000},{"_id":"themes/icarus/layout/widget/links.ejs","hash":"5e3a4a08ec6c146c14010ca7a03b57fccab6a7f6","modified":1542293809000},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","hash":"2ca923465275fb38a7ac7d67211d6e94a977e957","modified":1542293809000},{"_id":"themes/icarus/layout/widget/tag.ejs","hash":"3b8ae5953990436893da9d68f910ebe592005659","modified":1542293809000},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","hash":"ca8c7bf555fb6ce4904f2c59160548405c2c8a82","modified":1542293809000},{"_id":"themes/icarus/source/js/insight.js","hash":"6ee84c42c2b230ff9e9bf605a444bd671d44f9e3","modified":1542293809000},{"_id":"themes/icarus/source/js/main.js","hash":"1faffdc7aa7f0d28e85edbf49c99de3ad0b65753","modified":1542293809000},{"_id":"themes/icarus/source/css/.DS_Store","hash":"495dc0d217dbc3e7cb0c015a4aa9af3e7011d37f","modified":1542293809000},{"_id":"themes/icarus/source/css/_extend.styl","hash":"9a5c72663c0da1b32ecb6a75773a5ccfb8c467ca","modified":1542293809000},{"_id":"themes/icarus/source/css/_variables.styl","hash":"2d3711e9ee47069c17b91e30285833a65d219ac4","modified":1542293809000},{"_id":"themes/icarus/source/css/style.styl","hash":"367fd86ba213ced68052c64cf5895ac146bf7785","modified":1542293809000},{"_id":"themes/icarus/layout/common/post/banner.ejs","hash":"47ced3f03525698c79c6b1c07b48383fb6c496b2","modified":1542293809000},{"_id":"themes/icarus/layout/common/post/category.ejs","hash":"75c9dda2e7ec041943855ca163a6b1c4c8b4f260","modified":1542293809000},{"_id":"themes/icarus/layout/common/post/date.ejs","hash":"45cb0bcad461036cdd1fe2e3fbb5f2f19940025c","modified":1542293809000},{"_id":"themes/icarus/layout/common/post/gallery.ejs","hash":"659f019761116313169148ec61773e7b84abb739","modified":1542293809000},{"_id":"themes/icarus/layout/common/post/nav.ejs","hash":"d7cd611e642327f33dff3963ef869c2b46824a11","modified":1542293809000},{"_id":"themes/icarus/layout/common/post/tag.ejs","hash":"2e966216256321aa0c76fe1b9be689601c76ef31","modified":1542293809000},{"_id":"themes/icarus/layout/common/post/title.ejs","hash":"669ddb46fefa100856588351a7a2d30ad996b755","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/index.styl","hash":"903a1f2c6ec62cf76a44f92a2dbb52178a4ce94a","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1542293809000},{"_id":"themes/icarus/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1542293809000},{"_id":"themes/icarus/source/css/_partial/archive.styl","hash":"d35088c83ddd7a197d6d94e16a2ce3a7e29fa1dc","modified":1542293809000},{"_id":"themes/icarus/source/css/_partial/article.styl","hash":"49159a9d8a42d8478d66b93cf5c6ad20ee71b480","modified":1542293809000},{"_id":"themes/icarus/source/css/_partial/article_backup.styl","hash":"512b9252e1799b93a17c4ad847b0586814a030b4","modified":1542293809000},{"_id":"themes/icarus/source/css/_partial/comment.styl","hash":"784646796184d4f27918c22395288a2fafbf9554","modified":1542293809000},{"_id":"themes/icarus/source/css/_partial/footer.styl","hash":"484776654e4c1691dc844e6e93786a08855c1c99","modified":1542293809000},{"_id":"themes/icarus/source/css/_partial/header.styl","hash":"ce832196eb5761364f3d9af7344e616b031bb8a7","modified":1542293809000},{"_id":"themes/icarus/source/css/_partial/insight.styl","hash":"19833cd127f26ad90b06c115f8a96a30e0c0e53b","modified":1542293809000},{"_id":"themes/icarus/source/css/_partial/profile.styl","hash":"b0f9b4534c4949ecb9f8540ed04e3e440065c4cd","modified":1542293809000},{"_id":"themes/icarus/source/css/_partial/sidebar.styl","hash":"f528ca7064d9fcecd737b9b71c9c54601365d7d3","modified":1542293809000},{"_id":"themes/icarus/source/css/_partial/timeline.styl","hash":"c813b98f4fc45b64d2e07e5d944745a654c8c943","modified":1542293809000},{"_id":"themes/icarus/source/css/_util/grid.styl","hash":"93fb6f1e2f40cd7d88ad0d56dd73d3f9a7bc853e","modified":1542293809000},{"_id":"themes/icarus/source/css/_util/mixin.styl","hash":"c8e1ddfc0fe9108bab592c7a73b73ce9344991fd","modified":1542293809000},{"_id":"themes/icarus/source/css/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1542293809000},{"_id":"themes/icarus/source/css/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1542293809000},{"_id":"themes/icarus/source/css/images/logo.png","hash":"e606a0584f98268b2fe92303f3254520862ef659","modified":1542293809000},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1542293809000},{"_id":"themes/icarus/source/css/images/whale.png","hash":"5e59a7b7bed8480212a40ee5b0723cbfe9f27c52","modified":1542293809000},{"_id":"themes/icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1542293809000},{"_id":"themes/icarus/source/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1542293809000},{"_id":"themes/icarus/source/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1542293809000},{"_id":"themes/icarus/source/css/images/favicon.ico","hash":"72e198149b2809bc8af629da284399985e9023ec","modified":1542293809000},{"_id":"themes/icarus/source/css/images/horse.jpg","hash":"abe614ab9e08706a84523518ceabb36a3792302c","modified":1542293809000},{"_id":"themes/icarus/source/libs/font-awesome/css/font-awesome.css","hash":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1542293809000},{"_id":"themes/icarus/source/libs/font-awesome/css/font-awesome.min.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1542293809000},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1542293809000},{"_id":"themes/icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1542293809000},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1542293809000},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1542293809000},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1542293809000},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1542293809000},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1542293809000},{"_id":"themes/icarus/source/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1542293809000},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1542293809000},{"_id":"themes/icarus/source/css/images/profile_pic.jpg","hash":"dec900407c9f26db3e7475823e4f65d8bf3c19f2","modified":1542293809000},{"_id":"themes/icarus/source/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1542293809000},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1542293809000},{"_id":"public/content.json","hash":"b6f648e1afa30503ce3ddac3400e2b31a4ab8795","modified":1542300660100},{"_id":"public/about/index.html","hash":"6888354b0d093c4b53700481e86576d4eac39127","modified":1542300660648},{"_id":"public/categories/index.html","hash":"14c6742c822dd6f6d65f2b58b342187bd725593c","modified":1542300660648},{"_id":"public/tags/index.html","hash":"5524f92156a5479da9372b1e068c5c6a50a51c34","modified":1542300660787},{"_id":"public/post/c94099d8.html","hash":"54681c363004533000f39bdbd93c694a5a457cc5","modified":1542300660788},{"_id":"public/post/1d8b65b1.html","hash":"05ebd0949144015848e78455409fe5fb0946db2a","modified":1542300660790},{"_id":"public/post/61984fa2.html","hash":"2feb8c5b8f8eb2748f9cbbc50bda32e371f401c8","modified":1542300660790},{"_id":"public/post/5c1c4dd0.html","hash":"67eadebd2aec02e1ebdb38c37d72edd32bedda36","modified":1542300660790},{"_id":"public/post/ed8e0613.html","hash":"7f7d5643d957e2bff6b7eb1f1ad68b620efeb415","modified":1542300660790},{"_id":"public/post/50445eba.html","hash":"df633b9d93ef4af7ae27ca37dacbb1c142cfc072","modified":1542300660790},{"_id":"public/post/f055ffc7.html","hash":"2c09c4c64a1628b94a3e1b0793f2cb1353645f17","modified":1542300660790},{"_id":"public/categories/ceph/index.html","hash":"839f3f410236aa40325eec7695ef7814568bd974","modified":1542300660790},{"_id":"public/tags/List/index.html","hash":"e2a77f6110fd0e9d80c0064e56f6ad5d2805ae26","modified":1542300660790},{"_id":"public/tags/DFS/index.html","hash":"698ad0418b9276560d0630ef4981fd86cbc0f8ea","modified":1542300660790},{"_id":"public/tags/String/index.html","hash":"25de8e5e7b258659f9467a829844fd33a7b32a5c","modified":1542300660790},{"_id":"public/tags/Stack/index.html","hash":"7adac192feb7f8d97d3b3cf9fa2f6c1a989c08f9","modified":1542300660790},{"_id":"public/tags/ceph/index.html","hash":"bf533a6ecdb1f3ba2be8e3a0f73e5151974281f2","modified":1542300660790},{"_id":"public/post/42870ae4.html","hash":"eba92cd1bf3d45baab7d3003ec342d853127f96c","modified":1542300660790},{"_id":"public/post/b216f26b.html","hash":"ea0b5bb5b1ff6522a7e0bec39892dfdd3543f480","modified":1542300660790},{"_id":"public/post/74d7ef89.html","hash":"1a7eb4a94fa11832af164620c2388faabb944c83","modified":1542300660790},{"_id":"public/post/cc6b88ec.html","hash":"d6131e7ac1abc3e3399464dc380e20f535b9e53f","modified":1542300660790},{"_id":"public/post/c85f0a37.html","hash":"7168eb6157b6205f91d27389e102a5509eda1c78","modified":1542300660791},{"_id":"public/post/51bcb055.html","hash":"f90cf305b4e7fbbf7fe0e59be4f6586fe54f1e8f","modified":1542300660791},{"_id":"public/post/cf94e2fe.html","hash":"e1337417af2162e331404e8dc6ab7850db778161","modified":1542300660791},{"_id":"public/post/cc03a9fe.html","hash":"e720367bb0585ef0428bb6d771b5a57981c890e7","modified":1542300660791},{"_id":"public/post/c3d7e91e.html","hash":"3ea9196481fd344a4a8de0e83c1aa0326215837e","modified":1542300660791},{"_id":"public/archives/index.html","hash":"758a5b8791f3f699ab3574e822a2ee1c6b59349d","modified":1542300660791},{"_id":"public/archives/page/2/index.html","hash":"1a64c28aca864e586c9bfa05ead90b276d5d2fcc","modified":1542300660791},{"_id":"public/archives/2018/index.html","hash":"38243a811856c2137c0573ec1acceff2e85ed2b5","modified":1542300660791},{"_id":"public/archives/2018/page/2/index.html","hash":"7c764c63e847a9d9eff527ba95cb152abcddf376","modified":1542300660791},{"_id":"public/archives/2018/11/index.html","hash":"4250fc094884ccc1295caf45000b4c7f765603c2","modified":1542300660791},{"_id":"public/archives/2018/11/page/2/index.html","hash":"7fd5549c161a549fe77d928e4e70e6883ad01451","modified":1542300660791},{"_id":"public/categories/leetcode/index.html","hash":"18b6257907d177f0f91b8c1318daffa292086c21","modified":1542300660791},{"_id":"public/categories/leetcode/page/2/index.html","hash":"6da3fa86e5a6ce9df0810813e7c78aa9e7938a55","modified":1542300660791},{"_id":"public/index.html","hash":"57689023f8bc6b46a6c7053162be8fbddd59ea74","modified":1542300660791},{"_id":"public/page/2/index.html","hash":"897a9abeda574270b24ea82b049da1251d313bdc","modified":1542300660791},{"_id":"public/tags/C/index.html","hash":"5eda0fe147daaa9ae29ab60e2cee9aaa72d657a5","modified":1542300660791},{"_id":"public/tags/C/page/2/index.html","hash":"dd827a8ce5f9b9dffc7edcee6f2613ed95610b35","modified":1542300660791},{"_id":"public/tags/Binary-Tree/index.html","hash":"efbf1f35c9ad1623dea93ec8c6b9a23512bb8575","modified":1542300660791},{"_id":"public/post/f249b7a1.html","hash":"7527a63ef19ae98d8c2d44116420890913a6ca6e","modified":1542300660798},{"_id":"public/post/a10d34fe.html","hash":"d20e9025b974128fbc3a9b7de8f458df1e65d879","modified":1542300660798},{"_id":"public/post/2c2d1f13.html","hash":"7078a76506f696756da766500e6281920014fcc4","modified":1542300660798},{"_id":"public/post/f4467b0e.html","hash":"9003eeb7d567eeaa4c9fa76708d38ebc0f924476","modified":1542300660798},{"_id":"public/post/20d2cb13.html","hash":"f6b7d7239ca47f1406bd36e65d39199786f500bf","modified":1542300660798},{"_id":"public/post/8a5e7d39.html","hash":"609afe7c47e30d23e69f0c3ebe54c8246aaf656a","modified":1542300660798},{"_id":"public/archives/page/3/index.html","hash":"e2158bfdef85043c40869e97ea5fe22928b8033b","modified":1542300660799},{"_id":"public/archives/2018/page/3/index.html","hash":"aaf6af5f488577952f25db9d14dea546927aa5d7","modified":1542300660799},{"_id":"public/archives/2018/11/page/3/index.html","hash":"2fdee30568cc221910478322bc6dc4e3c830e763","modified":1542300660799},{"_id":"public/categories/leetcode/page/3/index.html","hash":"9fd847041a17a441c3f0b47fc80c8ca712b56c06","modified":1542300660799},{"_id":"public/tags/C/page/3/index.html","hash":"2a85b49de7a025b0c996ab84fb01981db6a427dd","modified":1542300660799},{"_id":"public/tags/BST/index.html","hash":"726ec0fbd887a77422f9560d4a4cfe3485803269","modified":1542300660799},{"_id":"public/post/8adb33dd.html","hash":"bdcbd246edd942699edaa47832137e21ff575c86","modified":1542300660799},{"_id":"public/post/a971a08f.html","hash":"bf4d3e8f4c6b5e07ae29a80946c13324bc9ff8fb","modified":1542300660799},{"_id":"public/post/d13d2726.html","hash":"651aae561b0a0411280d8d0c19bc4e77d959d39b","modified":1542300660799},{"_id":"public/page/3/index.html","hash":"d101a993eadc75d79b803a027391944e5d518eb2","modified":1542300660799},{"_id":"public/CNAME","hash":"3476d63984d6f43a96cd9834ed9fb4948ed6c85c","modified":1542300660809},{"_id":"public/css/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1542300660809},{"_id":"public/css/images/logo.png","hash":"e606a0584f98268b2fe92303f3254520862ef659","modified":1542300660809},{"_id":"public/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1542300660809},{"_id":"public/css/images/whale.png","hash":"5e59a7b7bed8480212a40ee5b0723cbfe9f27c52","modified":1542300660809},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1542300660809},{"_id":"public/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1542300660809},{"_id":"public/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1542300660809},{"_id":"public/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1542300660809},{"_id":"public/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1542300660809},{"_id":"public/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1542300660809},{"_id":"public/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1542300660809},{"_id":"public/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1542300660809},{"_id":"public/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1542300660809},{"_id":"public/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1542300660809},{"_id":"public/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1542300660809},{"_id":"public/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1542300660810},{"_id":"public/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1542300660810},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1542300660811},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1542300660811},{"_id":"public/css/images/favicon.ico","hash":"72e198149b2809bc8af629da284399985e9023ec","modified":1542300661236},{"_id":"public/css/images/horse.jpg","hash":"abe614ab9e08706a84523518ceabb36a3792302c","modified":1542300661236},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1542300661237},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1542300661237},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1542300661237},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1542300661237},{"_id":"public/js/main.js","hash":"1faffdc7aa7f0d28e85edbf49c99de3ad0b65753","modified":1542300661241},{"_id":"public/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1542300661241},{"_id":"public/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1542300661242},{"_id":"public/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1542300661242},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1542300661242},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1542300661242},{"_id":"public/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1542300661242},{"_id":"public/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1542300661242},{"_id":"public/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1542300661242},{"_id":"public/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1542300661242},{"_id":"public/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1542300661242},{"_id":"public/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1542300661242},{"_id":"public/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1542300661242},{"_id":"public/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1542300661242},{"_id":"public/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1542300661242},{"_id":"public/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1542300661242},{"_id":"public/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1542300661242},{"_id":"public/css/style.css","hash":"2bdffba6be51da60574ea96d85f0c07dffc835d8","modified":1542300661243},{"_id":"public/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1542300661243},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1542300661243},{"_id":"public/js/insight.js","hash":"6ee84c42c2b230ff9e9bf605a444bd671d44f9e3","modified":1542300661245},{"_id":"public/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1542300661245},{"_id":"public/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1542300661246},{"_id":"public/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1542300661246},{"_id":"public/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1542300661250},{"_id":"public/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1542300661251},{"_id":"public/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1542300661251},{"_id":"public/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1542300661251},{"_id":"public/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1542300661251},{"_id":"public/libs/font-awesome/css/font-awesome.min.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1542300661254},{"_id":"public/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1542300661254},{"_id":"public/libs/font-awesome/css/font-awesome.css","hash":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1542300661257},{"_id":"public/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1542300661257},{"_id":"public/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1542300661259},{"_id":"public/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1542300661285},{"_id":"public/css/images/profile_pic.jpg","hash":"dec900407c9f26db3e7475823e4f65d8bf3c19f2","modified":1542300661285},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1542300661286},{"_id":"public/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1542300661288}],"Category":[{"name":"leetcode","_id":"cjoitzonn0004tejenaq8lp48"},{"name":"ceph","_id":"cjoitzopm0033tejexx10d571"}],"Data":[],"Page":[{"layout":"page","_content":"\nhi,大家好！欢迎大家来到我的blog，希望以后能跟各位大佬一起学习进步。\n\n我叫左杨，目前就职于蚂蚁金服人工智能部，从事于蚂蚁人工智能相关的开发工作，对Machine Learning，Deep Learning比较感兴趣。\n","source":"about/index.md","raw":"layout: \"page\"\n---\n\nhi,大家好！欢迎大家来到我的blog，希望以后能跟各位大佬一起学习进步。\n\n我叫左杨，目前就职于蚂蚁金服人工智能部，从事于蚂蚁人工智能相关的开发工作，对Machine Learning，Deep Learning比较感兴趣。\n","date":"2018-11-15T14:56:49.000Z","updated":"2018-11-15T14:56:49.000Z","path":"about/index.html","title":"","comments":1,"_id":"cjoitzonk0001tejesb0ki8qp","content":"<p>hi,大家好！欢迎大家来到我的blog，希望以后能跟各位大佬一起学习进步。</p>\n<p>我叫左杨，目前就职于蚂蚁金服人工智能部，从事于蚂蚁人工智能相关的开发工作，对Machine Learning，Deep Learning比较感兴趣。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>hi,大家好！欢迎大家来到我的blog，希望以后能跟各位大佬一起学习进步。</p>\n<p>我叫左杨，目前就职于蚂蚁金服人工智能部，从事于蚂蚁人工智能相关的开发工作，对Machine Learning，Deep Learning比较感兴趣。</p>\n"},{"title":"Categories","layout":"categories","_content":"","source":"categories/index.md","raw":"title: \"Categories\"\nlayout: \"categories\"\n---\n","date":"2018-11-15T14:56:49.000Z","updated":"2018-11-15T14:56:49.000Z","path":"categories/index.html","comments":1,"_id":"cjoitzonm0003teje9bwhky12","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---\n","date":"2018-11-15T14:56:49.000Z","updated":"2018-11-15T14:56:49.000Z","path":"tags/index.html","comments":1,"_id":"cjoitzopk0032tejeqrei3ado","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2Sum","comments":1,"abbrlink":"74d7ef89","date":"2018-11-15T15:50:54.000Z","_content":"\n**问题描述：**\n\nGiven an array of integers, find two numbers such that they add up to a specific target number.\n\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.\n\nYou may assume that each input would have exactly one solution.\n\nInput: numbers={2, 7, 11, 15}, target=9\nOutput: index1=1, index2=2\n\n**解决思路：**\n\n本题主要是在给定的一个数组中找到两个数的下标，使得这个两个数和为给定的值，要求给出的下标从1 开始，且满足递增顺序，有三种解决方法，复杂度分别为O(n^2),O(nlogn),O(n),具体实现如下：\n\n\n\n**复杂度为O(n^2) 代码：**\n\n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int> &numbers, int target) {\n        // Start typing your C/C++ solution below\n        // DO NOT write int main() function\n        vector<int> ret(2, 0);\n        \n        int len = numbers.size();\n        \n        for(int i = 0; i < len; i++)\n        {\n            int tmp = target - numbers[i];      // another number\n            for(int j = i + 1; j < len; j++)\n            {\n                if(tmp == numbers[j])\n                {\n                    ret[0] = i + 1;     // +1 for not zero-based\n                    ret[1] = j + 1;\n                    return ret;\n                }\n            }\n        }\n        \n        return ret;\n    }\n};\n```\n\n\n\n**复杂度O(nlogn)代码:**\n\n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int> &numbers, int target) {\n        vector<int> index;\n        int len = numbers.size();\n        vector<int> bak = numbers;\n        \n            \n        sort(bak.begin(),bak.end());\n        \n        int l = 0,r = len-1;\n        int sum = 0;\n        while(l < r){\n            sum = bak[l]+bak[r];\n            if(sum == target)\n            {\n                for(int i = 0; i < len;i++)\n                {\n                    if (bak[l] == numbers[i])\n                    {\n                        index.push_back(i+1);\n                    }\n                    else if(bak[r] == numbers[i])\n                    {\n                        index.push_back(i+1);\n                    }\n                    if(index.size() == 2)\n                    {\n                        break;\n                    }\n                }\n                break;\n                \n            }\n            else if(sum < target)\n            {\n                ++l;\n            }\n            else\n            {\n                --r;\n            }\n            \n        }\n        \n       return index;\n    }\n};\n```\n\n\n\n**复杂度O(n)代码:**\n\n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int> &numbers, int target) {\n        int len = numbers.size();  \n        assert(len >= 2);             \n          \n        vector<int> ret(2, 0);  \n          \n        map<int, int> mapping;              // default all are 0  \n        vector<long long> mul(len, 0);  \n          \n        for(int i = 0; i < len; i++){  \n            mul[i] = (target - numbers[i]) * numbers[i];  \n              \n            if(mapping[mul[i]] > 0){        // not default 0  \n                if(numbers[i] + numbers[mapping[mul[i]] - 1] == target){  \n                    ret[0] = mapping[mul[i]];  \n                    ret[1] = i + 1;  \n                    break;  \n                }  \n                  \n            } \n            else {  \n                mapping[mul[i]] = i + 1;    // larger than 0  \n            }  \n        }  \n          \n        return ret;\n    }\n};\n```\n\n","source":"_posts/2Sum.md","raw":"---\ntitle: 2Sum\ncomments: true\ncategories:\n  - leetcode\ntags: C++\nabbrlink: 74d7ef89\ndate: 2018-11-15 23:50:54\n---\n\n**问题描述：**\n\nGiven an array of integers, find two numbers such that they add up to a specific target number.\n\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.\n\nYou may assume that each input would have exactly one solution.\n\nInput: numbers={2, 7, 11, 15}, target=9\nOutput: index1=1, index2=2\n\n**解决思路：**\n\n本题主要是在给定的一个数组中找到两个数的下标，使得这个两个数和为给定的值，要求给出的下标从1 开始，且满足递增顺序，有三种解决方法，复杂度分别为O(n^2),O(nlogn),O(n),具体实现如下：\n\n\n\n**复杂度为O(n^2) 代码：**\n\n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int> &numbers, int target) {\n        // Start typing your C/C++ solution below\n        // DO NOT write int main() function\n        vector<int> ret(2, 0);\n        \n        int len = numbers.size();\n        \n        for(int i = 0; i < len; i++)\n        {\n            int tmp = target - numbers[i];      // another number\n            for(int j = i + 1; j < len; j++)\n            {\n                if(tmp == numbers[j])\n                {\n                    ret[0] = i + 1;     // +1 for not zero-based\n                    ret[1] = j + 1;\n                    return ret;\n                }\n            }\n        }\n        \n        return ret;\n    }\n};\n```\n\n\n\n**复杂度O(nlogn)代码:**\n\n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int> &numbers, int target) {\n        vector<int> index;\n        int len = numbers.size();\n        vector<int> bak = numbers;\n        \n            \n        sort(bak.begin(),bak.end());\n        \n        int l = 0,r = len-1;\n        int sum = 0;\n        while(l < r){\n            sum = bak[l]+bak[r];\n            if(sum == target)\n            {\n                for(int i = 0; i < len;i++)\n                {\n                    if (bak[l] == numbers[i])\n                    {\n                        index.push_back(i+1);\n                    }\n                    else if(bak[r] == numbers[i])\n                    {\n                        index.push_back(i+1);\n                    }\n                    if(index.size() == 2)\n                    {\n                        break;\n                    }\n                }\n                break;\n                \n            }\n            else if(sum < target)\n            {\n                ++l;\n            }\n            else\n            {\n                --r;\n            }\n            \n        }\n        \n       return index;\n    }\n};\n```\n\n\n\n**复杂度O(n)代码:**\n\n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int> &numbers, int target) {\n        int len = numbers.size();  \n        assert(len >= 2);             \n          \n        vector<int> ret(2, 0);  \n          \n        map<int, int> mapping;              // default all are 0  \n        vector<long long> mul(len, 0);  \n          \n        for(int i = 0; i < len; i++){  \n            mul[i] = (target - numbers[i]) * numbers[i];  \n              \n            if(mapping[mul[i]] > 0){        // not default 0  \n                if(numbers[i] + numbers[mapping[mul[i]] - 1] == target){  \n                    ret[0] = mapping[mul[i]];  \n                    ret[1] = i + 1;  \n                    break;  \n                }  \n                  \n            } \n            else {  \n                mapping[mul[i]] = i + 1;    // larger than 0  \n            }  \n        }  \n          \n        return ret;\n    }\n};\n```\n\n","slug":"2Sum","published":1,"updated":"2018-11-15T16:02:33.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzonf0000tejeb2fz3azn","content":"<p><strong>问题描述：</strong></p>\n<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>\n<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>\n<p>You may assume that each input would have exactly one solution.</p>\n<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>\n<p><strong>解决思路：</strong></p>\n<p>本题主要是在给定的一个数组中找到两个数的下标，使得这个两个数和为给定的值，要求给出的下标从1 开始，且满足递增顺序，有三种解决方法，复杂度分别为O(n^2),O(nlogn),O(n),具体实现如下：</p>\n<p><strong>复杂度为O(n^2) 代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;numbers, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Start typing your C/C++ solution below</span></span><br><span class=\"line\">        <span class=\"comment\">// DO NOT write int main() function</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret(<span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = numbers.size();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = target - numbers[i];      <span class=\"comment\">// another number</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp == numbers[j])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ret[<span class=\"number\">0</span>] = i + <span class=\"number\">1</span>;     <span class=\"comment\">// +1 for not zero-based</span></span><br><span class=\"line\">                    ret[<span class=\"number\">1</span>] = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度O(nlogn)代码:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;numbers, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; index;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = numbers.size();</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; bak = numbers;</span><br><span class=\"line\">        </span><br><span class=\"line\">            </span><br><span class=\"line\">        sort(bak.begin(),bak.end());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>,r = len<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">            sum = bak[l]+bak[r];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum == target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len;i++)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (bak[l] == numbers[i])</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        index.push_back(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(bak[r] == numbers[i])</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        index.push_back(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(index.size() == <span class=\"number\">2</span>)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &lt; target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ++l;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                --r;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">       <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度O(n)代码:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;numbers, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = numbers.size();  </span><br><span class=\"line\">        assert(len &gt;= <span class=\"number\">2</span>);             </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret(<span class=\"number\">2</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; mapping;              <span class=\"comment\">// default all are 0  </span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>&gt; mul(len, <span class=\"number\">0</span>);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)&#123;  </span><br><span class=\"line\">            mul[i] = (target - numbers[i]) * numbers[i];  </span><br><span class=\"line\">              </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mapping[mul[i]] &gt; <span class=\"number\">0</span>)&#123;        <span class=\"comment\">// not default 0  </span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(numbers[i] + numbers[mapping[mul[i]] - <span class=\"number\">1</span>] == target)&#123;  </span><br><span class=\"line\">                    ret[<span class=\"number\">0</span>] = mapping[mul[i]];  </span><br><span class=\"line\">                    ret[<span class=\"number\">1</span>] = i + <span class=\"number\">1</span>;  </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                  </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                mapping[mul[i]] = i + <span class=\"number\">1</span>;    <span class=\"comment\">// larger than 0  </span></span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>\n<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>\n<p>You may assume that each input would have exactly one solution.</p>\n<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>\n<p><strong>解决思路：</strong></p>\n<p>本题主要是在给定的一个数组中找到两个数的下标，使得这个两个数和为给定的值，要求给出的下标从1 开始，且满足递增顺序，有三种解决方法，复杂度分别为O(n^2),O(nlogn),O(n),具体实现如下：</p>\n<p><strong>复杂度为O(n^2) 代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;numbers, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Start typing your C/C++ solution below</span></span><br><span class=\"line\">        <span class=\"comment\">// DO NOT write int main() function</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret(<span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = numbers.size();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = target - numbers[i];      <span class=\"comment\">// another number</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp == numbers[j])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ret[<span class=\"number\">0</span>] = i + <span class=\"number\">1</span>;     <span class=\"comment\">// +1 for not zero-based</span></span><br><span class=\"line\">                    ret[<span class=\"number\">1</span>] = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度O(nlogn)代码:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;numbers, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; index;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = numbers.size();</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; bak = numbers;</span><br><span class=\"line\">        </span><br><span class=\"line\">            </span><br><span class=\"line\">        sort(bak.begin(),bak.end());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>,r = len<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">            sum = bak[l]+bak[r];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum == target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len;i++)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (bak[l] == numbers[i])</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        index.push_back(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(bak[r] == numbers[i])</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        index.push_back(i+<span class=\"number\">1</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(index.size() == <span class=\"number\">2</span>)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &lt; target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ++l;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                --r;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">       <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度O(n)代码:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;numbers, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = numbers.size();  </span><br><span class=\"line\">        assert(len &gt;= <span class=\"number\">2</span>);             </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret(<span class=\"number\">2</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; mapping;              <span class=\"comment\">// default all are 0  </span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>&gt; mul(len, <span class=\"number\">0</span>);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)&#123;  </span><br><span class=\"line\">            mul[i] = (target - numbers[i]) * numbers[i];  </span><br><span class=\"line\">              </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mapping[mul[i]] &gt; <span class=\"number\">0</span>)&#123;        <span class=\"comment\">// not default 0  </span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(numbers[i] + numbers[mapping[mul[i]] - <span class=\"number\">1</span>] == target)&#123;  </span><br><span class=\"line\">                    ret[<span class=\"number\">0</span>] = mapping[mul[i]];  </span><br><span class=\"line\">                    ret[<span class=\"number\">1</span>] = i + <span class=\"number\">1</span>;  </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                  </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                mapping[mul[i]] = i + <span class=\"number\">1</span>;    <span class=\"comment\">// larger than 0  </span></span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"3Sum Closest","comments":1,"abbrlink":"c85f0a37","date":"2018-11-15T15:44:35.000Z","_content":"\n**问题描述：**\n\nGiven an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n For example, given array S = {-1 2 1 -4}, and target = 1.\n\n The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\n**解决思路：**\n\n我们可以在 2sum问题 的基础上来解决3sum问题，假设3sum问题的目标是target。每次从数组中选出一个数k，从剩下的数中求目标等于target-k的2sum问题。这里需要注意的是有个小的trick：当我们从数组中选出第i数时，我们只需要求数值中从第i+1个到最后一个范围内字数组的2sum问题。\n我们以选第一个和第二个举例，假设数组为A[],总共有n个元素A1，A2....An。很显然，当选出A1时，我们在子数组[A2~An]中求目标位target-A1的2sum问题，我们要证明的是当选出A2时，我们只需要在子数组[A3~An]中计算目标位target-A2的2sum问题，而不是在子数组[A1,A3~An]中，证明如下：\n假设在子数组[A1,A3~An]目标位target-A2的2sum问题中，存在A1 + m = target-A2（m为A3~An中的某个数），即A2 + m = target-A1，这刚好是“对于子数组[A3~An],目标位target-A1的2sum问题”的一个解。即我们相当于对满足3sum的三个数A1+A2+m = target重复计算了。因此为了避免重复计算，在子数组[A1，A3~An]中，可以把A1去掉，再来计算目标是target-A2的2sum问题。\n\n对于本题要求的求最接近解，只需要保存当前解以及当前解和目标的距离，如果新的解更接近，则更新解。算法复杂度为O（n^2）;\n注意：我们这里是求的和是一个非确定性的数，因此2sum问题的hashtable解法就不适合这里了\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    int threeSumClosest(vector<int> &num, int target) {\n        int n = num.size();\n        sort(num.begin(),num.end());\n        int res,dis=INT_MAX;\n        for(int i = 0;i<n-2;i++)\n        {\n            int target2 = target - num[i];\n            int tmpdis;\n            int tmpres = twoSumClosest(num,i+1,target2);\n            if((tmpdis = abs(tmpres-target2)) < dis)\n            {\n                res = tmpres + num[i];\n                dis = tmpdis;\n                if(res == target)\n                    return res;\n            }\n        }\n        return res;\n    }\n    \n    int twoSumClosest(vector<int> &sortnum,int start,int target){\n        int res,dis=INT_MAX;\n        int l = start,r = sortnum.size()-1;\n        while(l<r)\n        {\n            int sum = sortnum[l]+sortnum[r];\n            if(sum < target)\n            {\n                if(target-sum < dis)\n                {\n                    res = sum;\n                    dis = target - sum;\n                }\n                ++l;\n            }\n            else if(sum > target)\n            {\n                if(sum - target < dis)\n                {\n                    res = sum;\n                    dis = sum - target;\n                }\n                --r;\n            }\n            else\n                return target;\n        }\n        return res;\n    }\n};\n```\n\n","source":"_posts/3Sum-Closest.md","raw":"---\ntitle: 3Sum Closest\ncomments: true\ncategories:\n  - leetcode\ntags: C++\nabbrlink: c85f0a37\ndate: 2018-11-15 23:44:35\n---\n\n**问题描述：**\n\nGiven an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n For example, given array S = {-1 2 1 -4}, and target = 1.\n\n The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\n**解决思路：**\n\n我们可以在 2sum问题 的基础上来解决3sum问题，假设3sum问题的目标是target。每次从数组中选出一个数k，从剩下的数中求目标等于target-k的2sum问题。这里需要注意的是有个小的trick：当我们从数组中选出第i数时，我们只需要求数值中从第i+1个到最后一个范围内字数组的2sum问题。\n我们以选第一个和第二个举例，假设数组为A[],总共有n个元素A1，A2....An。很显然，当选出A1时，我们在子数组[A2~An]中求目标位target-A1的2sum问题，我们要证明的是当选出A2时，我们只需要在子数组[A3~An]中计算目标位target-A2的2sum问题，而不是在子数组[A1,A3~An]中，证明如下：\n假设在子数组[A1,A3~An]目标位target-A2的2sum问题中，存在A1 + m = target-A2（m为A3~An中的某个数），即A2 + m = target-A1，这刚好是“对于子数组[A3~An],目标位target-A1的2sum问题”的一个解。即我们相当于对满足3sum的三个数A1+A2+m = target重复计算了。因此为了避免重复计算，在子数组[A1，A3~An]中，可以把A1去掉，再来计算目标是target-A2的2sum问题。\n\n对于本题要求的求最接近解，只需要保存当前解以及当前解和目标的距离，如果新的解更接近，则更新解。算法复杂度为O（n^2）;\n注意：我们这里是求的和是一个非确定性的数，因此2sum问题的hashtable解法就不适合这里了\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    int threeSumClosest(vector<int> &num, int target) {\n        int n = num.size();\n        sort(num.begin(),num.end());\n        int res,dis=INT_MAX;\n        for(int i = 0;i<n-2;i++)\n        {\n            int target2 = target - num[i];\n            int tmpdis;\n            int tmpres = twoSumClosest(num,i+1,target2);\n            if((tmpdis = abs(tmpres-target2)) < dis)\n            {\n                res = tmpres + num[i];\n                dis = tmpdis;\n                if(res == target)\n                    return res;\n            }\n        }\n        return res;\n    }\n    \n    int twoSumClosest(vector<int> &sortnum,int start,int target){\n        int res,dis=INT_MAX;\n        int l = start,r = sortnum.size()-1;\n        while(l<r)\n        {\n            int sum = sortnum[l]+sortnum[r];\n            if(sum < target)\n            {\n                if(target-sum < dis)\n                {\n                    res = sum;\n                    dis = target - sum;\n                }\n                ++l;\n            }\n            else if(sum > target)\n            {\n                if(sum - target < dis)\n                {\n                    res = sum;\n                    dis = sum - target;\n                }\n                --r;\n            }\n            else\n                return target;\n        }\n        return res;\n    }\n};\n```\n\n","slug":"3Sum-Closest","published":1,"updated":"2018-11-15T16:28:11.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzonk0002tejego15bsh1","content":"<p><strong>问题描述：</strong></p>\n<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>\n<p> For example, given array S = {-1 2 1 -4}, and target = 1.</p>\n<p> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>\n<p><strong>解决思路：</strong></p>\n<p>我们可以在 2sum问题 的基础上来解决3sum问题，假设3sum问题的目标是target。每次从数组中选出一个数k，从剩下的数中求目标等于target-k的2sum问题。这里需要注意的是有个小的trick：当我们从数组中选出第i数时，我们只需要求数值中从第i+1个到最后一个范围内字数组的2sum问题。<br>我们以选第一个和第二个举例，假设数组为A[],总共有n个元素A1，A2….An。很显然，当选出A1时，我们在子数组[A2~An]中求目标位target-A1的2sum问题，我们要证明的是当选出A2时，我们只需要在子数组[A3~An]中计算目标位target-A2的2sum问题，而不是在子数组[A1,A3~An]中，证明如下：<br>假设在子数组[A1,A3~An]目标位target-A2的2sum问题中，存在A1 + m = target-A2（m为A3~An中的某个数），即A2 + m = target-A1，这刚好是“对于子数组[A3~An],目标位target-A1的2sum问题”的一个解。即我们相当于对满足3sum的三个数A1+A2+m = target重复计算了。因此为了避免重复计算，在子数组[A1，A3~An]中，可以把A1去掉，再来计算目标是target-A2的2sum问题。</p>\n<p>对于本题要求的求最接近解，只需要保存当前解以及当前解和目标的距离，如果新的解更接近，则更新解。算法复杂度为O（n^2）;<br>注意：我们这里是求的和是一个非确定性的数，因此2sum问题的hashtable解法就不适合这里了</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = num.size();</span><br><span class=\"line\">        sort(num.begin(),num.end());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res,dis=INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n<span class=\"number\">-2</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> target2 = target - num[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmpdis;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmpres = twoSumClosest(num,i+<span class=\"number\">1</span>,target2);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((tmpdis = <span class=\"built_in\">abs</span>(tmpres-target2)) &lt; dis)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                res = tmpres + num[i];</span><br><span class=\"line\">                dis = tmpdis;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(res == target)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">twoSumClosest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;sortnum,<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res,dis=INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = start,r = sortnum.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&lt;r)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = sortnum[l]+sortnum[r];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum &lt; target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target-sum &lt; dis)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    res = sum;</span><br><span class=\"line\">                    dis = target - sum;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ++l;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &gt; target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(sum - target &lt; dis)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    res = sum;</span><br><span class=\"line\">                    dis = sum - target;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                --r;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>\n<p> For example, given array S = {-1 2 1 -4}, and target = 1.</p>\n<p> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>\n<p><strong>解决思路：</strong></p>\n<p>我们可以在 2sum问题 的基础上来解决3sum问题，假设3sum问题的目标是target。每次从数组中选出一个数k，从剩下的数中求目标等于target-k的2sum问题。这里需要注意的是有个小的trick：当我们从数组中选出第i数时，我们只需要求数值中从第i+1个到最后一个范围内字数组的2sum问题。<br>我们以选第一个和第二个举例，假设数组为A[],总共有n个元素A1，A2….An。很显然，当选出A1时，我们在子数组[A2~An]中求目标位target-A1的2sum问题，我们要证明的是当选出A2时，我们只需要在子数组[A3~An]中计算目标位target-A2的2sum问题，而不是在子数组[A1,A3~An]中，证明如下：<br>假设在子数组[A1,A3~An]目标位target-A2的2sum问题中，存在A1 + m = target-A2（m为A3~An中的某个数），即A2 + m = target-A1，这刚好是“对于子数组[A3~An],目标位target-A1的2sum问题”的一个解。即我们相当于对满足3sum的三个数A1+A2+m = target重复计算了。因此为了避免重复计算，在子数组[A1，A3~An]中，可以把A1去掉，再来计算目标是target-A2的2sum问题。</p>\n<p>对于本题要求的求最接近解，只需要保存当前解以及当前解和目标的距离，如果新的解更接近，则更新解。算法复杂度为O（n^2）;<br>注意：我们这里是求的和是一个非确定性的数，因此2sum问题的hashtable解法就不适合这里了</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = num.size();</span><br><span class=\"line\">        sort(num.begin(),num.end());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res,dis=INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n<span class=\"number\">-2</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> target2 = target - num[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmpdis;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmpres = twoSumClosest(num,i+<span class=\"number\">1</span>,target2);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((tmpdis = <span class=\"built_in\">abs</span>(tmpres-target2)) &lt; dis)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                res = tmpres + num[i];</span><br><span class=\"line\">                dis = tmpdis;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(res == target)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">twoSumClosest</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;sortnum,<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res,dis=INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = start,r = sortnum.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&lt;r)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = sortnum[l]+sortnum[r];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum &lt; target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target-sum &lt; dis)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    res = sum;</span><br><span class=\"line\">                    dis = target - sum;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ++l;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &gt; target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(sum - target &lt; dis)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    res = sum;</span><br><span class=\"line\">                    dis = sum - target;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                --r;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"4Sum","comments":1,"abbrlink":"51bcb055","date":"2018-11-15T15:44:12.000Z","_content":"\n**问题描述**\nGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\n\nNote: The solution set must not contain duplicate quadruplets.\n\nFor example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.\n\nA solution set is: \n\n```\n[ \n[-1, 0, 0, 1], \n[-2, -1, 1, 2], \n[-2, 0, 0, 2] \n]\n```\n\n**算法1：O(n^3)**\n\n我们可以仿照3sum的解决方法。这里枚举第一个和第二个数，然后对余下数的求2sum，算法复杂度为O（n^3）\n\n代码：\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int> > fourSum(vector<int> &num, int target) {\n        int n = num.size();\n        sort(num.begin(),num.end());\n        vector<vector<int>> res;\n        \n        vector<int> quard(4,0);\n        for(int i = 0; i < n-3; i++)\n        {\n            if(i > 0 && num[i] == num[i-1]) continue;\n            for(int j = i + 1; j < n -2; j++)\n            {\n                if(j > i+1 && num[j] == num[j-1]) continue;\n                int l = j+1,r=n-1;\n                int target2 = target - num[i] - num[j];\n                while(l<r)\n                {\n                    int sum = num[l] + num[r];\n                    if(sum < target2)\n                    {\n                        ++l;\n                    }\n                    else if(sum > target2)\n                    {\n                        --r;\n                    }\n                    else\n                    {\n                        quard[0] = num[i];\n                        quard[1] = num[j];\n                        quard[2] = num[l];\n                        quard[3] = num[r];\n                        res.push_back(quard);\n                        \n                        int k = l + 1;\n                        while(k < r && num[k] == num[l])k++;\n                        l = k;\n                        \n                        k = r-1;\n                        while(k > l && num[k] == num[r])k--;\n                        r = k;\n                        \n                    }\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n\n\n**算法2：O（n^2）的算法**\n\n和前面相同，都是先对数组排序。我们先枚举出所有二个数的和存放在哈希map中，其中map的key对应的是二个数的和，因为多对元素求和可能是相同的值，故哈希map的value是一个链表（下面的代码中用数组代替），链表每个节点存的是这两个数在数组的下标；这个预处理的时间复杂度是O（n^2）。接着和算法1类似，枚举第一个和第二个元素，假设分别为v1,v2, 然后在哈希map中查找和为target-v1-v2的所有二元对（在对应的链表中），查找的时间为O（1），为了保证不重复计算，我们只保留两个数下标都大于V2的二元对（其实我们在前面3sum问题中所求得的三个数在排序后的数组中下标都是递增的），即时是这样也有可能重复：比如排好序后数组为-9 -4 -2 0 2 4 4，target = 0，当第一个和第二个元素分别是-4，-2时，我们要得到和为0-（-2）-（-4） = 6的二元对，这样的二元对有两个,都是(2,4)，且他们在数组中的下标都大于-4和-2，如果都加入结果，则(-4,-2,2,4)会出现两次，因此在加入二元对时，要判断是否和已经加入的二元对重复（由于过早二元对之前数组已经排过序，所以两个元素都相同的二元对可以保证在链表中是相邻的，链表不会出现(2,4)->(1,5)->(2,4)的情况，因此只要判断新加入的二元对和上一个加入的二元对是否重复即可），因为同一个链表中的二元对两个元素的和都是相同的，因此只要二元对的一个元素不同，则这个二元对就不同。我们可以认为哈希map中key对应的链表长度为常数，那么算法总的复杂度为O（n^2）\n\n代码：\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int> > fourSum(vector<int> &num, int target) {\n        int n = num.size();\n        vector<vector<int> > res;\n        unordered_map<int, vector<pair<int, int> > >pairs;\n        pairs.reserve(n*n);\n        sort(num.begin(), num.end());\n        \n        for(int i = 0; i < n; i++)\n            for(int j = i+1 ; j < n; j++)\n                pairs[num[i]+num[j]].push_back(make_pair(i,j));\n        \n        for(int i = 0; i < n - 3; i++)\n        {\n            if(i != 0 && num[i] == num[i-1])continue;//防止第一个元素重复\n            for(int j = i+1; j < n - 2; j++)\n            {\n                if(j != i+1 && num[j] == num[j-1])continue;//防止第二个元素重复\n                if(pairs.find(target - num[i] - num[j]) != pairs.end())\n                {\n                    vector<pair<int, int>> &sum2 = pairs[target - num[i] - num[j]];\n                    bool isFirstPush = true;\n                    for(int k = 0; k < sum2.size(); k++)\n                    {\n                        if(sum2[k].first <= j)continue;//保证所求的四元组的数组下标是递增的\n                        if(isFirstPush || (res.back())[2] != num[sum2[k].first])\n                        {\n                            res.push_back(vector<int>{num[i], num[j], num[sum2[k].first], num[sum2[k].second]});\n                            isFirstPush = false;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n```\n\n","source":"_posts/4Sum.md","raw":"---\ntitle: 4Sum\ncomments: true\ncategories:\n  - leetcode\ntags: C++\nabbrlink: 51bcb055\ndate: 2018-11-15 23:44:12\n---\n\n**问题描述**\nGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\n\nNote: The solution set must not contain duplicate quadruplets.\n\nFor example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.\n\nA solution set is: \n\n```\n[ \n[-1, 0, 0, 1], \n[-2, -1, 1, 2], \n[-2, 0, 0, 2] \n]\n```\n\n**算法1：O(n^3)**\n\n我们可以仿照3sum的解决方法。这里枚举第一个和第二个数，然后对余下数的求2sum，算法复杂度为O（n^3）\n\n代码：\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int> > fourSum(vector<int> &num, int target) {\n        int n = num.size();\n        sort(num.begin(),num.end());\n        vector<vector<int>> res;\n        \n        vector<int> quard(4,0);\n        for(int i = 0; i < n-3; i++)\n        {\n            if(i > 0 && num[i] == num[i-1]) continue;\n            for(int j = i + 1; j < n -2; j++)\n            {\n                if(j > i+1 && num[j] == num[j-1]) continue;\n                int l = j+1,r=n-1;\n                int target2 = target - num[i] - num[j];\n                while(l<r)\n                {\n                    int sum = num[l] + num[r];\n                    if(sum < target2)\n                    {\n                        ++l;\n                    }\n                    else if(sum > target2)\n                    {\n                        --r;\n                    }\n                    else\n                    {\n                        quard[0] = num[i];\n                        quard[1] = num[j];\n                        quard[2] = num[l];\n                        quard[3] = num[r];\n                        res.push_back(quard);\n                        \n                        int k = l + 1;\n                        while(k < r && num[k] == num[l])k++;\n                        l = k;\n                        \n                        k = r-1;\n                        while(k > l && num[k] == num[r])k--;\n                        r = k;\n                        \n                    }\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n\n\n**算法2：O（n^2）的算法**\n\n和前面相同，都是先对数组排序。我们先枚举出所有二个数的和存放在哈希map中，其中map的key对应的是二个数的和，因为多对元素求和可能是相同的值，故哈希map的value是一个链表（下面的代码中用数组代替），链表每个节点存的是这两个数在数组的下标；这个预处理的时间复杂度是O（n^2）。接着和算法1类似，枚举第一个和第二个元素，假设分别为v1,v2, 然后在哈希map中查找和为target-v1-v2的所有二元对（在对应的链表中），查找的时间为O（1），为了保证不重复计算，我们只保留两个数下标都大于V2的二元对（其实我们在前面3sum问题中所求得的三个数在排序后的数组中下标都是递增的），即时是这样也有可能重复：比如排好序后数组为-9 -4 -2 0 2 4 4，target = 0，当第一个和第二个元素分别是-4，-2时，我们要得到和为0-（-2）-（-4） = 6的二元对，这样的二元对有两个,都是(2,4)，且他们在数组中的下标都大于-4和-2，如果都加入结果，则(-4,-2,2,4)会出现两次，因此在加入二元对时，要判断是否和已经加入的二元对重复（由于过早二元对之前数组已经排过序，所以两个元素都相同的二元对可以保证在链表中是相邻的，链表不会出现(2,4)->(1,5)->(2,4)的情况，因此只要判断新加入的二元对和上一个加入的二元对是否重复即可），因为同一个链表中的二元对两个元素的和都是相同的，因此只要二元对的一个元素不同，则这个二元对就不同。我们可以认为哈希map中key对应的链表长度为常数，那么算法总的复杂度为O（n^2）\n\n代码：\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int> > fourSum(vector<int> &num, int target) {\n        int n = num.size();\n        vector<vector<int> > res;\n        unordered_map<int, vector<pair<int, int> > >pairs;\n        pairs.reserve(n*n);\n        sort(num.begin(), num.end());\n        \n        for(int i = 0; i < n; i++)\n            for(int j = i+1 ; j < n; j++)\n                pairs[num[i]+num[j]].push_back(make_pair(i,j));\n        \n        for(int i = 0; i < n - 3; i++)\n        {\n            if(i != 0 && num[i] == num[i-1])continue;//防止第一个元素重复\n            for(int j = i+1; j < n - 2; j++)\n            {\n                if(j != i+1 && num[j] == num[j-1])continue;//防止第二个元素重复\n                if(pairs.find(target - num[i] - num[j]) != pairs.end())\n                {\n                    vector<pair<int, int>> &sum2 = pairs[target - num[i] - num[j]];\n                    bool isFirstPush = true;\n                    for(int k = 0; k < sum2.size(); k++)\n                    {\n                        if(sum2[k].first <= j)continue;//保证所求的四元组的数组下标是递增的\n                        if(isFirstPush || (res.back())[2] != num[sum2[k].first])\n                        {\n                            res.push_back(vector<int>{num[i], num[j], num[sum2[k].first], num[sum2[k].second]});\n                            isFirstPush = false;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n```\n\n","slug":"4Sum","published":1,"updated":"2018-11-15T16:28:10.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzonp0006tejetrfx7o3v","content":"<p><strong>问题描述</strong><br>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>\n<p>Note: The solution set must not contain duplicate quadruplets.</p>\n<p>For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</p>\n<p>A solution set is: </p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ </span><br><span class=\"line\">[<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>], </span><br><span class=\"line\">[<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], </span><br><span class=\"line\">[<span class=\"number\">-2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>] </span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p><strong>算法1：O(n^3)</strong></p>\n<p>我们可以仿照3sum的解决方法。这里枚举第一个和第二个数，然后对余下数的求2sum，算法复杂度为O（n^3）</p>\n<p>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; fourSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = num.size();</span><br><span class=\"line\">        sort(num.begin(),num.end());</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; quard(<span class=\"number\">4</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n<span class=\"number\">-3</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt; <span class=\"number\">0</span> &amp;&amp; num[i] == num[i<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; n <span class=\"number\">-2</span>; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j &gt; i+<span class=\"number\">1</span> &amp;&amp; num[j] == num[j<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> l = j+<span class=\"number\">1</span>,r=n<span class=\"number\">-1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> target2 = target - num[i] - num[j];</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(l&lt;r)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum = num[l] + num[r];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(sum &lt; target2)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        ++l;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &gt; target2)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        --r;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        quard[<span class=\"number\">0</span>] = num[i];</span><br><span class=\"line\">                        quard[<span class=\"number\">1</span>] = num[j];</span><br><span class=\"line\">                        quard[<span class=\"number\">2</span>] = num[l];</span><br><span class=\"line\">                        quard[<span class=\"number\">3</span>] = num[r];</span><br><span class=\"line\">                        res.push_back(quard);</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        <span class=\"keyword\">int</span> k = l + <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span>(k &lt; r &amp;&amp; num[k] == num[l])k++;</span><br><span class=\"line\">                        l = k;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        k = r<span class=\"number\">-1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span>(k &gt; l &amp;&amp; num[k] == num[r])k--;</span><br><span class=\"line\">                        r = k;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>算法2：O（n^2）的算法</strong></p>\n<p>和前面相同，都是先对数组排序。我们先枚举出所有二个数的和存放在哈希map中，其中map的key对应的是二个数的和，因为多对元素求和可能是相同的值，故哈希map的value是一个链表（下面的代码中用数组代替），链表每个节点存的是这两个数在数组的下标；这个预处理的时间复杂度是O（n^2）。接着和算法1类似，枚举第一个和第二个元素，假设分别为v1,v2, 然后在哈希map中查找和为target-v1-v2的所有二元对（在对应的链表中），查找的时间为O（1），为了保证不重复计算，我们只保留两个数下标都大于V2的二元对（其实我们在前面3sum问题中所求得的三个数在排序后的数组中下标都是递增的），即时是这样也有可能重复：比如排好序后数组为-9 -4 -2 0 2 4 4，target = 0，当第一个和第二个元素分别是-4，-2时，我们要得到和为0-（-2）-（-4） = 6的二元对，这样的二元对有两个,都是(2,4)，且他们在数组中的下标都大于-4和-2，如果都加入结果，则(-4,-2,2,4)会出现两次，因此在加入二元对时，要判断是否和已经加入的二元对重复（由于过早二元对之前数组已经排过序，所以两个元素都相同的二元对可以保证在链表中是相邻的，链表不会出现(2,4)-&gt;(1,5)-&gt;(2,4)的情况，因此只要判断新加入的二元对和上一个加入的二元对是否重复即可），因为同一个链表中的二元对两个元素的和都是相同的，因此只要二元对的一个元素不同，则这个二元对就不同。我们可以认为哈希map中key对应的链表长度为常数，那么算法总的复杂度为O（n^2）</p>\n<p>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; fourSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = num.size();</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; &gt;pairs;</span><br><span class=\"line\">        pairs.reserve(n*n);</span><br><span class=\"line\">        sort(num.begin(), num.end());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span> ; j &lt; n; j++)</span><br><span class=\"line\">                pairs[num[i]+num[j]].push_back(make_pair(i,j));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i != <span class=\"number\">0</span> &amp;&amp; num[i] == num[i<span class=\"number\">-1</span>])<span class=\"keyword\">continue</span>;<span class=\"comment\">//防止第一个元素重复</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; n - <span class=\"number\">2</span>; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j != i+<span class=\"number\">1</span> &amp;&amp; num[j] == num[j<span class=\"number\">-1</span>])<span class=\"keyword\">continue</span>;<span class=\"comment\">//防止第二个元素重复</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(pairs.find(target - num[i] - num[j]) != pairs.end())</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; &amp;sum2 = pairs[target - num[i] - num[j]];</span><br><span class=\"line\">                    <span class=\"keyword\">bool</span> isFirstPush = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; sum2.size(); k++)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(sum2[k].first &lt;= j)<span class=\"keyword\">continue</span>;<span class=\"comment\">//保证所求的四元组的数组下标是递增的</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(isFirstPush || (res.back())[<span class=\"number\">2</span>] != num[sum2[k].first])</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            res.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;num[i], num[j], num[sum2[k].first], num[sum2[k].second]&#125;);</span><br><span class=\"line\">                            isFirstPush = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述</strong><br>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>\n<p>Note: The solution set must not contain duplicate quadruplets.</p>\n<p>For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</p>\n<p>A solution set is: </p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ </span><br><span class=\"line\">[<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>], </span><br><span class=\"line\">[<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], </span><br><span class=\"line\">[<span class=\"number\">-2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>] </span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p><strong>算法1：O(n^3)</strong></p>\n<p>我们可以仿照3sum的解决方法。这里枚举第一个和第二个数，然后对余下数的求2sum，算法复杂度为O（n^3）</p>\n<p>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; fourSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = num.size();</span><br><span class=\"line\">        sort(num.begin(),num.end());</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; quard(<span class=\"number\">4</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n<span class=\"number\">-3</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt; <span class=\"number\">0</span> &amp;&amp; num[i] == num[i<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; n <span class=\"number\">-2</span>; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j &gt; i+<span class=\"number\">1</span> &amp;&amp; num[j] == num[j<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> l = j+<span class=\"number\">1</span>,r=n<span class=\"number\">-1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> target2 = target - num[i] - num[j];</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(l&lt;r)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum = num[l] + num[r];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(sum &lt; target2)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        ++l;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &gt; target2)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        --r;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        quard[<span class=\"number\">0</span>] = num[i];</span><br><span class=\"line\">                        quard[<span class=\"number\">1</span>] = num[j];</span><br><span class=\"line\">                        quard[<span class=\"number\">2</span>] = num[l];</span><br><span class=\"line\">                        quard[<span class=\"number\">3</span>] = num[r];</span><br><span class=\"line\">                        res.push_back(quard);</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        <span class=\"keyword\">int</span> k = l + <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span>(k &lt; r &amp;&amp; num[k] == num[l])k++;</span><br><span class=\"line\">                        l = k;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        k = r<span class=\"number\">-1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span>(k &gt; l &amp;&amp; num[k] == num[r])k--;</span><br><span class=\"line\">                        r = k;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>算法2：O（n^2）的算法</strong></p>\n<p>和前面相同，都是先对数组排序。我们先枚举出所有二个数的和存放在哈希map中，其中map的key对应的是二个数的和，因为多对元素求和可能是相同的值，故哈希map的value是一个链表（下面的代码中用数组代替），链表每个节点存的是这两个数在数组的下标；这个预处理的时间复杂度是O（n^2）。接着和算法1类似，枚举第一个和第二个元素，假设分别为v1,v2, 然后在哈希map中查找和为target-v1-v2的所有二元对（在对应的链表中），查找的时间为O（1），为了保证不重复计算，我们只保留两个数下标都大于V2的二元对（其实我们在前面3sum问题中所求得的三个数在排序后的数组中下标都是递增的），即时是这样也有可能重复：比如排好序后数组为-9 -4 -2 0 2 4 4，target = 0，当第一个和第二个元素分别是-4，-2时，我们要得到和为0-（-2）-（-4） = 6的二元对，这样的二元对有两个,都是(2,4)，且他们在数组中的下标都大于-4和-2，如果都加入结果，则(-4,-2,2,4)会出现两次，因此在加入二元对时，要判断是否和已经加入的二元对重复（由于过早二元对之前数组已经排过序，所以两个元素都相同的二元对可以保证在链表中是相邻的，链表不会出现(2,4)-&gt;(1,5)-&gt;(2,4)的情况，因此只要判断新加入的二元对和上一个加入的二元对是否重复即可），因为同一个链表中的二元对两个元素的和都是相同的，因此只要二元对的一个元素不同，则这个二元对就不同。我们可以认为哈希map中key对应的链表长度为常数，那么算法总的复杂度为O（n^2）</p>\n<p>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; fourSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = num.size();</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; &gt; &gt;pairs;</span><br><span class=\"line\">        pairs.reserve(n*n);</span><br><span class=\"line\">        sort(num.begin(), num.end());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span> ; j &lt; n; j++)</span><br><span class=\"line\">                pairs[num[i]+num[j]].push_back(make_pair(i,j));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i != <span class=\"number\">0</span> &amp;&amp; num[i] == num[i<span class=\"number\">-1</span>])<span class=\"keyword\">continue</span>;<span class=\"comment\">//防止第一个元素重复</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; n - <span class=\"number\">2</span>; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j != i+<span class=\"number\">1</span> &amp;&amp; num[j] == num[j<span class=\"number\">-1</span>])<span class=\"keyword\">continue</span>;<span class=\"comment\">//防止第二个元素重复</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(pairs.find(target - num[i] - num[j]) != pairs.end())</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; &amp;sum2 = pairs[target - num[i] - num[j]];</span><br><span class=\"line\">                    <span class=\"keyword\">bool</span> isFirstPush = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; sum2.size(); k++)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(sum2[k].first &lt;= j)<span class=\"keyword\">continue</span>;<span class=\"comment\">//保证所求的四元组的数组下标是递增的</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(isFirstPush || (res.back())[<span class=\"number\">2</span>] != num[sum2[k].first])</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            res.push_back(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;num[i], num[j], num[sum2[k].first], num[sum2[k].second]&#125;);</span><br><span class=\"line\">                            isFirstPush = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"3Sum","comments":1,"abbrlink":"cc6b88ec","date":"2018-11-15T15:50:50.000Z","_content":"\n**问题描述：**\n\nGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\nNote:\n\nElements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)\nThe solution set must not contain duplicate triplets.\n​    For example, given array S = {-1 0 1 2 -1 -4},\n\n    A solution set is:\n    (-1, 0, 1)\n    (-1, -1, 2)\n**解决思路：**\n\n3sum的时候，先整体排一次序，然后枚举第三个数字的时候不需要重复， 比如排好序以后的数字是 a b c d e f, 那么第一次枚举a, 在剩下的b c d e f中进行2 sum, 完了以后第二次枚举b, 只需要在 c d e f中进行2sum好了，而不是在a c d e f中进行2sum, 这个大家可以自己体会一下，想通了还是挺有帮助的。\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int> > threeSum(vector<int> &num) {\n        sort(num.begin(),num.end());\n        int len = num.size();\n        vector<vector<int>> result;\n        if(len < 3)\n            return result;\n        \n        int iCount = len - 2;\n        vector<int> truple(3,0);\n        int CurrentVal = num[0];\n        \n        for(int i = 0; i < iCount;i++)\n        {\n            if(i && num[i] == CurrentVal)\n            {\n                continue;\n            }\n            truple[0] = num[i];\n            int l = i + 1;\n            int r = len - 1;\n            while(l<r)\n            {\n                int iSum = num[l] + num[r];\n                if(iSum + truple[0] == 0)\n                {\n                    truple[1] = num[l];\n                    truple[2] = num[r];\n                    if(result.size() == 0 || truple != result[result.size()-1])\n                        result.push_back(truple);\n                    ++l;\n                    --r;\n                }\n                else if(iSum + truple[0] < 0)\n                {\n                    ++l;\n                }\n                else\n                {\n                    --r;\n                }\n            }\n            CurrentVal = num[i];\n          \n        }\n        return result;\n    }\n    \n};\n```\n\n\n\n这是一篇关于[kSum问题的总结性文章](http://tech-wonderland.net/blog/summary-of-ksum-problems.html)。","source":"_posts/3Sum.md","raw":"---\ntitle: 3Sum\ncomments: true\ncategories:\n  - leetcode\ntags: C++\nabbrlink: cc6b88ec\ndate: 2018-11-15 23:50:50\n---\n\n**问题描述：**\n\nGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\nNote:\n\nElements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)\nThe solution set must not contain duplicate triplets.\n​    For example, given array S = {-1 0 1 2 -1 -4},\n\n    A solution set is:\n    (-1, 0, 1)\n    (-1, -1, 2)\n**解决思路：**\n\n3sum的时候，先整体排一次序，然后枚举第三个数字的时候不需要重复， 比如排好序以后的数字是 a b c d e f, 那么第一次枚举a, 在剩下的b c d e f中进行2 sum, 完了以后第二次枚举b, 只需要在 c d e f中进行2sum好了，而不是在a c d e f中进行2sum, 这个大家可以自己体会一下，想通了还是挺有帮助的。\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int> > threeSum(vector<int> &num) {\n        sort(num.begin(),num.end());\n        int len = num.size();\n        vector<vector<int>> result;\n        if(len < 3)\n            return result;\n        \n        int iCount = len - 2;\n        vector<int> truple(3,0);\n        int CurrentVal = num[0];\n        \n        for(int i = 0; i < iCount;i++)\n        {\n            if(i && num[i] == CurrentVal)\n            {\n                continue;\n            }\n            truple[0] = num[i];\n            int l = i + 1;\n            int r = len - 1;\n            while(l<r)\n            {\n                int iSum = num[l] + num[r];\n                if(iSum + truple[0] == 0)\n                {\n                    truple[1] = num[l];\n                    truple[2] = num[r];\n                    if(result.size() == 0 || truple != result[result.size()-1])\n                        result.push_back(truple);\n                    ++l;\n                    --r;\n                }\n                else if(iSum + truple[0] < 0)\n                {\n                    ++l;\n                }\n                else\n                {\n                    --r;\n                }\n            }\n            CurrentVal = num[i];\n          \n        }\n        return result;\n    }\n    \n};\n```\n\n\n\n这是一篇关于[kSum问题的总结性文章](http://tech-wonderland.net/blog/summary-of-ksum-problems.html)。","slug":"3Sum","published":1,"updated":"2018-11-15T16:28:12.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzonr0007teje4czdgibi","content":"<p><strong>问题描述：</strong></p>\n<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n<p>Note:</p>\n<p>Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)<br>The solution set must not contain duplicate triplets.<br>​    For example, given array S = {-1 0 1 2 -1 -4},</p>\n<pre><code>A solution set is:\n(-1, 0, 1)\n(-1, -1, 2)\n</code></pre><p><strong>解决思路：</strong></p>\n<p>3sum的时候，先整体排一次序，然后枚举第三个数字的时候不需要重复， 比如排好序以后的数字是 a b c d e f, 那么第一次枚举a, 在剩下的b c d e f中进行2 sum, 完了以后第二次枚举b, 只需要在 c d e f中进行2sum好了，而不是在a c d e f中进行2sum, 这个大家可以自己体会一下，想通了还是挺有帮助的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; threeSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num) &#123;</span><br><span class=\"line\">        sort(num.begin(),num.end());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = num.size();</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len &lt; <span class=\"number\">3</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> iCount = len - <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; truple(<span class=\"number\">3</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> CurrentVal = num[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; iCount;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &amp;&amp; num[i] == CurrentVal)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            truple[<span class=\"number\">0</span>] = num[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> r = len - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l&lt;r)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> iSum = num[l] + num[r];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(iSum + truple[<span class=\"number\">0</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    truple[<span class=\"number\">1</span>] = num[l];</span><br><span class=\"line\">                    truple[<span class=\"number\">2</span>] = num[r];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(result.size() == <span class=\"number\">0</span> || truple != result[result.size()<span class=\"number\">-1</span>])</span><br><span class=\"line\">                        result.push_back(truple);</span><br><span class=\"line\">                    ++l;</span><br><span class=\"line\">                    --r;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(iSum + truple[<span class=\"number\">0</span>] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ++l;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    --r;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            CurrentVal = num[i];</span><br><span class=\"line\">          </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这是一篇关于<a href=\"http://tech-wonderland.net/blog/summary-of-ksum-problems.html\" target=\"_blank\" rel=\"noopener\">kSum问题的总结性文章</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n<p>Note:</p>\n<p>Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)<br>The solution set must not contain duplicate triplets.<br>​    For example, given array S = {-1 0 1 2 -1 -4},</p>\n<pre><code>A solution set is:\n(-1, 0, 1)\n(-1, -1, 2)\n</code></pre><p><strong>解决思路：</strong></p>\n<p>3sum的时候，先整体排一次序，然后枚举第三个数字的时候不需要重复， 比如排好序以后的数字是 a b c d e f, 那么第一次枚举a, 在剩下的b c d e f中进行2 sum, 完了以后第二次枚举b, 只需要在 c d e f中进行2sum好了，而不是在a c d e f中进行2sum, 这个大家可以自己体会一下，想通了还是挺有帮助的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; threeSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num) &#123;</span><br><span class=\"line\">        sort(num.begin(),num.end());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = num.size();</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len &lt; <span class=\"number\">3</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> iCount = len - <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; truple(<span class=\"number\">3</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> CurrentVal = num[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; iCount;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &amp;&amp; num[i] == CurrentVal)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            truple[<span class=\"number\">0</span>] = num[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> r = len - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l&lt;r)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> iSum = num[l] + num[r];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(iSum + truple[<span class=\"number\">0</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    truple[<span class=\"number\">1</span>] = num[l];</span><br><span class=\"line\">                    truple[<span class=\"number\">2</span>] = num[r];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(result.size() == <span class=\"number\">0</span> || truple != result[result.size()<span class=\"number\">-1</span>])</span><br><span class=\"line\">                        result.push_back(truple);</span><br><span class=\"line\">                    ++l;</span><br><span class=\"line\">                    --r;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(iSum + truple[<span class=\"number\">0</span>] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ++l;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    --r;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            CurrentVal = num[i];</span><br><span class=\"line\">          </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这是一篇关于<a href=\"http://tech-wonderland.net/blog/summary-of-ksum-problems.html\" target=\"_blank\" rel=\"noopener\">kSum问题的总结性文章</a>。</p>\n"},{"title":"Balanced Binary Tree","comments":1,"abbrlink":"5c1c4dd0","date":"2018-11-15T16:14:50.000Z","_content":"\n**问题描述：**\n\nGiven a binary tree, determine if it is height-balanced.\n\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n\n**解决思路：**\n\n首先设计一个求二叉树高度的函数，然后调用该函数比较左右子树的高度差即可。\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int height(TreeNode *root){\n        if(root == NULL)\n            return 0;\n        int hr,hl;\n        hl = height(root->left);\n        hr = height(root->right);\n        int h;\n        h =1 + (hl > hr ? hl : hr);\n        return h;\n        \n    }\n    bool isBalanced(TreeNode *root) {\n        if(root == NULL)\n            return true;\n        int hl = height(root->left);\n        int hr = height(root->right);\n        int diff = hl - hr;\n        if(diff > 1 || diff < -1)\n            return false;\n        return isBalanced(root->left) && isBalanced(root->right);\n    }\n};\n```\n\n","source":"_posts/Balanced-Binary-Tree.md","raw":"---\ntitle: Balanced Binary Tree\ncomments: true\ncategories:\n  - leetcode\ntags: \n  - C++ \n  - Binary Tree\nabbrlink: 5c1c4dd0\ndate: 2018-11-16 00:14:50\n---\n\n**问题描述：**\n\nGiven a binary tree, determine if it is height-balanced.\n\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n\n**解决思路：**\n\n首先设计一个求二叉树高度的函数，然后调用该函数比较左右子树的高度差即可。\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int height(TreeNode *root){\n        if(root == NULL)\n            return 0;\n        int hr,hl;\n        hl = height(root->left);\n        hr = height(root->right);\n        int h;\n        h =1 + (hl > hr ? hl : hr);\n        return h;\n        \n    }\n    bool isBalanced(TreeNode *root) {\n        if(root == NULL)\n            return true;\n        int hl = height(root->left);\n        int hr = height(root->right);\n        int diff = hl - hr;\n        if(diff > 1 || diff < -1)\n            return false;\n        return isBalanced(root->left) && isBalanced(root->right);\n    }\n};\n```\n\n","slug":"Balanced-Binary-Tree","published":1,"updated":"2018-11-15T16:28:07.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzons0008tejeniqeau1z","content":"<p><strong>问题描述：</strong></p>\n<p>Given a binary tree, determine if it is height-balanced.</p>\n<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>\n<p><strong>解决思路：</strong></p>\n<p>首先设计一个求二叉树高度的函数，然后调用该函数比较左右子树的高度差即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">height</span><span class=\"params\">(TreeNode *root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hr,hl;</span><br><span class=\"line\">        hl = height(root-&gt;left);</span><br><span class=\"line\">        hr = height(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">        h =<span class=\"number\">1</span> + (hl &gt; hr ? hl : hr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hl = height(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hr = height(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> diff = hl - hr;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(diff &gt; <span class=\"number\">1</span> || diff &lt; <span class=\"number\">-1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given a binary tree, determine if it is height-balanced.</p>\n<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>\n<p><strong>解决思路：</strong></p>\n<p>首先设计一个求二叉树高度的函数，然后调用该函数比较左右子树的高度差即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">height</span><span class=\"params\">(TreeNode *root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hr,hl;</span><br><span class=\"line\">        hl = height(root-&gt;left);</span><br><span class=\"line\">        hr = height(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">        h =<span class=\"number\">1</span> + (hl &gt; hr ? hl : hr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hl = height(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hr = height(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> diff = hl - hr;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(diff &gt; <span class=\"number\">1</span> || diff &lt; <span class=\"number\">-1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Binary Tree Inorder Traversal","comments":1,"date":"2018-11-15T16:33:28.000Z","_content":"\n**问题描述：**\n\nGiven a binary tree, return the inorder traversal of its nodes' values.\n\nFor example:\nGiven binary tree {1,#,2,3},\n\n   1\n​    \\\n​     2\n​    /\n   3\nreturn [1,3,2].\n\nNote: Recursive solution is trivial, could you do it iteratively?\n\nconfused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\n\n**解决思路：**\n\n本想用栈去实现，但是这上面好像没有栈的定义，没办法只好用vector去解决了。\n\n**代码：**\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode *root) {\n        vector<int> intr;\n        if (root == NULL)\n            return intr;\n        vector<TreeNode*> node;\n        TreeNode *p;\n        p = root;\n        while(p != NULL || !node.empty()){\n            if(p != NULL){\n                node.push_back(p);\n                p =p->left;\n            }\n            else{\n                TreeNode *t = node.back();\n                node.pop_back();\n                intr.push_back(t->val);\n                p = t->right;\n        }\n    }\n    return intr;\n    }\n};\n```","source":"_posts/Binary-Tree-Inorder-Traversal.md","raw":"---\ntitle: Binary Tree Inorder Traversal\ncomments: true\ndate: 2018-11-16 00:33:28\ncategories:\n\t- leetcode\ntags:\n\t- C++\n\t- Binary Tree\n---\n\n**问题描述：**\n\nGiven a binary tree, return the inorder traversal of its nodes' values.\n\nFor example:\nGiven binary tree {1,#,2,3},\n\n   1\n​    \\\n​     2\n​    /\n   3\nreturn [1,3,2].\n\nNote: Recursive solution is trivial, could you do it iteratively?\n\nconfused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\n\n**解决思路：**\n\n本想用栈去实现，但是这上面好像没有栈的定义，没办法只好用vector去解决了。\n\n**代码：**\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode *root) {\n        vector<int> intr;\n        if (root == NULL)\n            return intr;\n        vector<TreeNode*> node;\n        TreeNode *p;\n        p = root;\n        while(p != NULL || !node.empty()){\n            if(p != NULL){\n                node.push_back(p);\n                p =p->left;\n            }\n            else{\n                TreeNode *t = node.back();\n                node.pop_back();\n                intr.push_back(t->val);\n                p = t->right;\n        }\n    }\n    return intr;\n    }\n};\n```","slug":"Binary-Tree-Inorder-Traversal","published":1,"updated":"2018-11-15T16:35:03.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzonv000ctejebjvn4qi2","content":"<p><strong>问题描述：</strong></p>\n<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>\n<p>For example:<br>Given binary tree {1,#,2,3},</p>\n<p>   1<br>​    \\<br>​     2<br>​    /<br>   3<br>return [1,3,2].</p>\n<p>Note: Recursive solution is trivial, could you do it iteratively?</p>\n<p>confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ.</p>\n<p><strong>解决思路：</strong></p>\n<p>本想用栈去实现，但是这上面好像没有栈的定义，没办法只好用vector去解决了。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; inorderTraversal(TreeNode *root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; intr;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> intr;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; node;</span><br><span class=\"line\">        TreeNode *p;</span><br><span class=\"line\">        p = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> || !node.empty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                node.push_back(p);</span><br><span class=\"line\">                p =p-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                TreeNode *t = node.back();</span><br><span class=\"line\">                node.pop_back();</span><br><span class=\"line\">                intr.push_back(t-&gt;val);</span><br><span class=\"line\">                p = t-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> intr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"abbrlink":"8a5e7d39","excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>\n<p>For example:<br>Given binary tree {1,#,2,3},</p>\n<p>   1<br>​    \\<br>​     2<br>​    /<br>   3<br>return [1,3,2].</p>\n<p>Note: Recursive solution is trivial, could you do it iteratively?</p>\n<p>confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ.</p>\n<p><strong>解决思路：</strong></p>\n<p>本想用栈去实现，但是这上面好像没有栈的定义，没办法只好用vector去解决了。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; inorderTraversal(TreeNode *root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; intr;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> intr;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; node;</span><br><span class=\"line\">        TreeNode *p;</span><br><span class=\"line\">        p = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> || !node.empty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                node.push_back(p);</span><br><span class=\"line\">                p =p-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                TreeNode *t = node.back();</span><br><span class=\"line\">                node.pop_back();</span><br><span class=\"line\">                intr.push_back(t-&gt;val);</span><br><span class=\"line\">                p = t-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> intr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"Best Time to Buy and Sell Stock II","comments":1,"date":"2018-11-15T16:48:29.000Z","_content":"\n**问题描述：**\n\nSay you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n\n**解决思路：**\n\n依次将相邻的元素相减（后面减去前面）得到新的数组，再取新数组正数相加即可\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    int maxProfit(vector<int> &prices) {\n        if(prices.empty())\n            return 0;\n        vector<int> price_d(prices.size());\n        for(int i = 0; i < prices.size()-1; i++)\n        {\n            price_d[i] = prices[i+1] - prices[i];\n        }\n        int max = 0;\n        for(int i = 0; i < price_d.size(); i ++)\n        {\n            if(price_d[i] > 0)\n                max += price_d[i];\n        }\n        return max;\n    }\n};\n```\n\n","source":"_posts/Best-Time-to-Buy-and-Sell-Stock-II.md","raw":"---\ntitle: Best Time to Buy and Sell Stock II\ncomments: true\ndate: 2018-11-16 00:48:29\ncategories:\n\t- leetcode\ntags:\n\t- C++\n---\n\n**问题描述：**\n\nSay you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n\n**解决思路：**\n\n依次将相邻的元素相减（后面减去前面）得到新的数组，再取新数组正数相加即可\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    int maxProfit(vector<int> &prices) {\n        if(prices.empty())\n            return 0;\n        vector<int> price_d(prices.size());\n        for(int i = 0; i < prices.size()-1; i++)\n        {\n            price_d[i] = prices[i+1] - prices[i];\n        }\n        int max = 0;\n        for(int i = 0; i < price_d.size(); i ++)\n        {\n            if(price_d[i] > 0)\n                max += price_d[i];\n        }\n        return max;\n    }\n};\n```\n\n","slug":"Best-Time-to-Buy-and-Sell-Stock-II","published":1,"updated":"2018-11-15T16:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzonw000etejevskqx5rl","content":"<p><strong>问题描述：</strong></p>\n<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>\n<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>\n<p><strong>解决思路：</strong></p>\n<p>依次将相邻的元素相减（后面减去前面）得到新的数组，再取新数组正数相加即可</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices.empty())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; price_d(prices.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prices.size()<span class=\"number\">-1</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            price_d[i] = prices[i+<span class=\"number\">1</span>] - prices[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; price_d.size(); i ++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(price_d[i] &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                max += price_d[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"abbrlink":"a10d34fe","excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>\n<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>\n<p><strong>解决思路：</strong></p>\n<p>依次将相邻的元素相减（后面减去前面）得到新的数组，再取新数组正数相加即可</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices.empty())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; price_d(prices.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prices.size()<span class=\"number\">-1</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            price_d[i] = prices[i+<span class=\"number\">1</span>] - prices[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; price_d.size(); i ++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(price_d[i] &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                max += price_d[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Binary Tree Level Order Traversal II","comments":1,"date":"2018-11-15T16:40:06.000Z","_content":"\n**问题描述：**\n\nGiven a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\n\nFor example:\nGiven binary tree {3,9,20,#,#,15,7},\n\n    \t3\n       / \\\n      9  20\n        /  \\\n       15   7\n\nreturn its bottom-up level order traversal as:\n\n```\n[\n  [15,7],\n  [9,20],\n  [3]\n]\n```\n\nconfused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\n\n\nOJ's Binary Tree Serialization:\nThe serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below.\n\nHere's an example:\n\n```\n   1\n  / \\\n 2   3\n    /\n   4\n    \\\n     5\n```\n\nThe above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\".\n\n**解决思路：**\n\n和前面一样\n\n**代码：**\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int> > levelOrderBottom(TreeNode *root) {\n        vector<vector<int>> LOB;\n        if (root == NULL)\n            return LOB;\n        int level = 0;\n        int count = 1;\n        queue<TreeNode *> node;\n        node.push(root);\n        stack<vector<int>> stk;\n        vector<int> sub(0);\n        while(!node.empty()){\n            sub.clear();\n            level = 0;\n            for(int i = 0; i < count; i++){\n                root = node.front();\n                node.pop();\n                sub.push_back(root->val);\n                if(root->left != NULL){\n                    node.push(root->left);\n                    ++level;\n                }\n                if(root->right != NULL){\n                    node.push(root->right);\n                    ++level;\n                }\n            }\n            stk.push(sub);\n            count = level;\n        }\n        while(!stk.empty()){\n            vector<int> tmp = stk.top();\n            LOB.push_back(tmp);\n            stk.pop();\n        }\n        return LOB;\n    }\n};\n```\n\n","source":"_posts/Binary-Tree-Level-Order-Traversal-II.md","raw":"---\ntitle: Binary Tree Level Order Traversal II\ncomments: true\ndate: 2018-11-16 00:40:06\ncategories:\n\t- leetcode\ntags:\n\t- C++\n\t- Binary Tree\n---\n\n**问题描述：**\n\nGiven a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\n\nFor example:\nGiven binary tree {3,9,20,#,#,15,7},\n\n    \t3\n       / \\\n      9  20\n        /  \\\n       15   7\n\nreturn its bottom-up level order traversal as:\n\n```\n[\n  [15,7],\n  [9,20],\n  [3]\n]\n```\n\nconfused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\n\n\nOJ's Binary Tree Serialization:\nThe serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below.\n\nHere's an example:\n\n```\n   1\n  / \\\n 2   3\n    /\n   4\n    \\\n     5\n```\n\nThe above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\".\n\n**解决思路：**\n\n和前面一样\n\n**代码：**\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int> > levelOrderBottom(TreeNode *root) {\n        vector<vector<int>> LOB;\n        if (root == NULL)\n            return LOB;\n        int level = 0;\n        int count = 1;\n        queue<TreeNode *> node;\n        node.push(root);\n        stack<vector<int>> stk;\n        vector<int> sub(0);\n        while(!node.empty()){\n            sub.clear();\n            level = 0;\n            for(int i = 0; i < count; i++){\n                root = node.front();\n                node.pop();\n                sub.push_back(root->val);\n                if(root->left != NULL){\n                    node.push(root->left);\n                    ++level;\n                }\n                if(root->right != NULL){\n                    node.push(root->right);\n                    ++level;\n                }\n            }\n            stk.push(sub);\n            count = level;\n        }\n        while(!stk.empty()){\n            vector<int> tmp = stk.top();\n            LOB.push_back(tmp);\n            stk.pop();\n        }\n        return LOB;\n    }\n};\n```\n\n","slug":"Binary-Tree-Level-Order-Traversal-II","published":1,"updated":"2018-11-15T16:42:01.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzonz000jteje2i094l5w","content":"<p><strong>问题描述：</strong></p>\n<p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>\n<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},</p>\n<pre><code>  3\n / \\\n9  20\n  /  \\\n 15   7\n</code></pre><p>return its bottom-up level order traversal as:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>,<span class=\"number\">20</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ.</p>\n<p>OJ’s Binary Tree Serialization:<br>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p>\n<p>Here’s an example:</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">1</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">2</span>   <span class=\"number\">3</span></span><br><span class=\"line\">   /</span><br><span class=\"line\">  <span class=\"number\">4</span></span><br><span class=\"line\">   \\</span><br><span class=\"line\">    <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>The above binary tree is serialized as “{1,2,3,#,#,4,#,#,5}”.</p>\n<p><strong>解决思路：</strong></p>\n<p>和前面一样</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; levelOrderBottom(TreeNode *root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; LOB;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> LOB;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; node;</span><br><span class=\"line\">        node.push(root);</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; stk;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; sub(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!node.empty())&#123;</span><br><span class=\"line\">            sub.clear();</span><br><span class=\"line\">            level = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)&#123;</span><br><span class=\"line\">                root = node.front();</span><br><span class=\"line\">                node.pop();</span><br><span class=\"line\">                sub.push_back(root-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(root-&gt;left != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                    node.push(root-&gt;left);</span><br><span class=\"line\">                    ++level;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(root-&gt;right != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                    node.push(root-&gt;right);</span><br><span class=\"line\">                    ++level;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stk.push(sub);</span><br><span class=\"line\">            count = level;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stk.empty())&#123;</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp = stk.top();</span><br><span class=\"line\">            LOB.push_back(tmp);</span><br><span class=\"line\">            stk.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LOB;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"abbrlink":"8adb33dd","excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>\n<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},</p>\n<pre><code>  3\n / \\\n9  20\n  /  \\\n 15   7\n</code></pre><p>return its bottom-up level order traversal as:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>,<span class=\"number\">20</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ.</p>\n<p>OJ’s Binary Tree Serialization:<br>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p>\n<p>Here’s an example:</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">1</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">2</span>   <span class=\"number\">3</span></span><br><span class=\"line\">   /</span><br><span class=\"line\">  <span class=\"number\">4</span></span><br><span class=\"line\">   \\</span><br><span class=\"line\">    <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>The above binary tree is serialized as “{1,2,3,#,#,4,#,#,5}”.</p>\n<p><strong>解决思路：</strong></p>\n<p>和前面一样</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; levelOrderBottom(TreeNode *root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; LOB;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> LOB;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; node;</span><br><span class=\"line\">        node.push(root);</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; stk;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; sub(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!node.empty())&#123;</span><br><span class=\"line\">            sub.clear();</span><br><span class=\"line\">            level = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)&#123;</span><br><span class=\"line\">                root = node.front();</span><br><span class=\"line\">                node.pop();</span><br><span class=\"line\">                sub.push_back(root-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(root-&gt;left != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                    node.push(root-&gt;left);</span><br><span class=\"line\">                    ++level;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(root-&gt;right != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                    node.push(root-&gt;right);</span><br><span class=\"line\">                    ++level;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stk.push(sub);</span><br><span class=\"line\">            count = level;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stk.empty())&#123;</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp = stk.top();</span><br><span class=\"line\">            LOB.push_back(tmp);</span><br><span class=\"line\">            stk.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LOB;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Binary Tree Level Order Traversal","comments":1,"date":"2018-11-15T16:37:35.000Z","_content":"\n**问题描述：**\n\nGiven a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n\nFor example:\nGiven binary tree {3,9,20,#,#,15,7},\n\n     \t3\n       / \\\n      9  20\n        /  \\\n       15   7\n\nreturn its level order traversal as:\n\n```\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n```\n\nconfused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\n\nOJ's Binary Tree Serialization:\nThe serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below.\n\nHere's an example:\n\n```\n  1\n  / \\\n 2   3\n    /\n   4\n    \\\n     5\n```\n\nThe above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\".\n\n**解决思路：**\n\n这里需要用到队列，因为根据题意要求，我们的输出结果应该是包含vector的vector，里面的每个vector包含的是该层的所有节点的值。由于队列是先进先出的，所以首先建立一个节点队列，从根节点开始插入，另外用count记录每层节点的总个数，level计算每层节点的个数。\n\n**代码：**\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int> > levelOrder(TreeNode *root) {\n        vector<vector<int>> LO;\n        if(root == NULL) return LO;\n        queue<TreeNode *> node;\n        node.push(root);\n        int count = 1;\n        int level = 0;\n        vector<int> sub(0);\n        while(!node.empty()){\n            sub.clear();\n            level = 0;\n            for(int i = 0; i < count; i++){\n                root = node.front();\n                node.pop();\n                sub.push_back(root->val);\n                if(root->left != NULL){\n                    node.push(root->left);\n                    ++level;\n                }\n                if(root->right != NULL){\n                    node.push(root->right);\n                    ++level;\n                }\n            }\n            count = level;\n            LO.push_back(sub);\n        }\n        return LO;\n    }\n};\n```\n\n","source":"_posts/Binary-Tree-Level-Order-Traversal.md","raw":"---\ntitle: Binary Tree Level Order Traversal\ncomments: true\ndate: 2018-11-16 00:37:35\ncategories:\n\t- leetcode\ntags:\n\t- C++\n\t- Binary Tree\n---\n\n**问题描述：**\n\nGiven a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n\nFor example:\nGiven binary tree {3,9,20,#,#,15,7},\n\n     \t3\n       / \\\n      9  20\n        /  \\\n       15   7\n\nreturn its level order traversal as:\n\n```\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n```\n\nconfused what \"{1,#,2,3}\" means? > read more on how binary tree is serialized on OJ.\n\nOJ's Binary Tree Serialization:\nThe serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below.\n\nHere's an example:\n\n```\n  1\n  / \\\n 2   3\n    /\n   4\n    \\\n     5\n```\n\nThe above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\".\n\n**解决思路：**\n\n这里需要用到队列，因为根据题意要求，我们的输出结果应该是包含vector的vector，里面的每个vector包含的是该层的所有节点的值。由于队列是先进先出的，所以首先建立一个节点队列，从根节点开始插入，另外用count记录每层节点的总个数，level计算每层节点的个数。\n\n**代码：**\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int> > levelOrder(TreeNode *root) {\n        vector<vector<int>> LO;\n        if(root == NULL) return LO;\n        queue<TreeNode *> node;\n        node.push(root);\n        int count = 1;\n        int level = 0;\n        vector<int> sub(0);\n        while(!node.empty()){\n            sub.clear();\n            level = 0;\n            for(int i = 0; i < count; i++){\n                root = node.front();\n                node.pop();\n                sub.push_back(root->val);\n                if(root->left != NULL){\n                    node.push(root->left);\n                    ++level;\n                }\n                if(root->right != NULL){\n                    node.push(root->right);\n                    ++level;\n                }\n            }\n            count = level;\n            LO.push_back(sub);\n        }\n        return LO;\n    }\n};\n```\n\n","slug":"Binary-Tree-Level-Order-Traversal","published":1,"updated":"2018-11-15T16:39:53.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzoo2000mtejedoxw2apq","content":"<p><strong>问题描述：</strong></p>\n<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>\n<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},</p>\n<pre><code>   3\n / \\\n9  20\n  /  \\\n 15   7\n</code></pre><p>return its level order traversal as:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>,<span class=\"number\">20</span>],</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ.</p>\n<p>OJ’s Binary Tree Serialization:<br>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p>\n<p>Here’s an example:</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">1</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">2</span>   <span class=\"number\">3</span></span><br><span class=\"line\">   /</span><br><span class=\"line\">  <span class=\"number\">4</span></span><br><span class=\"line\">   \\</span><br><span class=\"line\">    <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>The above binary tree is serialized as “{1,2,3,#,#,4,#,#,5}”.</p>\n<p><strong>解决思路：</strong></p>\n<p>这里需要用到队列，因为根据题意要求，我们的输出结果应该是包含vector的vector，里面的每个vector包含的是该层的所有节点的值。由于队列是先进先出的，所以首先建立一个节点队列，从根节点开始插入，另外用count记录每层节点的总个数，level计算每层节点的个数。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; levelOrder(TreeNode *root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; LO;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> LO;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; node;</span><br><span class=\"line\">        node.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; sub(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!node.empty())&#123;</span><br><span class=\"line\">            sub.clear();</span><br><span class=\"line\">            level = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)&#123;</span><br><span class=\"line\">                root = node.front();</span><br><span class=\"line\">                node.pop();</span><br><span class=\"line\">                sub.push_back(root-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(root-&gt;left != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                    node.push(root-&gt;left);</span><br><span class=\"line\">                    ++level;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(root-&gt;right != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                    node.push(root-&gt;right);</span><br><span class=\"line\">                    ++level;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            count = level;</span><br><span class=\"line\">            LO.push_back(sub);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"abbrlink":"a971a08f","excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>\n<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},</p>\n<pre><code>   3\n / \\\n9  20\n  /  \\\n 15   7\n</code></pre><p>return its level order traversal as:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">9</span>,<span class=\"number\">20</span>],</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ.</p>\n<p>OJ’s Binary Tree Serialization:<br>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p>\n<p>Here’s an example:</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">1</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">2</span>   <span class=\"number\">3</span></span><br><span class=\"line\">   /</span><br><span class=\"line\">  <span class=\"number\">4</span></span><br><span class=\"line\">   \\</span><br><span class=\"line\">    <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>The above binary tree is serialized as “{1,2,3,#,#,4,#,#,5}”.</p>\n<p><strong>解决思路：</strong></p>\n<p>这里需要用到队列，因为根据题意要求，我们的输出结果应该是包含vector的vector，里面的每个vector包含的是该层的所有节点的值。由于队列是先进先出的，所以首先建立一个节点队列，从根节点开始插入，另外用count记录每层节点的总个数，level计算每层节点的个数。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; levelOrder(TreeNode *root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; LO;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> LO;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; node;</span><br><span class=\"line\">        node.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> level = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; sub(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!node.empty())&#123;</span><br><span class=\"line\">            sub.clear();</span><br><span class=\"line\">            level = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)&#123;</span><br><span class=\"line\">                root = node.front();</span><br><span class=\"line\">                node.pop();</span><br><span class=\"line\">                sub.push_back(root-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(root-&gt;left != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                    node.push(root-&gt;left);</span><br><span class=\"line\">                    ++level;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(root-&gt;right != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                    node.push(root-&gt;right);</span><br><span class=\"line\">                    ++level;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            count = level;</span><br><span class=\"line\">            LO.push_back(sub);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Binary Tree Preorder Traversal","comments":1,"date":"2018-11-15T16:35:34.000Z","_content":"\n**问题描述：**\n\nGiven a binary tree, return the preorder traversal of its nodes' values.\n\nFor example:\nGiven binary tree {1,#,2,3},\n\n   1\n​    \\\n​     2\n​    /\n   3\nreturn [1,2,3].\n\nNote: Recursive solution is trivial, could you do it iteratively?\n\n**非递归实现，不过超时了。**\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode *root) {\n        vector<int> pretr;\n        if(root == NULL)\n            return pretr;\n        stack<TreeNode *> node;\n        node.push(root);\n        while(!node.empty()){\n            TreeNode *p = node.top();\n            pretr.push_back(p->val);\n            node.pop();\n            if(p->right) node.push(p);\n            if(p->left) node.push(p);\n        }\n        return pretr;\n    }\n};\n```\n\n**递归实现**\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode *root) {\n        vector<int> pretr;\n        process(root,pretr);\n        return pretr;\n        \n    }\n    void process(TreeNode *root,vector<int> &pretr){\n        if(root == NULL) return;\n        TreeNode *p;\n        p = root;\n        pretr.push_back(p->val);\n        process(p->left,pretr);\n        process(p->right,pretr);\n    }\n};\n```\n\n","source":"_posts/Binary-Tree-Preorder-Traversal.md","raw":"---\ntitle: Binary Tree Preorder Traversal\ncomments: true\ndate: 2018-11-16 00:35:34\ncategories:\n\t- leetcode\ntags:\n\t- C++\n\t- Binary Tree\n---\n\n**问题描述：**\n\nGiven a binary tree, return the preorder traversal of its nodes' values.\n\nFor example:\nGiven binary tree {1,#,2,3},\n\n   1\n​    \\\n​     2\n​    /\n   3\nreturn [1,2,3].\n\nNote: Recursive solution is trivial, could you do it iteratively?\n\n**非递归实现，不过超时了。**\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode *root) {\n        vector<int> pretr;\n        if(root == NULL)\n            return pretr;\n        stack<TreeNode *> node;\n        node.push(root);\n        while(!node.empty()){\n            TreeNode *p = node.top();\n            pretr.push_back(p->val);\n            node.pop();\n            if(p->right) node.push(p);\n            if(p->left) node.push(p);\n        }\n        return pretr;\n    }\n};\n```\n\n**递归实现**\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode *root) {\n        vector<int> pretr;\n        process(root,pretr);\n        return pretr;\n        \n    }\n    void process(TreeNode *root,vector<int> &pretr){\n        if(root == NULL) return;\n        TreeNode *p;\n        p = root;\n        pretr.push_back(p->val);\n        process(p->left,pretr);\n        process(p->right,pretr);\n    }\n};\n```\n\n","slug":"Binary-Tree-Preorder-Traversal","published":1,"updated":"2018-11-15T16:37:21.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzoo4000qtejeqfw34mql","content":"<p><strong>问题描述：</strong></p>\n<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>\n<p>For example:<br>Given binary tree {1,#,2,3},</p>\n<p>   1<br>​    \\<br>​     2<br>​    /<br>   3<br>return [1,2,3].</p>\n<p>Note: Recursive solution is trivial, could you do it iteratively?</p>\n<p><strong>非递归实现，不过超时了。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; preorderTraversal(TreeNode *root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; pretr;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pretr;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; node;</span><br><span class=\"line\">        node.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!node.empty())&#123;</span><br><span class=\"line\">            TreeNode *p = node.top();</span><br><span class=\"line\">            pretr.push_back(p-&gt;val);</span><br><span class=\"line\">            node.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p-&gt;right) node.push(p);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p-&gt;left) node.push(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pretr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>递归实现</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; preorderTraversal(TreeNode *root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; pretr;</span><br><span class=\"line\">        process(root,pretr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pretr;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(TreeNode *root,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;pretr)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        TreeNode *p;</span><br><span class=\"line\">        p = root;</span><br><span class=\"line\">        pretr.push_back(p-&gt;val);</span><br><span class=\"line\">        process(p-&gt;left,pretr);</span><br><span class=\"line\">        process(p-&gt;right,pretr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"abbrlink":"d13d2726","excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>\n<p>For example:<br>Given binary tree {1,#,2,3},</p>\n<p>   1<br>​    \\<br>​     2<br>​    /<br>   3<br>return [1,2,3].</p>\n<p>Note: Recursive solution is trivial, could you do it iteratively?</p>\n<p><strong>非递归实现，不过超时了。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; preorderTraversal(TreeNode *root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; pretr;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pretr;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;TreeNode *&gt; node;</span><br><span class=\"line\">        node.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!node.empty())&#123;</span><br><span class=\"line\">            TreeNode *p = node.top();</span><br><span class=\"line\">            pretr.push_back(p-&gt;val);</span><br><span class=\"line\">            node.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p-&gt;right) node.push(p);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p-&gt;left) node.push(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pretr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>递归实现</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; preorderTraversal(TreeNode *root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; pretr;</span><br><span class=\"line\">        process(root,pretr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pretr;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(TreeNode *root,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;pretr)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        TreeNode *p;</span><br><span class=\"line\">        p = root;</span><br><span class=\"line\">        pretr.push_back(p-&gt;val);</span><br><span class=\"line\">        process(p-&gt;left,pretr);</span><br><span class=\"line\">        process(p-&gt;right,pretr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Excel Sheet Column Number","comments":1,"abbrlink":"50445eba","date":"2018-11-15T16:03:44.000Z","_content":"\n**问题描述：**\n\nRelated to question Excel Sheet Column Title\n\nGiven a column title as appear in an Excel sheet, return its corresponding column number.\n\nFor example:\n\n```C++\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n```\n**解决思路：**\n\n本题类似于进制转换，将一个字符串转化为一个十进制的数字，而要求的字符串可以看作是一个26进制的数字。\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    int titleToNumber(string s) {\n        if(s.empty())\n            return 0;\n        int n = 0;\n        for(int i = 0; i < s.length()-1; i ++){\n            n = (int(s[i]-'A')+1+n) * 26;\n        }\n        n += int(s[s.length()-1]-'A')+1;\n        return n;\n    }\n};\n```\n\n","source":"_posts/Excel-Sheet-Column-Number.md","raw":"---\ntitle: Excel Sheet Column Number\ncomments: true\ncategories:\n  - leetcode\ntags: C++\nabbrlink: 50445eba\ndate: 2018-11-16 00:03:44\n---\n\n**问题描述：**\n\nRelated to question Excel Sheet Column Title\n\nGiven a column title as appear in an Excel sheet, return its corresponding column number.\n\nFor example:\n\n```C++\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n```\n**解决思路：**\n\n本题类似于进制转换，将一个字符串转化为一个十进制的数字，而要求的字符串可以看作是一个26进制的数字。\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    int titleToNumber(string s) {\n        if(s.empty())\n            return 0;\n        int n = 0;\n        for(int i = 0; i < s.length()-1; i ++){\n            n = (int(s[i]-'A')+1+n) * 26;\n        }\n        n += int(s[s.length()-1]-'A')+1;\n        return n;\n    }\n};\n```\n\n","slug":"Excel-Sheet-Column-Number","published":1,"updated":"2018-11-15T16:14:30.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzoo6000stejed7gsxlvt","content":"<p><strong>问题描述：</strong></p>\n<p>Related to question Excel Sheet Column Title</p>\n<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>\n<p>For example:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A -&gt; <span class=\"number\">1</span></span><br><span class=\"line\">B -&gt; <span class=\"number\">2</span></span><br><span class=\"line\">C -&gt; <span class=\"number\">3</span></span><br><span class=\"line\">...</span><br><span class=\"line\">Z -&gt; <span class=\"number\">26</span></span><br><span class=\"line\">AA -&gt; <span class=\"number\">27</span></span><br><span class=\"line\">AB -&gt; <span class=\"number\">28</span></span><br></pre></td></tr></table></figure>\n<p><strong>解决思路：</strong></p>\n<p>本题类似于进制转换，将一个字符串转化为一个十进制的数字，而要求的字符串可以看作是一个26进制的数字。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">titleToNumber</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.empty())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length()<span class=\"number\">-1</span>; i ++)&#123;</span><br><span class=\"line\">            n = (<span class=\"keyword\">int</span>(s[i]-<span class=\"string\">'A'</span>)+<span class=\"number\">1</span>+n) * <span class=\"number\">26</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n += <span class=\"keyword\">int</span>(s[s.length()<span class=\"number\">-1</span>]-<span class=\"string\">'A'</span>)+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Related to question Excel Sheet Column Title</p>\n<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>\n<p>For example:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A -&gt; <span class=\"number\">1</span></span><br><span class=\"line\">B -&gt; <span class=\"number\">2</span></span><br><span class=\"line\">C -&gt; <span class=\"number\">3</span></span><br><span class=\"line\">...</span><br><span class=\"line\">Z -&gt; <span class=\"number\">26</span></span><br><span class=\"line\">AA -&gt; <span class=\"number\">27</span></span><br><span class=\"line\">AB -&gt; <span class=\"number\">28</span></span><br></pre></td></tr></table></figure>\n<p><strong>解决思路：</strong></p>\n<p>本题类似于进制转换，将一个字符串转化为一个十进制的数字，而要求的字符串可以看作是一个26进制的数字。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">titleToNumber</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.empty())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length()<span class=\"number\">-1</span>; i ++)&#123;</span><br><span class=\"line\">            n = (<span class=\"keyword\">int</span>(s[i]-<span class=\"string\">'A'</span>)+<span class=\"number\">1</span>+n) * <span class=\"number\">26</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n += <span class=\"keyword\">int</span>(s[s.length()<span class=\"number\">-1</span>]-<span class=\"string\">'A'</span>)+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Intersection of Two Linked Lists","comments":1,"abbrlink":"42870ae4","date":"2018-11-15T16:09:39.000Z","_content":"\n**问题描述：**\n\nFor example, the following two linked lists:\n\nA:          a1 → a2\n​                   ↘\n​                     c1 → c2 → c3\n​                   ↗            \nB:     b1 → b2 → b3\nbegin to intersect at node c1.\n\n\nNotes:\n\nIf the two linked lists have no intersection at all, return null.\nThe linked lists must retain their original structure after the function returns.\nYou may assume there are no cycles anywhere in the entire linked structure.\nYour code should preferably run in O(n) time and use only O(1) memory.\n\n**解决思路：**\n\n这题要求的时间复杂度是O(n)和空间复杂度O(1)，所以只能用以下方法解决：(1)首先分别求出两个单链表的长度lenA和lenB；(2)求出两个链表的长度差，然后将长链表的比较位置移到长度差的位置，因为这些位置上的两个链表的元素是肯定不相同的；(3)此时，两个链表的长度一致，在分别依次比较元素即可\n\n**代码：**\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if(headA == NULL || headB == NULL)\n            return NULL;\n        int lenA,lenB;\n        lenA = 0,lenB = 0;\n        ListNode *p,*q;\n        for(p = headA;p != NULL;p=p->next)\n            lenA ++;\n        for(q = headB;q != NULL;q=q->next)\n            lenB ++;\n        int diff = abs(lenB-lenA);\n        if(lenA > lenB){\n            p = headA;\n            for(int i = 0;i < diff;i++)\n                p = p->next;\n            q = headB;\n            while(p != NULL && q != NULL){\n                if(p->val == q->val)\n                    return p;\n                else{\n                    p = p->next;\n                    q = q->next;\n                }\n            }\n            return NULL;\n        }\n        else{\n            p = headB;\n            for(int i = 0;i < diff;i++)\n                p = p->next;\n            q = headA;\n            while(p != NULL && q != NULL){\n                if(p->val == q->val)\n                    return p;\n                else{\n                    p = p->next;\n                    q = q->next;\n                }\n            }\n            return NULL;\n        }\n    }\n};\n```\n\n","source":"_posts/Intersection-of-Two-Linked-Lists.md","raw":"---\ntitle: Intersection of Two Linked Lists\ncomments: true\ncategories:\n  - leetcode\ntags: \n  - C++\n  - List\nabbrlink: 42870ae4\ndate: 2018-11-16 00:09:39\n---\n\n**问题描述：**\n\nFor example, the following two linked lists:\n\nA:          a1 → a2\n​                   ↘\n​                     c1 → c2 → c3\n​                   ↗            \nB:     b1 → b2 → b3\nbegin to intersect at node c1.\n\n\nNotes:\n\nIf the two linked lists have no intersection at all, return null.\nThe linked lists must retain their original structure after the function returns.\nYou may assume there are no cycles anywhere in the entire linked structure.\nYour code should preferably run in O(n) time and use only O(1) memory.\n\n**解决思路：**\n\n这题要求的时间复杂度是O(n)和空间复杂度O(1)，所以只能用以下方法解决：(1)首先分别求出两个单链表的长度lenA和lenB；(2)求出两个链表的长度差，然后将长链表的比较位置移到长度差的位置，因为这些位置上的两个链表的元素是肯定不相同的；(3)此时，两个链表的长度一致，在分别依次比较元素即可\n\n**代码：**\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if(headA == NULL || headB == NULL)\n            return NULL;\n        int lenA,lenB;\n        lenA = 0,lenB = 0;\n        ListNode *p,*q;\n        for(p = headA;p != NULL;p=p->next)\n            lenA ++;\n        for(q = headB;q != NULL;q=q->next)\n            lenB ++;\n        int diff = abs(lenB-lenA);\n        if(lenA > lenB){\n            p = headA;\n            for(int i = 0;i < diff;i++)\n                p = p->next;\n            q = headB;\n            while(p != NULL && q != NULL){\n                if(p->val == q->val)\n                    return p;\n                else{\n                    p = p->next;\n                    q = q->next;\n                }\n            }\n            return NULL;\n        }\n        else{\n            p = headB;\n            for(int i = 0;i < diff;i++)\n                p = p->next;\n            q = headA;\n            while(p != NULL && q != NULL){\n                if(p->val == q->val)\n                    return p;\n                else{\n                    p = p->next;\n                    q = q->next;\n                }\n            }\n            return NULL;\n        }\n    }\n};\n```\n\n","slug":"Intersection-of-Two-Linked-Lists","published":1,"updated":"2018-11-15T16:28:26.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzoo8000wteje61mwsvwc","content":"<p><strong>问题描述：</strong></p>\n<p>For example, the following two linked lists:</p>\n<p>A:          a1 → a2<br>​                   ↘<br>​                     c1 → c2 → c3<br>​                   ↗<br>B:     b1 → b2 → b3<br>begin to intersect at node c1.</p>\n<p>Notes:</p>\n<p>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.</p>\n<p><strong>解决思路：</strong></p>\n<p>这题要求的时间复杂度是O(n)和空间复杂度O(1)，所以只能用以下方法解决：(1)首先分别求出两个单链表的长度lenA和lenB；(2)求出两个链表的长度差，然后将长链表的比较位置移到长度差的位置，因为这些位置上的两个链表的元素是肯定不相同的；(3)此时，两个链表的长度一致，在分别依次比较元素即可</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(headA == <span class=\"literal\">NULL</span> || headB == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenA,lenB;</span><br><span class=\"line\">        lenA = <span class=\"number\">0</span>,lenB = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode *p,*q;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(p = headA;p != <span class=\"literal\">NULL</span>;p=p-&gt;next)</span><br><span class=\"line\">            lenA ++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(q = headB;q != <span class=\"literal\">NULL</span>;q=q-&gt;next)</span><br><span class=\"line\">            lenB ++;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> diff = <span class=\"built_in\">abs</span>(lenB-lenA);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lenA &gt; lenB)&#123;</span><br><span class=\"line\">            p = headA;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; diff;i++)</span><br><span class=\"line\">                p = p-&gt;next;</span><br><span class=\"line\">            q = headB;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; q != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(p-&gt;val == q-&gt;val)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    p = p-&gt;next;</span><br><span class=\"line\">                    q = q-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            p = headB;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; diff;i++)</span><br><span class=\"line\">                p = p-&gt;next;</span><br><span class=\"line\">            q = headA;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; q != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(p-&gt;val == q-&gt;val)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    p = p-&gt;next;</span><br><span class=\"line\">                    q = q-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>For example, the following two linked lists:</p>\n<p>A:          a1 → a2<br>​                   ↘<br>​                     c1 → c2 → c3<br>​                   ↗<br>B:     b1 → b2 → b3<br>begin to intersect at node c1.</p>\n<p>Notes:</p>\n<p>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.</p>\n<p><strong>解决思路：</strong></p>\n<p>这题要求的时间复杂度是O(n)和空间复杂度O(1)，所以只能用以下方法解决：(1)首先分别求出两个单链表的长度lenA和lenB；(2)求出两个链表的长度差，然后将长链表的比较位置移到长度差的位置，因为这些位置上的两个链表的元素是肯定不相同的；(3)此时，两个链表的长度一致，在分别依次比较元素即可</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(headA == <span class=\"literal\">NULL</span> || headB == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenA,lenB;</span><br><span class=\"line\">        lenA = <span class=\"number\">0</span>,lenB = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode *p,*q;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(p = headA;p != <span class=\"literal\">NULL</span>;p=p-&gt;next)</span><br><span class=\"line\">            lenA ++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(q = headB;q != <span class=\"literal\">NULL</span>;q=q-&gt;next)</span><br><span class=\"line\">            lenB ++;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> diff = <span class=\"built_in\">abs</span>(lenB-lenA);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lenA &gt; lenB)&#123;</span><br><span class=\"line\">            p = headA;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; diff;i++)</span><br><span class=\"line\">                p = p-&gt;next;</span><br><span class=\"line\">            q = headB;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; q != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(p-&gt;val == q-&gt;val)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    p = p-&gt;next;</span><br><span class=\"line\">                    q = q-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            p = headB;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; diff;i++)</span><br><span class=\"line\">                p = p-&gt;next;</span><br><span class=\"line\">            q = headA;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; q != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(p-&gt;val == q-&gt;val)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    p = p-&gt;next;</span><br><span class=\"line\">                    q = q-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Linked List Cycle","comments":1,"abbrlink":"c94099d8","date":"2018-11-15T16:20:05.000Z","_content":"\n**问题描述：**\n\nGiven a linked list, determine if it has a cycle in it.\n\nFollow up:\nCan you solve it without using extra space?\n\n**解决思路：**\n\n采用快慢指针的方法，快指针一次走两步，慢指针一次走一步，如果链表中有环的话，经过走一定的步数之后快慢指针一定会相遇的，当然如果没有环就需考虑循环结束的条件，这里主要要考虑快指针的情况即可。\n\n**代码：**\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        if(head->next == NULL)\n            return false;\n        ListNode *p,*q;\n        p = head;\n        q = head;\n       while(p != NULL && p->next != NULL)\n        {\n            p = p->next->next;\n            q = q->next;\n            if(p == q)\n                return true;\n            \n        }\n        return false;\n    }\n};\n```\n\n","source":"_posts/Linked-List-Cycle.md","raw":"---\ntitle: Linked List Cycle\ncomments: true\ncategories:\n  - leetcode\ntags:\n  - C++\n  - List\nabbrlink: c94099d8\ndate: 2018-11-16 00:20:05\n---\n\n**问题描述：**\n\nGiven a linked list, determine if it has a cycle in it.\n\nFollow up:\nCan you solve it without using extra space?\n\n**解决思路：**\n\n采用快慢指针的方法，快指针一次走两步，慢指针一次走一步，如果链表中有环的话，经过走一定的步数之后快慢指针一定会相遇的，当然如果没有环就需考虑循环结束的条件，这里主要要考虑快指针的情况即可。\n\n**代码：**\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false;\n        if(head->next == NULL)\n            return false;\n        ListNode *p,*q;\n        p = head;\n        q = head;\n       while(p != NULL && p->next != NULL)\n        {\n            p = p->next->next;\n            q = q->next;\n            if(p == q)\n                return true;\n            \n        }\n        return false;\n    }\n};\n```\n\n","slug":"Linked-List-Cycle","published":1,"updated":"2018-11-15T16:25:35.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzoo9000zteje70viyxh0","content":"<p><strong>问题描述：</strong></p>\n<p>Given a linked list, determine if it has a cycle in it.</p>\n<p>Follow up:<br>Can you solve it without using extra space?</p>\n<p><strong>解决思路：</strong></p>\n<p>采用快慢指针的方法，快指针一次走两步，慢指针一次走一步，如果链表中有环的话，经过走一定的步数之后快慢指针一定会相遇的，当然如果没有环就需考虑循环结束的条件，这里主要要考虑快指针的情况即可。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head-&gt;next == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        ListNode *p,*q;</span><br><span class=\"line\">        p = head;</span><br><span class=\"line\">        q = head;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; p-&gt;next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            p = p-&gt;next-&gt;next;</span><br><span class=\"line\">            q = q-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p == q)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given a linked list, determine if it has a cycle in it.</p>\n<p>Follow up:<br>Can you solve it without using extra space?</p>\n<p><strong>解决思路：</strong></p>\n<p>采用快慢指针的方法，快指针一次走两步，慢指针一次走一步，如果链表中有环的话，经过走一定的步数之后快慢指针一定会相遇的，当然如果没有环就需考虑循环结束的条件，这里主要要考虑快指针的情况即可。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head-&gt;next == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        ListNode *p,*q;</span><br><span class=\"line\">        p = head;</span><br><span class=\"line\">        q = head;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; p-&gt;next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            p = p-&gt;next-&gt;next;</span><br><span class=\"line\">            q = q-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p == q)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Majority Element","comments":1,"abbrlink":"ed8e0613","date":"2018-11-15T16:12:02.000Z","_content":"\n**问题描述：**\n\nGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n\nYou may assume that the array is non-empty and the majority element always exist in the array.\n\n**解决思路：**\n\n这是一个求解数组主元素的题目，数组的主元素是指数组中出现次数超过一半的元素。此题是假设数组非空并且主元素存在，所以比较简单。主元素总会比其他元素多，我们设置两个变量maj_index用于记录主元素的位置，count用于记录主元素出现的次数，然后一次比较数组元素，如果相同则count加1，不同则减1，若count为零，则替换maj_index，并将count置为1.\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    int majorityElement(vector<int> &num) {\n        int maj_index,count;\n        maj_index = 0;\n        count = 1;\n        for(int i =1; i < num.size(); i++){\n            if (num[i] == num[maj_index])\n                count ++;\n            else\n                count --;\n            if (count == 0){\n                maj_index = i;\n                count = 1;\n            }\n        }\n        return num[maj_index];\n    }\n};\n```\n\n","source":"_posts/Majority-Element.md","raw":"---\ntitle: Majority Element\ncomments: true\ncategories:\n  - leetcode\ntags: C++\nabbrlink: ed8e0613\ndate: 2018-11-16 00:12:02\n---\n\n**问题描述：**\n\nGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n\nYou may assume that the array is non-empty and the majority element always exist in the array.\n\n**解决思路：**\n\n这是一个求解数组主元素的题目，数组的主元素是指数组中出现次数超过一半的元素。此题是假设数组非空并且主元素存在，所以比较简单。主元素总会比其他元素多，我们设置两个变量maj_index用于记录主元素的位置，count用于记录主元素出现的次数，然后一次比较数组元素，如果相同则count加1，不同则减1，若count为零，则替换maj_index，并将count置为1.\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    int majorityElement(vector<int> &num) {\n        int maj_index,count;\n        maj_index = 0;\n        count = 1;\n        for(int i =1; i < num.size(); i++){\n            if (num[i] == num[maj_index])\n                count ++;\n            else\n                count --;\n            if (count == 0){\n                maj_index = i;\n                count = 1;\n            }\n        }\n        return num[maj_index];\n    }\n};\n```\n\n","slug":"Majority-Element","published":1,"updated":"2018-11-15T16:14:30.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzoob0013tejebbfa5gcw","content":"<p><strong>问题描述：</strong></p>\n<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>\n<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\n<p><strong>解决思路：</strong></p>\n<p>这是一个求解数组主元素的题目，数组的主元素是指数组中出现次数超过一半的元素。此题是假设数组非空并且主元素存在，所以比较简单。主元素总会比其他元素多，我们设置两个变量maj_index用于记录主元素的位置，count用于记录主元素出现的次数，然后一次比较数组元素，如果相同则count加1，不同则减1，若count为零，则替换maj_index，并将count置为1.</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maj_index,count;</span><br><span class=\"line\">        maj_index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">1</span>; i &lt; num.size(); i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num[i] == num[maj_index])</span><br><span class=\"line\">                count ++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                count --;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                maj_index = i;</span><br><span class=\"line\">                count = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num[maj_index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>\n<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\n<p><strong>解决思路：</strong></p>\n<p>这是一个求解数组主元素的题目，数组的主元素是指数组中出现次数超过一半的元素。此题是假设数组非空并且主元素存在，所以比较简单。主元素总会比其他元素多，我们设置两个变量maj_index用于记录主元素的位置，count用于记录主元素出现的次数，然后一次比较数组元素，如果相同则count加1，不同则减1，若count为零，则替换maj_index，并将count置为1.</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maj_index,count;</span><br><span class=\"line\">        maj_index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">1</span>; i &lt; num.size(); i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num[i] == num[maj_index])</span><br><span class=\"line\">                count ++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                count --;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                maj_index = i;</span><br><span class=\"line\">                count = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num[maj_index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Maximum Depth of Binary Tree","comments":1,"date":"2018-11-15T16:47:11.000Z","_content":"\n**问题描述：**\nGiven a binary tree, find its maximum depth.\n\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**解决思路：**\n\nDFS分别求出左子树和右子树的最大深度然后比较即可\n\n**代码：**\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode *root) {\n        if (root == NULL)\n            return 0;\n        int l = maxDepth(root->left);\n        int r = maxDepth(root->right);\n        return l>r?1+l:1+r;\n        \n    }\n};\n```","source":"_posts/Maximum-Depth-of-Binary-Tree.md","raw":"---\ntitle: Maximum Depth of Binary Tree\ncomments: true\ndate: 2018-11-16 00:47:11\ncategories:\n\t- leetcode\ntags:\n\t- C++\n\t- Binary Tree\n\t- DFS\n---\n\n**问题描述：**\nGiven a binary tree, find its maximum depth.\n\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**解决思路：**\n\nDFS分别求出左子树和右子树的最大深度然后比较即可\n\n**代码：**\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode *root) {\n        if (root == NULL)\n            return 0;\n        int l = maxDepth(root->left);\n        int r = maxDepth(root->right);\n        return l>r?1+l:1+r;\n        \n    }\n};\n```","slug":"Maximum-Depth-of-Binary-Tree","published":1,"updated":"2018-11-15T16:48:39.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzood0016tejep24oux1h","content":"<p><strong>问题描述：</strong><br>Given a binary tree, find its maximum depth.</p>\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n<p><strong>解决思路：</strong></p>\n<p>DFS分别求出左子树和右子树的最大深度然后比较即可</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = maxDepth(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = maxDepth(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l&gt;r?<span class=\"number\">1</span>+l:<span class=\"number\">1</span>+r;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"abbrlink":"2c2d1f13","excerpt":"","more":"<p><strong>问题描述：</strong><br>Given a binary tree, find its maximum depth.</p>\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n<p><strong>解决思路：</strong></p>\n<p>DFS分别求出左子树和右子树的最大深度然后比较即可</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = maxDepth(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = maxDepth(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l&gt;r?<span class=\"number\">1</span>+l:<span class=\"number\">1</span>+r;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"Palindrome Number","comments":1,"abbrlink":"b216f26b","date":"2018-11-15T16:06:52.000Z","_content":"\n**问题描述：**\n\nDetermine whether an integer is a palindrome. Do this without extra space.\n\nclick to show spoilers.\n\nSome hints:\nCould negative integers be palindromes? (ie, -1)\n\nIf you are thinking of converting the integer to string, note the restriction of using extra space.\n\nYou could also try reversing an integer. However, if you have solved the problem \"Reverse Integer\", you know that the reversed integer might overflow. How would you handle such case?\n\nThere is a more generic way of solving this problem.\n\n**解决思路：**\n\n这里要求不能使用额外的空间，基本思路是首先求出数据的位数，然后编写一个函数能够求出每一位的数字，然后遍历比较即可。\n\n**代码1：**\n\n```C++\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0)\n            return false;\n        int num = 0;\n        int y = x;\n        while( y != 0){\n            num ++;\n            y /= 10;\n        }\n        int i,j;\n        for(i = 1, j = num; i < j;i++,j--){\n            if (search(x,num,i) != search(x,num,j))\n                return false;\n        }\n        return true;\n    }\n    int search(int x,int n,int index){\n        int d = pow(10,n-index);\n        int y = x/d;\n        return y%10;\n    }\n};\n```\n\n\n\n**代码2：**\n\n```C++\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0)\n            return false;\n        int z = x;\n        int y = 0;\n        while( x != 0){\n            y *= 10;\n            y += x%10;\n            x /= 10;\n        }\n        if(z == y)\n            return true;\n        else\n            return false;\n    }\n};\n```\n\n","source":"_posts/Palindrome-Number.md","raw":"---\ntitle: Palindrome Number\ncomments: true\ncategories:\n  - leetcode\ntags: C++\nabbrlink: b216f26b\ndate: 2018-11-16 00:06:52\n---\n\n**问题描述：**\n\nDetermine whether an integer is a palindrome. Do this without extra space.\n\nclick to show spoilers.\n\nSome hints:\nCould negative integers be palindromes? (ie, -1)\n\nIf you are thinking of converting the integer to string, note the restriction of using extra space.\n\nYou could also try reversing an integer. However, if you have solved the problem \"Reverse Integer\", you know that the reversed integer might overflow. How would you handle such case?\n\nThere is a more generic way of solving this problem.\n\n**解决思路：**\n\n这里要求不能使用额外的空间，基本思路是首先求出数据的位数，然后编写一个函数能够求出每一位的数字，然后遍历比较即可。\n\n**代码1：**\n\n```C++\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0)\n            return false;\n        int num = 0;\n        int y = x;\n        while( y != 0){\n            num ++;\n            y /= 10;\n        }\n        int i,j;\n        for(i = 1, j = num; i < j;i++,j--){\n            if (search(x,num,i) != search(x,num,j))\n                return false;\n        }\n        return true;\n    }\n    int search(int x,int n,int index){\n        int d = pow(10,n-index);\n        int y = x/d;\n        return y%10;\n    }\n};\n```\n\n\n\n**代码2：**\n\n```C++\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0)\n            return false;\n        int z = x;\n        int y = 0;\n        while( x != 0){\n            y *= 10;\n            y += x%10;\n            x /= 10;\n        }\n        if(z == y)\n            return true;\n        else\n            return false;\n    }\n};\n```\n\n","slug":"Palindrome-Number","published":1,"updated":"2018-11-15T16:14:30.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzooe001atejelnlvwhed","content":"<p><strong>问题描述：</strong></p>\n<p>Determine whether an integer is a palindrome. Do this without extra space.</p>\n<p>click to show spoilers.</p>\n<p>Some hints:<br>Could negative integers be palindromes? (ie, -1)</p>\n<p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>\n<p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p>\n<p>There is a more generic way of solving this problem.</p>\n<p><strong>解决思路：</strong></p>\n<p>这里要求不能使用额外的空间，基本思路是首先求出数据的位数，然后编写一个函数能够求出每一位的数字，然后遍历比较即可。</p>\n<p><strong>代码1：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = x;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( y != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            num ++;</span><br><span class=\"line\">            y /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>, j = num; i &lt; j;i++,j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (search(x,num,i) != search(x,num,j))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> index)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> d = <span class=\"built_in\">pow</span>(<span class=\"number\">10</span>,n-index);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = x/d;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> y%<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>代码2：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> z = x;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( x != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            y *= <span class=\"number\">10</span>;</span><br><span class=\"line\">            y += x%<span class=\"number\">10</span>;</span><br><span class=\"line\">            x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(z == y)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Determine whether an integer is a palindrome. Do this without extra space.</p>\n<p>click to show spoilers.</p>\n<p>Some hints:<br>Could negative integers be palindromes? (ie, -1)</p>\n<p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>\n<p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p>\n<p>There is a more generic way of solving this problem.</p>\n<p><strong>解决思路：</strong></p>\n<p>这里要求不能使用额外的空间，基本思路是首先求出数据的位数，然后编写一个函数能够求出每一位的数字，然后遍历比较即可。</p>\n<p><strong>代码1：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = x;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( y != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            num ++;</span><br><span class=\"line\">            y /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>, j = num; i &lt; j;i++,j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (search(x,num,i) != search(x,num,j))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> index)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> d = <span class=\"built_in\">pow</span>(<span class=\"number\">10</span>,n-index);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = x/d;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> y%<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>代码2：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> z = x;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( x != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            y *= <span class=\"number\">10</span>;</span><br><span class=\"line\">            y += x%<span class=\"number\">10</span>;</span><br><span class=\"line\">            x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(z == y)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Remove Duplicates from Sorted List","comments":1,"abbrlink":"1d8b65b1","date":"2018-11-15T16:18:19.000Z","_content":"\n**问题描述：**\n\nGiven a sorted linked list, delete all duplicates such that each element appear only once.\n\nFor example,\nGiven 1->1->2, return 1->2.\nGiven 1->1->2->3->3, return 1->2->3.\n\n**解决思路：**\n\n定义两个指针base和cmp,base指针指向被比较的结点，cmp指向base的后一个结点，由于链表是有序的，所以cmp找到第一个不等于base的结点之后，就分别将base和cmp后移。如果相等，只要将相等的结点删除即可。\n\n**代码:**\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *deleteDuplicates(ListNode *head) {\n        if(head == NULL || head->next == NULL)\n            return head;\n        ListNode *base,*cmp;\n        base = head;\n        cmp = base->next;\n        while(cmp != NULL){\n            ListNode *tmp;\n            tmp = cmp->next;\n            if(cmp->val == base->val){\n                base->next = tmp;\n                free(cmp);\n                cmp = tmp;\n            }\n            else{\n                base = cmp;\n                cmp = tmp;\n            }\n            \n        }\n        return head;\n        \n    }\n};\n```\n\n","source":"_posts/Remove-Duplicates-from-Sorted-List.md","raw":"---\ntitle: Remove Duplicates from Sorted List\ncomments: true\ncategories:\n  - leetcode\ntags: \n  - C++\n  - List\nabbrlink: 1d8b65b1\ndate: 2018-11-16 00:18:19\n---\n\n**问题描述：**\n\nGiven a sorted linked list, delete all duplicates such that each element appear only once.\n\nFor example,\nGiven 1->1->2, return 1->2.\nGiven 1->1->2->3->3, return 1->2->3.\n\n**解决思路：**\n\n定义两个指针base和cmp,base指针指向被比较的结点，cmp指向base的后一个结点，由于链表是有序的，所以cmp找到第一个不等于base的结点之后，就分别将base和cmp后移。如果相等，只要将相等的结点删除即可。\n\n**代码:**\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *deleteDuplicates(ListNode *head) {\n        if(head == NULL || head->next == NULL)\n            return head;\n        ListNode *base,*cmp;\n        base = head;\n        cmp = base->next;\n        while(cmp != NULL){\n            ListNode *tmp;\n            tmp = cmp->next;\n            if(cmp->val == base->val){\n                base->next = tmp;\n                free(cmp);\n                cmp = tmp;\n            }\n            else{\n                base = cmp;\n                cmp = tmp;\n            }\n            \n        }\n        return head;\n        \n    }\n};\n```\n\n","slug":"Remove-Duplicates-from-Sorted-List","published":1,"updated":"2018-11-15T16:28:43.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzoof001dteje3dqwcnxk","content":"<p><strong>问题描述：</strong></p>\n<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>\n<p>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>\n<p><strong>解决思路：</strong></p>\n<p>定义两个指针base和cmp,base指针指向被比较的结点，cmp指向base的后一个结点，由于链表是有序的，所以cmp找到第一个不等于base的结点之后，就分别将base和cmp后移。如果相等，只要将相等的结点删除即可。</p>\n<p><strong>代码:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">NULL</span> || head-&gt;next == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode *base,*cmp;</span><br><span class=\"line\">        base = head;</span><br><span class=\"line\">        cmp = base-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cmp != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            ListNode *tmp;</span><br><span class=\"line\">            tmp = cmp-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cmp-&gt;val == base-&gt;val)&#123;</span><br><span class=\"line\">                base-&gt;next = tmp;</span><br><span class=\"line\">                <span class=\"built_in\">free</span>(cmp);</span><br><span class=\"line\">                cmp = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                base = cmp;</span><br><span class=\"line\">                cmp = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>\n<p>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>\n<p><strong>解决思路：</strong></p>\n<p>定义两个指针base和cmp,base指针指向被比较的结点，cmp指向base的后一个结点，由于链表是有序的，所以cmp找到第一个不等于base的结点之后，就分别将base和cmp后移。如果相等，只要将相等的结点删除即可。</p>\n<p><strong>代码:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">NULL</span> || head-&gt;next == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode *base,*cmp;</span><br><span class=\"line\">        base = head;</span><br><span class=\"line\">        cmp = base-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cmp != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            ListNode *tmp;</span><br><span class=\"line\">            tmp = cmp-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cmp-&gt;val == base-&gt;val)&#123;</span><br><span class=\"line\">                base-&gt;next = tmp;</span><br><span class=\"line\">                <span class=\"built_in\">free</span>(cmp);</span><br><span class=\"line\">                cmp = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                base = cmp;</span><br><span class=\"line\">                cmp = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Same Tree","comments":1,"date":"2018-11-15T16:45:40.000Z","_content":"\n**问题描述：**\n\nGiven two binary trees, write a function to check if they are equal or not.\n\nTwo binary trees are considered equal if they are structurally identical and the nodes have the same value.\n\n**解决思路：**\n\nDFS遍历两颗二叉树的结点，只要有一个不同就返回false\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode *p, TreeNode *q) {\n        if(p == NULL)\n        {\n            if (q == NULL)\n                return true;\n            return false;\n        }\n        if(q == NULL)\n        {\n            if (p == NULL)\n                return true;\n            return false;\n        }\n        if (p->val != q->val)\n            return false;\n        bool lsame = isSameTree(p->left,q->left);\n        bool rsame = isSameTree(p->right,q->right);\n        if(lsame==false||rsame==false)\n            return false;\n        return true;\n        \n    }\n};\n```\n\n","source":"_posts/Same-Tree.md","raw":"---\ntitle: Same Tree\ncomments: true\ndate: 2018-11-16 00:45:40\ncategories:\n\t- leetcode\ntags:\n\t- C++\n\t- Binary Tree\n\t- DFS\n---\n\n**问题描述：**\n\nGiven two binary trees, write a function to check if they are equal or not.\n\nTwo binary trees are considered equal if they are structurally identical and the nodes have the same value.\n\n**解决思路：**\n\nDFS遍历两颗二叉树的结点，只要有一个不同就返回false\n\n```C++\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode *p, TreeNode *q) {\n        if(p == NULL)\n        {\n            if (q == NULL)\n                return true;\n            return false;\n        }\n        if(q == NULL)\n        {\n            if (p == NULL)\n                return true;\n            return false;\n        }\n        if (p->val != q->val)\n            return false;\n        bool lsame = isSameTree(p->left,q->left);\n        bool rsame = isSameTree(p->right,q->right);\n        if(lsame==false||rsame==false)\n            return false;\n        return true;\n        \n    }\n};\n```\n\n","slug":"Same-Tree","published":1,"updated":"2018-11-15T16:46:38.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzooh001hteje5fwsbwcz","content":"<p><strong>问题描述：</strong></p>\n<p>Given two binary trees, write a function to check if they are equal or not.</p>\n<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>\n<p><strong>解决思路：</strong></p>\n<p>DFS遍历两颗二叉树的结点，只要有一个不同就返回false</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSameTree</span><span class=\"params\">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(q == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;val != q-&gt;val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> lsame = isSameTree(p-&gt;left,q-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> rsame = isSameTree(p-&gt;right,q-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lsame==<span class=\"literal\">false</span>||rsame==<span class=\"literal\">false</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"abbrlink":"f4467b0e","excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given two binary trees, write a function to check if they are equal or not.</p>\n<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>\n<p><strong>解决思路：</strong></p>\n<p>DFS遍历两颗二叉树的结点，只要有一个不同就返回false</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSameTree</span><span class=\"params\">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(q == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;val != q-&gt;val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> lsame = isSameTree(p-&gt;left,q-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> rsame = isSameTree(p-&gt;right,q-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lsame==<span class=\"literal\">false</span>||rsame==<span class=\"literal\">false</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Single Number","comments":1,"date":"2018-11-15T16:49:48.000Z","_content":"\n**问题描述：**\n\nGiven an array of integers, every element appears twice except for one. Find that single one.\n\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n\n**解决思路：**\n\n本题主要是求出一组数组中唯一个没有相同元素的数字，这里要求时间复杂度为O(n)，空间复杂度为O(1)，所以我们只需遍历一次数组就必须得到结果，并且不能使用其他额外的内存空间。这里采用异或运算，能够保证相同的元素运算结果为0，所以最终便能找个那个唯一的数字。\n\n**代码：**\n\n```C++\nclass Solution {\n \npublic:\n \n    int singleNumber(int A[], int n) {\n \n        int result = 0;\n \n        for(int i = 0;i < n; i++)\n \n            result ^= A[i];\n \n        return result;\n \n    }\n \n};\n```\n\n","source":"_posts/Single-Number.md","raw":"---\ntitle: Single Number\ncomments: true\ndate: 2018-11-16 00:49:48\ncategories:\n\t- leetcode\ntags:\n\t- C++\n---\n\n**问题描述：**\n\nGiven an array of integers, every element appears twice except for one. Find that single one.\n\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n\n**解决思路：**\n\n本题主要是求出一组数组中唯一个没有相同元素的数字，这里要求时间复杂度为O(n)，空间复杂度为O(1)，所以我们只需遍历一次数组就必须得到结果，并且不能使用其他额外的内存空间。这里采用异或运算，能够保证相同的元素运算结果为0，所以最终便能找个那个唯一的数字。\n\n**代码：**\n\n```C++\nclass Solution {\n \npublic:\n \n    int singleNumber(int A[], int n) {\n \n        int result = 0;\n \n        for(int i = 0;i < n; i++)\n \n            result ^= A[i];\n \n        return result;\n \n    }\n \n};\n```\n\n","slug":"Single-Number","published":1,"updated":"2018-11-15T16:50:47.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzooi001ktejeyla27kgp","content":"<p><strong>问题描述：</strong></p>\n<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>\n<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>\n<p><strong>解决思路：</strong></p>\n<p>本题主要是求出一组数组中唯一个没有相同元素的数字，这里要求时间复杂度为O(n)，空间复杂度为O(1)，所以我们只需遍历一次数组就必须得到结果，并且不能使用其他额外的内存空间。这里采用异或运算，能够保证相同的元素运算结果为0，所以最终便能找个那个唯一的数字。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n; i++)</span><br><span class=\"line\"> </span><br><span class=\"line\">            result ^= A[i];</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"abbrlink":"f249b7a1","excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>\n<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>\n<p><strong>解决思路：</strong></p>\n<p>本题主要是求出一组数组中唯一个没有相同元素的数字，这里要求时间复杂度为O(n)，空间复杂度为O(1)，所以我们只需遍历一次数组就必须得到结果，并且不能使用其他额外的内存空间。这里采用异或运算，能够保证相同的元素运算结果为0，所以最终便能找个那个唯一的数字。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n; i++)</span><br><span class=\"line\"> </span><br><span class=\"line\">            result ^= A[i];</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"Unique Binary Search Trees","comments":1,"date":"2018-11-15T16:42:32.000Z","_content":"\n**问题描述：**\n\nGiven n, how many structurally unique BST's (binary search trees) that store values 1...n?\n\nFor example,\nGiven n = 3, there are a total of 5 unique BST's.\n\n```C++\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n```\n\n**解决思路：**\n\n首先分析一下当n=0,1,2这三种情况下BTS个数，我们可以得到当n=0,1时，BTS个数为1，当n=2时，BTS个数为2.这就可以转化为一个递归求解的问题，我们将根结点从1到n依次代替，这样左右子树结点的个数就会发生变化，我们在分别求解左右子树BTS的个数，以此递归求解便可得到BTS的总数目。\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    int numTrees(int n) {\n        if(n == 1 || n == 0)\n            return 1;\n        int num = 0;\n        for(int i = 1; i <= n; i++)\n            num += numTrees(i-1) * numTrees(n-i);\n        return num;\n    }\n};\n```\n\n","source":"_posts/Unique-Binary-Search-Trees.md","raw":"---\ntitle: Unique Binary Search Trees\ncomments: true\ndate: 2018-11-16 00:42:32\ncategories:\n\t- leetcode\ntags:\n\t- C++\n\t- Binary Tree\n\t- BST\n---\n\n**问题描述：**\n\nGiven n, how many structurally unique BST's (binary search trees) that store values 1...n?\n\nFor example,\nGiven n = 3, there are a total of 5 unique BST's.\n\n```C++\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n```\n\n**解决思路：**\n\n首先分析一下当n=0,1,2这三种情况下BTS个数，我们可以得到当n=0,1时，BTS个数为1，当n=2时，BTS个数为2.这就可以转化为一个递归求解的问题，我们将根结点从1到n依次代替，这样左右子树结点的个数就会发生变化，我们在分别求解左右子树BTS的个数，以此递归求解便可得到BTS的总数目。\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    int numTrees(int n) {\n        if(n == 1 || n == 0)\n            return 1;\n        int num = 0;\n        for(int i = 1; i <= n; i++)\n            num += numTrees(i-1) * numTrees(n-i);\n        return num;\n    }\n};\n```\n\n","slug":"Unique-Binary-Search-Trees","published":1,"updated":"2018-11-15T16:44:50.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzooj001otejei9physvq","content":"<p><strong>问题描述：</strong></p>\n<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>\n<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>         <span class=\"number\">3</span>     <span class=\"number\">3</span>      <span class=\"number\">2</span>      <span class=\"number\">1</span></span><br><span class=\"line\"> \\       /     /      / \\      \\</span><br><span class=\"line\">  <span class=\"number\">3</span>     <span class=\"number\">2</span>     <span class=\"number\">1</span>      <span class=\"number\">1</span>   <span class=\"number\">3</span>      <span class=\"number\">2</span></span><br><span class=\"line\"> /     /       \\                 \\</span><br><span class=\"line\"><span class=\"number\">2</span>     <span class=\"number\">1</span>         <span class=\"number\">2</span>                 <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p><strong>解决思路：</strong></p>\n<p>首先分析一下当n=0,1,2这三种情况下BTS个数，我们可以得到当n=0,1时，BTS个数为1，当n=2时，BTS个数为2.这就可以转化为一个递归求解的问题，我们将根结点从1到n依次代替，这样左右子树结点的个数就会发生变化，我们在分别求解左右子树BTS的个数，以此递归求解便可得到BTS的总数目。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numTrees</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span> || n == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">            num += numTrees(i<span class=\"number\">-1</span>) * numTrees(n-i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"abbrlink":"20d2cb13","excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>\n<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>         <span class=\"number\">3</span>     <span class=\"number\">3</span>      <span class=\"number\">2</span>      <span class=\"number\">1</span></span><br><span class=\"line\"> \\       /     /      / \\      \\</span><br><span class=\"line\">  <span class=\"number\">3</span>     <span class=\"number\">2</span>     <span class=\"number\">1</span>      <span class=\"number\">1</span>   <span class=\"number\">3</span>      <span class=\"number\">2</span></span><br><span class=\"line\"> /     /       \\                 \\</span><br><span class=\"line\"><span class=\"number\">2</span>     <span class=\"number\">1</span>         <span class=\"number\">2</span>                 <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p><strong>解决思路：</strong></p>\n<p>首先分析一下当n=0,1,2这三种情况下BTS个数，我们可以得到当n=0,1时，BTS个数为1，当n=2时，BTS个数为2.这就可以转化为一个递归求解的问题，我们将根结点从1到n依次代替，这样左右子树结点的个数就会发生变化，我们在分别求解左右子树BTS的个数，以此递归求解便可得到BTS的总数目。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numTrees</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span> || n == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">            num += numTrees(i<span class=\"number\">-1</span>) * numTrees(n-i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"ZigZag Conversion","comments":1,"abbrlink":"61984fa2","date":"2018-11-15T16:16:46.000Z","_content":"\n**问题描述：**\n\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string text, int nRows);\nconvert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\".\n\n**解决思路：**\n\n找出规律即可，每次的周期为2*nRows-2,但是在1到nRows-1的行数还需要判断周期为2*（nRows-1-i）的元素，i是处于1到nRows-1的行数。\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    string convert(string s, int nRows) {\n        if(s.empty() || nRows <= 1 || s.length() < nRows)\n            return s;\n        string result;\n        int cycle = 2 * nRows - 2;\n        for(int i = 0; i < nRows; i++){\n            for(int j = i; j < s.length(); j += cycle){\n                result.push_back(s[j]);\n                if( i > 0 && i < nRows-1){\n                    if (j + 2 *(nRows - 1 - i) < s.length())\n                        result.push_back(s[j + 2 *(nRows - 1 - i)]);\n                }\n            }\n        }\n        return result;\n    }\n};\n```\n\n","source":"_posts/ZigZag-Conversion.md","raw":"---\ntitle: ZigZag Conversion\ncomments: true\ncategories:\n  - leetcode\ntags: C++\nabbrlink: 61984fa2\ndate: 2018-11-16 00:16:46\n---\n\n**问题描述：**\n\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string text, int nRows);\nconvert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\".\n\n**解决思路：**\n\n找出规律即可，每次的周期为2*nRows-2,但是在1到nRows-1的行数还需要判断周期为2*（nRows-1-i）的元素，i是处于1到nRows-1的行数。\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    string convert(string s, int nRows) {\n        if(s.empty() || nRows <= 1 || s.length() < nRows)\n            return s;\n        string result;\n        int cycle = 2 * nRows - 2;\n        for(int i = 0; i < nRows; i++){\n            for(int j = i; j < s.length(); j += cycle){\n                result.push_back(s[j]);\n                if( i > 0 && i < nRows-1){\n                    if (j + 2 *(nRows - 1 - i) < s.length())\n                        result.push_back(s[j + 2 *(nRows - 1 - i)]);\n                }\n            }\n        }\n        return result;\n    }\n};\n```\n\n","slug":"ZigZag-Conversion","published":1,"updated":"2018-11-15T16:25:35.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzook001rtejextiyieal","content":"<p><strong>问题描述：</strong></p>\n<p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>\n<p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>And then read line by line: “PAHNAPLSIIGYIR”<br>Write the code that will take a string and make this conversion given a number of rows:</p>\n<p>string convert(string text, int nRows);<br>convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.</p>\n<p><strong>解决思路：</strong></p>\n<p>找出规律即可，每次的周期为2<em>nRows-2,但是在1到nRows-1的行数还需要判断周期为2</em>（nRows-1-i）的元素，i是处于1到nRows-1的行数。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> nRows)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.empty() || nRows &lt;= <span class=\"number\">1</span> || s.length() &lt; nRows)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cycle = <span class=\"number\">2</span> * nRows - <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nRows; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i; j &lt; s.length(); j += cycle)&#123;</span><br><span class=\"line\">                result.push_back(s[j]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( i &gt; <span class=\"number\">0</span> &amp;&amp; i &lt; nRows<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (j + <span class=\"number\">2</span> *(nRows - <span class=\"number\">1</span> - i) &lt; s.length())</span><br><span class=\"line\">                        result.push_back(s[j + <span class=\"number\">2</span> *(nRows - <span class=\"number\">1</span> - i)]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>\n<p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>And then read line by line: “PAHNAPLSIIGYIR”<br>Write the code that will take a string and make this conversion given a number of rows:</p>\n<p>string convert(string text, int nRows);<br>convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.</p>\n<p><strong>解决思路：</strong></p>\n<p>找出规律即可，每次的周期为2<em>nRows-2,但是在1到nRows-1的行数还需要判断周期为2</em>（nRows-1-i）的元素，i是处于1到nRows-1的行数。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> nRows)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.empty() || nRows &lt;= <span class=\"number\">1</span> || s.length() &lt; nRows)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cycle = <span class=\"number\">2</span> * nRows - <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nRows; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i; j &lt; s.length(); j += cycle)&#123;</span><br><span class=\"line\">                result.push_back(s[j]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( i &gt; <span class=\"number\">0</span> &amp;&amp; i &lt; nRows<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (j + <span class=\"number\">2</span> *(nRows - <span class=\"number\">1</span> - i) &lt; s.length())</span><br><span class=\"line\">                        result.push_back(s[j + <span class=\"number\">2</span> *(nRows - <span class=\"number\">1</span> - i)]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"岛屿个数","comments":1,"abbrlink":"cc03a9fe","date":"2018-11-15T15:36:58.000Z","_content":"\n**问题描述：**\n\n给一个0,1矩阵，求不同的岛屿的个数。\n\n0代表海，1代表岛，如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。\n\n样例\n\n在矩阵：\n\n```C++\n[\n  [1, 1, 0, 0, 0],\n  [0, 1, 0, 0, 1],\n  [0, 0, 0, 1, 1],\n  [0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 1]\n]\n```\n\n中有 `3` 个岛.\n\n解题思路：深度遍历 dfs\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    /**\n     * @param grid a boolean 2D matrix\n     * @return an integer\n     */\n    int step[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\n    int numIslands(vector<vector<bool>>& grid) {\n        // Write your code here\n        int n = grid.size();\n        if(n < 1) return 0;\n        int m = grid[0].size();\n        int count = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m; j++){\n                if(grid[i][j] == true){\n                    dfs(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    \n    void dfs(vector<vector<bool>>& grid, int i, int j){\n        grid[i][j] = false;\n        for(int k = 0; k < 4; k++){\n            int x = step[k][0] + i;\n            int y = step[k][1] + j;\n            if(x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() && grid[x][y] == true){\n                dfs(grid,x,y);\n            }\n        }\n        return;\n    }\n};\n```\n\n","source":"_posts/岛屿个数.md","raw":"---\ntitle: 岛屿个数\ncomments: true\ncategories:\n  - leetcode\ntags: \n  - C++\n  - DFS\nabbrlink: cc03a9fe\ndate: 2018-11-15 23:36:58\n---\n\n**问题描述：**\n\n给一个0,1矩阵，求不同的岛屿的个数。\n\n0代表海，1代表岛，如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。\n\n样例\n\n在矩阵：\n\n```C++\n[\n  [1, 1, 0, 0, 0],\n  [0, 1, 0, 0, 1],\n  [0, 0, 0, 1, 1],\n  [0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 1]\n]\n```\n\n中有 `3` 个岛.\n\n解题思路：深度遍历 dfs\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    /**\n     * @param grid a boolean 2D matrix\n     * @return an integer\n     */\n    int step[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\n    int numIslands(vector<vector<bool>>& grid) {\n        // Write your code here\n        int n = grid.size();\n        if(n < 1) return 0;\n        int m = grid[0].size();\n        int count = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m; j++){\n                if(grid[i][j] == true){\n                    dfs(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    \n    void dfs(vector<vector<bool>>& grid, int i, int j){\n        grid[i][j] = false;\n        for(int k = 0; k < 4; k++){\n            int x = step[k][0] + i;\n            int y = step[k][1] + j;\n            if(x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() && grid[x][y] == true){\n                dfs(grid,x,y);\n            }\n        }\n        return;\n    }\n};\n```\n\n","slug":"岛屿个数","published":1,"updated":"2018-11-15T16:28:09.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzoom001vtejeoongrlbg","content":"<p><strong>问题描述：</strong></p>\n<p>给一个0,1矩阵，求不同的岛屿的个数。</p>\n<p>0代表海，1代表岛，如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。</p>\n<p>样例</p>\n<p>在矩阵：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>中有 <code>3</code> 个岛.</p>\n<p>解题思路：深度遍历 dfs</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @param grid a boolean 2D matrix</span></span><br><span class=\"line\"><span class=\"comment\">     * @return an integer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> step[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numIslands</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = grid.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = grid[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(grid[i][j] == <span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                    dfs(grid,i,j);</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt;&gt;&amp; grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        grid[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">4</span>; k++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = step[k][<span class=\"number\">0</span>] + i;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = step[k][<span class=\"number\">1</span>] + j;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(x &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; grid.size() &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; y &lt; grid[<span class=\"number\">0</span>].size() &amp;&amp; grid[x][y] == <span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                dfs(grid,x,y);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>给一个0,1矩阵，求不同的岛屿的个数。</p>\n<p>0代表海，1代表岛，如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。</p>\n<p>样例</p>\n<p>在矩阵：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">  [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>中有 <code>3</code> 个岛.</p>\n<p>解题思路：深度遍历 dfs</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @param grid a boolean 2D matrix</span></span><br><span class=\"line\"><span class=\"comment\">     * @return an integer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> step[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numIslands</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = grid.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = grid[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(grid[i][j] == <span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                    dfs(grid,i,j);</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt;&gt;&amp; grid, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        grid[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">4</span>; k++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = step[k][<span class=\"number\">0</span>] + i;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = step[k][<span class=\"number\">1</span>] + j;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(x &gt;= <span class=\"number\">0</span> &amp;&amp; x &lt; grid.size() &amp;&amp; y &gt;= <span class=\"number\">0</span> &amp;&amp; y &lt; grid[<span class=\"number\">0</span>].size() &amp;&amp; grid[x][y] == <span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                dfs(grid,x,y);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"最后一个单词的长度","comments":1,"abbrlink":"f055ffc7","date":"2018-11-15T15:19:54.000Z","_content":"\n**问题描述：**\n\n给定一个字符串， 包含大小写字母、空格`' '`，请返回其最后一个单词的长度。\n\n如果不存在最后一个单词，请返回 `0` 。\n\n样例：\n\n给定 s = `\"Hello World\"`，返回 `5`。\n\n\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    /**\n     * @param s A string\n     * @return the length of last word\n     */\n    int lengthOfLastWord(string& s) {\n        // Write your code here\n        int  n = s.length();\n        int len = 0;\n        if(n < 1) return 0;\n        int i = n - 1; \n        while(i >= 0)\n        {\n            if(s[i] == ' ')\n                i--;\n            else\n                break;\n        }\n        if(i >= 0)\n        {\n            while(s[i] != ' ' && i >= 0)\n            {\n                len++;\n                i--;\n            }\n            return len;\n        }\n        else\n            return len;\n        \n    }\n};\n```\n\n","source":"_posts/最后一个单词的长度.md","raw":"---\ntitle: 最后一个单词的长度\ncomments: true\ncategories:\n  - leetcode\ntags: \n  - C++\n  - String\nabbrlink: f055ffc7\ndate: 2018-11-15 23:19:54\n---\n\n**问题描述：**\n\n给定一个字符串， 包含大小写字母、空格`' '`，请返回其最后一个单词的长度。\n\n如果不存在最后一个单词，请返回 `0` 。\n\n样例：\n\n给定 s = `\"Hello World\"`，返回 `5`。\n\n\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    /**\n     * @param s A string\n     * @return the length of last word\n     */\n    int lengthOfLastWord(string& s) {\n        // Write your code here\n        int  n = s.length();\n        int len = 0;\n        if(n < 1) return 0;\n        int i = n - 1; \n        while(i >= 0)\n        {\n            if(s[i] == ' ')\n                i--;\n            else\n                break;\n        }\n        if(i >= 0)\n        {\n            while(s[i] != ' ' && i >= 0)\n            {\n                len++;\n                i--;\n            }\n            return len;\n        }\n        else\n            return len;\n        \n    }\n};\n```\n\n","slug":"最后一个单词的长度","published":1,"updated":"2018-11-15T16:28:05.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzoon001yteje5cedm6cb","content":"<p><strong>问题描述：</strong></p>\n<p>给定一个字符串， 包含大小写字母、空格<code>&#39; &#39;</code>，请返回其最后一个单词的长度。</p>\n<p>如果不存在最后一个单词，请返回 <code>0</code> 。</p>\n<p>样例：</p>\n<p>给定 s = <code>&quot;Hello World&quot;</code>，返回 <code>5</code>。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @param s A string</span></span><br><span class=\"line\"><span class=\"comment\">     * @return the length of last word</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span>&amp; s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>  n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">' '</span>)</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(s[i] != <span class=\"string\">' '</span> &amp;&amp; i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                len++;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>给定一个字符串， 包含大小写字母、空格<code>&#39; &#39;</code>，请返回其最后一个单词的长度。</p>\n<p>如果不存在最后一个单词，请返回 <code>0</code> 。</p>\n<p>样例：</p>\n<p>给定 s = <code>&quot;Hello World&quot;</code>，返回 <code>5</code>。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @param s A string</span></span><br><span class=\"line\"><span class=\"comment\">     * @return the length of last word</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span>&amp; s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>  n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">' '</span>)</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(s[i] != <span class=\"string\">' '</span> &amp;&amp; i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                len++;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"有效的括号序列","comments":1,"abbrlink":"cf94e2fe","date":"2018-11-15T15:41:20.000Z","_content":"\n**问题描述：**\n\n给定一个字符串所表示的括号序列，包含以下字符： `'(', ')'`, `'{'`, `'}'`, `'['` and `']'`， 判定是否是有效的括号序列。\n\n样例\n\n括号必须依照 `\"()\"` 顺序表示， `\"()[]{}\"` 是有效的括号，但 `\"([)]\"`则是无效的括号。\n\n解题思路：使用栈\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    /**\n     * @param s A string\n     * @return whether the string is a valid parentheses\n     */\n    bool isMatch(char a, char b)\n    {\n        if(a == '(' && b == ')')\n            return true;\n        if(a == '[' && b == ']')\n            return true;\n        if(a == '{' && b == '}')\n            return true;\n        return false;\n    }\n    bool isValidParentheses(string& s) {\n        // Write your code here\n        int n = s.length();\n        if(n < 1) return true;\n        if(n % 2) return false;\n        stack<char> paren;\n        paren.push(s[0]);\n        int i = 1;\n        while(i < n)\n        {\n            if(!paren.empty() && isMatch(paren.top(),s[i]))\n                paren.pop();\n            else\n                paren.push(s[i]);\n            i++;\n        }\n        if(!paren.empty()) return false;\n        else return true;\n    }\n};\n\n```\n\n","source":"_posts/有效的括号序列.md","raw":"---\ntitle: 有效的括号序列\ncomments: true\ncategories:\n  - leetcode\ntags: \n  - C++\n  - Stack\nabbrlink: cf94e2fe\ndate: 2018-11-15 23:41:20\n---\n\n**问题描述：**\n\n给定一个字符串所表示的括号序列，包含以下字符： `'(', ')'`, `'{'`, `'}'`, `'['` and `']'`， 判定是否是有效的括号序列。\n\n样例\n\n括号必须依照 `\"()\"` 顺序表示， `\"()[]{}\"` 是有效的括号，但 `\"([)]\"`则是无效的括号。\n\n解题思路：使用栈\n\n**代码：**\n\n```C++\nclass Solution {\npublic:\n    /**\n     * @param s A string\n     * @return whether the string is a valid parentheses\n     */\n    bool isMatch(char a, char b)\n    {\n        if(a == '(' && b == ')')\n            return true;\n        if(a == '[' && b == ']')\n            return true;\n        if(a == '{' && b == '}')\n            return true;\n        return false;\n    }\n    bool isValidParentheses(string& s) {\n        // Write your code here\n        int n = s.length();\n        if(n < 1) return true;\n        if(n % 2) return false;\n        stack<char> paren;\n        paren.push(s[0]);\n        int i = 1;\n        while(i < n)\n        {\n            if(!paren.empty() && isMatch(paren.top(),s[i]))\n                paren.pop();\n            else\n                paren.push(s[i]);\n            i++;\n        }\n        if(!paren.empty()) return false;\n        else return true;\n    }\n};\n\n```\n\n","slug":"有效的括号序列","published":1,"updated":"2018-11-15T16:28:04.000Z","layout":"post","photos":[],"link":"","_id":"cjoitzooo0022tejebl6yyj8i","content":"<p><strong>问题描述：</strong></p>\n<p>给定一个字符串所表示的括号序列，包含以下字符： <code>&#39;(&#39;, &#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>， 判定是否是有效的括号序列。</p>\n<p>样例</p>\n<p>括号必须依照 <code>&quot;()&quot;</code> 顺序表示， <code>&quot;()[]{}&quot;</code> 是有效的括号，但 <code>&quot;([)]&quot;</code>则是无效的括号。</p>\n<p>解题思路：使用栈</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @param s A string</span></span><br><span class=\"line\"><span class=\"comment\">     * @return whether the string is a valid parentheses</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(<span class=\"keyword\">char</span> a, <span class=\"keyword\">char</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a == <span class=\"string\">'('</span> &amp;&amp; b == <span class=\"string\">')'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a == <span class=\"string\">'['</span> &amp;&amp; b == <span class=\"string\">']'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a == <span class=\"string\">'&#123;'</span> &amp;&amp; b == <span class=\"string\">'&#125;'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidParentheses</span><span class=\"params\">(<span class=\"built_in\">string</span>&amp; s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n % <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; paren;</span><br><span class=\"line\">        paren.push(s[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; n)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!paren.empty() &amp;&amp; isMatch(paren.top(),s[i]))</span><br><span class=\"line\">                paren.pop();</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                paren.push(s[i]);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!paren.empty()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>问题描述：</strong></p>\n<p>给定一个字符串所表示的括号序列，包含以下字符： <code>&#39;(&#39;, &#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>， 判定是否是有效的括号序列。</p>\n<p>样例</p>\n<p>括号必须依照 <code>&quot;()&quot;</code> 顺序表示， <code>&quot;()[]{}&quot;</code> 是有效的括号，但 <code>&quot;([)]&quot;</code>则是无效的括号。</p>\n<p>解题思路：使用栈</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @param s A string</span></span><br><span class=\"line\"><span class=\"comment\">     * @return whether the string is a valid parentheses</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(<span class=\"keyword\">char</span> a, <span class=\"keyword\">char</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a == <span class=\"string\">'('</span> &amp;&amp; b == <span class=\"string\">')'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a == <span class=\"string\">'['</span> &amp;&amp; b == <span class=\"string\">']'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a == <span class=\"string\">'&#123;'</span> &amp;&amp; b == <span class=\"string\">'&#125;'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidParentheses</span><span class=\"params\">(<span class=\"built_in\">string</span>&amp; s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Write your code here</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n % <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; paren;</span><br><span class=\"line\">        paren.push(s[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; n)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!paren.empty() &amp;&amp; isMatch(paren.top(),s[i]))</span><br><span class=\"line\">                paren.pop();</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                paren.push(s[i]);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!paren.empty()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"手动部署ceph集群","abbrlink":"c3d7e91e","date":"2018-11-15T07:54:19.000Z","_content":"\n## 1、机器选择\n\n### 1.1 系统要求\n\nceph 最新 LTS 版本 (luminous) 推荐 linux 内核版本 `4.1.4` 及以上, 最低版本要求 `3.10.*`。\n\n\n### 1.2 服务器\n\n这里选择三台服务器来部署ceph集群，一台Mon+五台OSD\n\n------\n\n| 节点            | 服务             | cluster network  | public network   |\n| --------------- | ---------------- | ---------------- | ---------------- |\n| 192.168.226.20  | osd.1,mon.node2  | 192.168.226.0/24 | 192.168.226.0/24 |\n| 192.168.226.21  | osd.4            | 192.168.226.0/24 | 192.168.226.0/24 |\n| 192.168.226.22  | osd.2, mon.node1 | 192.168.226.0/24 | 192.168.226.0/24 |\n| 192.168.226.96  | osd.3,mon.node3  | 192.168.226.0/24 | 192.168.226.0/24 |\n| 192.168.226.106 | osd.0            | 192.168.226.0/24 | 192.168.226.0/24 |\n\n每个节点只能使用1块磁盘部署osd。所以，集群共有5个`osd`进程，3个`monitor`进程。\n\ncluster network 是处理osd间的数据复制，数据重平衡，osd进程心跳检测的网络，其不对外提供服务，只在各个osd节点间通信，本文使用eth1网卡作为cluster network，三个节点网卡eth1桥接到同一个网桥br1上\n\n\n\n## 2、环境配置 \n\n配置每个节点的host文件，在 `/etc/hosts`文件中添加如下内容：\n\n```shell\n192.168.226.20 ceph-1\n192.168.226.22 ceph-2\n192.168.226.96 ceph-3\n```\n\n### 2.2 ceph节点安装\n\n你的管理节点必须能够通过 SSH 无密码地访问各 Ceph 节点。如果 `ceph-deploy` 以某个普通用户登录，那么这个用户必须有无密码使用 `sudo` 的权限。\n\n#### 2.2.1 安装 NTP\n\n我们建议在所有 Ceph 节点上安装 NTP 服务（特别是 Ceph Monitor 节点），以免因时钟漂移导致故障，详情见[时钟](http://docs.ceph.org.cn/rados/configuration/mon-config-ref#clock)。\n\n```shell\nsudo yum install ntp ntpdate ntp-doc\n```\n\n确保在各 Ceph 节点上启动了 NTP 服务，并且要使用同一个 NTP 服务器，详情见 [NTP](http://www.ntp.org/) 。\n\n#### 2.2.2 安装 SSH 服务器\n\n在**所有 Ceph** 节点上执行如下步骤：\n\n1. 在各 Ceph 节点安装 SSH 服务器（如果还没有）\n\n   ```shell\n   sudo yum install openssh-server\n   ```\n\n2. 确保**所有** Ceph 节点上的 SSH 服务器都在运行。\n\n#### 2.2.3 安装ceph\n\n由于蚂蚁内部物理机不能访问外网，使用以下步骤安装ceph。\n\n在**所有Ceph**节点上执行如下步骤：\n\n下载ceph所有的依赖rpm，并解压缩\n\n```shell\nsudo wget http://qianli-lzh.oss-cn-hangzhou-zmf.aliyuncs.com/bill_inference_public%2Fceph.tar\nsudo tar -xvf bill_inference_public%2Fceph.tar\n```\n\n手动安装所有的rpm\n\n```shell\nsudo rpm -ivh --force --nodeps ceph/*.rpm\n```\n\n验证ceph是否正确安装\n\n```shell\nceph -v\nceph version 12.2.8 (ae699615bac534ea496ee965ac6192cb7e0e07c0) luminous (stable)\n```\n\n#### 2.2.4 关闭防火墙\n\n```shell\nsudo sed -i 's/SELINUX=.*/SELINUX=disabled/' /etc/selinux/config\nsudo setenforce 0\nsudo systemctl stop firewalld \nsudo systemctl disable firewalld\n```\n\n## 3、集群搭建\n\n### 3.1 搭建Mon集群 (使用admin账户)\n\n**创建配置文件**\n\n在**每台节点机器**上创建配置文件`/etc/ceph/ceph.conf`：\n\n```shell\n[global]\nfsid = 932XXXXX-fba7-XXXX-9526-a858c613f468\nmon initial members = e15p13447.ew9\nmon host = 192.168.226.20,192.168.226.22,192.168.226.96\nrbd default features = 1\nauth_cluster_required = none\nauth_service_required = none\nauth_client_required = none\npublic network = 192.168.226.0/24\ncluster network = 192.168.226.0/24\nosd journal size = 1024\nosd pool default size = 2\nosd pool default min size = 1\nosd pool default pg num = 128\nosd pool default pgp num = 128\nosd crush chooseleaf type = 1\nmon_max_pg_per_osd = 200\n\n[mds.ceph-1]\nhost = ceph-1\n[mds.ceph-2]\nhost = ceph-2\n[mds.ceph-3]\nhost = ceph-3\n\n[mon]\nmon allow pool delete = true\n```\n\n其中 `fsid` 是为集群分配的一个 uuid, 初始化 mon 节点其实只需要这一个配置就够了。\n`mon host` 配置 ceph 命令行工具访问操作 ceph 集群时查找 mon 节点入口。\nceph 集群可包含多个 mon 节点实现高可用容灾, 避免单点故障。\n`rbd default features = 1` 配置 rbd 客户端创建磁盘时禁用一些需要高版本内核才能支持的特性。\n\n#### 3.1.2 主mon节点 （192.168.226.20）\n\n1、为此集群创建密钥环、并生成Monitor密钥 (3台机器一样)\n\n```shell\nsudo ceph-authtool --create-keyring /tmp/ceph.mon.keyring --gen-key -n mon. --cap mon 'allow *'\n```\n\n2、生成管理员密钥环，生成 `client.admin` 用户并加入密钥环 (3台机器一样)\n\n```shell\nsudo ceph-authtool --create-keyring /etc/ceph/ceph.client.admin.keyring --gen-key -n client.admin --set-uid=0 --cap mon 'allow *' --cap osd 'allow *' --cap mds 'allow *' --cap mgr 'allow *' \n```\n\n3、把 `client.admin` 密钥加入 `ceph.mon.keyring`  (3台机器一样)\n\n```shell\nsudo ceph-authtool /tmp/ceph.mon.keyring --import-keyring /etc/ceph/ceph.client.admin.keyring\n```\n\n4、用规划好的主机名、对应 IP 地址、和 FSID 生成一个Monitor Map，并保存为 `/tmp/monmap`\n\n```shell\nhost_name=`hostname`\nsudo monmaptool --create --add $host_name 192.168.226.20  --fsid 932XXXXX-fba7-XXXX-9526-a858c613f468 /tmp/monmap --clobber\n```\n\n5、在Monitor主机上分别创建数据目录\n\n```shell\nhost_name=`hostname`\n#在admin账户下\nsudo mkdir /var/lib/ceph/mon/ceph-$host_name/\n```\n\n6、用Monitor Map和密钥环组装守护进程所需的初始数据\n\n```shell\nsudo ceph-mon --mkfs -i $host_name --monmap /tmp/monmap --keyring /tmp/ceph.mon.keyring\n```\n\n7、建一个空文件 `done` ，表示监视器已创建、可以启动了\n\n```shell\nsudo touch /var/lib/ceph/mon/ceph-$host_name/done\n```\n\n8、启动Monitor\n\n```shell\n#sudo ceph-mon -f --cluster ceph --id $host_name &\nsudo cp /usr/lib/systemd/system/ceph-mon@.service /usr/lib/systemd/system/ceph-mon@$host_name.service\nsudo systemctl start ceph-mon@$host_name\nsudo systemctl enable ceph-mon@$host_name\n```\n\n9、确认下集群在运行\n\n```shell\nceph -s\n```\n\n事例：\n\n```shell\n  cluster:\n    id:     932XXXXX-fba7-XXXX-9526-a858c613f468\n    health: HEALTH_OK\n \n  services:\n    mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3\n    mgr: no daemons active\n    osd: 0 osds: 0 up, 0 in\n \n  data:\n    pools:   0 pools, 0 pgs\n    objects: 0 objects, 0B\n    usage:   0B used, 0B / 0B avail\n    pgs:     \n```\n\n#### 3.1.2 从mon节点 (192.168.226.22 & 192.168.226.96)\n\n```shell\nhost_name=`hostname`\nsudo ceph mon getmap -o /tmp/monmap\nsudo rm -rf /var/lib/ceph/mon/ceph-$host_name\nsudo ceph-mon -i $host_name --mkfs --monmap /tmp/monmap\nsudo chown -R ceph:ceph /var/lib/ceph/mon/ceph-$host_name/\n#nohup ceph-mon -f --cluster ceph --id $host_name --setuser ceph --setgroup ceph &\n#ceph-mon -f --cluster ceph --id $host_name &\nsudo cp /usr/lib/systemd/system/ceph-mon@.service /usr/lib/systemd/system/ceph-mon@$host_name.service\nsudo systemctl start ceph-mon@$host_name\nsudo systemctl enable ceph-mon@$host_name\n```\n\n\n\n### 3.2 创建ceph-mgr\n\n#### 3.2.1 创建用户 openstack 用于 MGR 监控\n\n```shell\nceph auth get-or-create mgr.openstack mon 'allow *' osd 'allow *' mds 'allow *'\n输出：\n[mgr.openstack]\n        key = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxugvXkLfgauLA==\n```\n\n需要将之前创建的用户密码存放至对应位置\n\n```shell\nmkdir /var/lib/ceph/mgr/ceph-openstack\nceph auth get mgr.openstack -o  /var/lib/ceph/mgr/ceph-openstack/keyring\nexported keyring for mgr.openstack\n```\n\n#### 3.2.2 启动mgr\n\n```shell\nceph-mgr -i openstack\n```\n\n监控状态\n\n```shell\n$ceph -s\n  cluster:\n    id:     932e88a6-fba7-45a9-9526-a858c613f468\n    health: HEALTH_OK\n \n  services:\n    mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3\n    mgr: openstack(active)\n    mds: cephfs-1/1/1 up  {0=2=up:active}, 2 up:standby\n    osd: 3 osds: 3 up, 3 in\n \n  data:\n    pools:   2 pools, 256 pgs\n    objects: 21 objects, 3.04KiB\n    usage:   3.32GiB used, 1.17TiB / 1.17TiB avail\n    pgs:     256 active+clean\n```\n\n当 mgr 服务被激活之后, service 中 mgr 会显示 mgr-$name(active) \ndata 部分信息将变得可用\n\n### 3.3 手动搭建osd集群(三台机器上做相同的操作，注意osd_id的变化)\n\n添加一个新osd，`id`可以省略，ceph会自动使用最小可用整数，第一个osd从0开始\n\n```shell\n#ceph osd create {id}\nceph osd create\n0\n```\n\n#### 3.3.1 初始化osd目录\n\n创建osd.0目录，目录名格式`{cluster-name}-{id}`\n\n```shell\n#mkdir /var/lib/ceph/osd/{cluster-name}-{id}\nsudo mkdir /var/lib/ceph/osd/ceph-0\n```\n\n挂载osd.0的数据盘/dev/sdb2\n\n```shell\nsudo mkfs.xfs /dev/sdb2\nsudo mount /dev/sdb2 /var/lib/ceph/osd/ceph-0\n```\n\n初始化osd数据目录\n\n```shell\n# sudo ceph-osd -i {id} --mkfs --mkkey\nsudo ceph-osd -i 0 --mkfs --mkkey\n#--mkkey要求osd数据目录为空\n#这会创建osd.0的keyring /var/lib/ceph/osd/ceph-0/keyring\n```\n\n初始化后，默认使用普通文件/var/lib/ceph/osd/ceph-3/journal作为osd.0的journal分区，普通文件作为journal分区性能不高，若只是测试环境，可以跳过更改journal分区这一步骤\n\n#### 3.3.2 创建journal\n\n生成journal分区，一般选ssd盘作为journal分区，这里使用ssd的/dev/sdb1分区作为journal\n\n使用fdisk工分出磁盘/dev/sdb1,\n\n```shell\n#清除磁盘所有分区(重新添加时需要)\n#sgdisk --zap-all --clear --mbrtogpt /dev/sdb\n#生成分区/dev/sdb1的uuid\n#uuidgen\n#b3897364-8807-48eb-9905-e2c8400d0cd4\n#创建分区\n#1:0:+100G 表示创建第一个分区，100G大小\n#sudo sgdisk --new=1:0:+100G --change-name=1:'ceph journal' --partition-guid=1:b3897364-8807-48eb-9905-e2c8400d0cd4 --typecode=1:b3897364-8807-48eb-9905-e2c8400d0cd4 --mbrtogpt -- /dev/vdf\n#格式化\nsudo mkfs.xfs /dev/sdb1\nsudo rm -f /var/lib/ceph/osd/ceph-4/journal \n#查看分区对应的partuuid， 找出/dev/sdb1对应的partuuid\nsudo blkid\nsudo ln -s /dev/disk/by-partuuid/b3897364-8807-48eb-9905-e2c8400d0cd4 /var/lib/ceph/osd/ceph-0/journal\n\nsudo chown ceph:ceph -R /var/lib/ceph/osd/ceph-0\nsudo chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal\n#初始化新的journal\nsudo ceph-osd --mkjournal -i 0\nsudo chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal\n```\n\n\n\n#### 3.3.3 注册osd.{id}，id为osd编号，默认从0开始\n\n```shell\n# sudo ceph auth add osd.{id} osd 'allow *' mon 'allow profile osd' -i /var/lib/ceph/osd/ceph-{id}/keyring\nsudo ceph auth add osd.0 osd 'allow *' mon 'allow profile osd' -i /var/lib/ceph/osd/ceph-0/keyring\n#ceph auth list 中出现osd.0\n```\n\n#### 3.3.4 加入crush map\n\n这是m1上新创建的第一个osd，CRUSH map中还没有m1节点，因此首先要把m1节点加入CRUSH map，同理，m2/m3节点也需要加入CRUSH map\n\n```shell\n#ceph osd crush add-bucket {hostname} host\nsudo ceph osd crush add-bucket `hostname` host\n```\n\n然后把三个节点移动到默认的root `default`下面\n\n```shell\nsudo ceph osd crush move `hostname` root=default\n```\n\n添加osd.0到CRUSH map中的m1节点下面，加入后，osd.0就能够接收数据\n\n```shell\n#ceph osd crush add osd.{id} 0.4 root=sata rack=sata-rack01 host=sata-node5\nsudo ceph osd crush add osd.4 1.7 root=default host=`hostname`\n#0.4为此osd在CRUSH map中的权重值，它表示数据落在此osd上的比重，是一个相对值，一般按照1T磁盘比重值为1来计算，这里的osd数据盘1.7，所以值为1.7  \n```\n\n此时osd.0状态是`down`且`in`，`in`表示此osd位于CRUSH map，已经准备好接受数据，`down`表示osd进程运行异常，因为我们还没有启动osd.0进程\n\n#### 3.3.5 启动ceph-osd进程\n\n需要向systemctl传递osd的`id`以启动指定的osd进程，如下，我们准备启动osd.0进程\n\n```shell\n#systemctl start ceph-osd@{id}  id表示osd编号，从数字0开始\nsudo cp /usr/lib/systemd/system/ceph-osd@.service /usr/lib/systemd/system/ceph-osd@0.service\nsudo systemctl start ceph-osd@0\nsudo systemctl enable ceph-osd@0\n#sudo ceph-osd -i 0\n```\n\n上面就是添加osd.0的步骤，然后可以接着在其他`hostname`节点上添加osd.{1,2}，添加了这3个osd后，可以查看集群状态 ceph -s。\n\n### 3.4 搭建MDS\n\n创建目录：\n\n```shell\nsudo mkdir /var/lib/ceph/mds/ceph-`hostname`\nsudo chown ceph:ceph -R /var/lib/ceph/mds/ceph-`hostname`\n```\n\n在ceph.conf中添加如下信息：\n\n```shell\n[mds.{id}]\nhost = {id}\n例如：\n[mds.0]\nhost = 0\n```\n\n启动mds\n\n```shell\n#ceph-mds --cluster {cluster-name} -i {id} -m {mon-hostname}:{mon-port} [-f]\nsudo cp /usr/lib/systemd/system/ceph-mds@.service /usr/lib/systemd/system/ceph-mds@`hostname`.service \nsudo systemctl start ceph-mds@`hostname`\nsudo systemctl enable ceph-mds@`hostname`\n#ceph-mds --cluster ceph -i 0 -m e15p13447.ew9:6789\n```\n\n查看mds状态\n\n```shell\nceph mds stat\ncephfs-1/1/1 up  {0=1=up:active}, 2 up:standby\n```\n\n至此ceph集群搭建完成。","source":"_posts/manual-deploy-ceph.md","raw":"---\ntitle: 手动部署ceph集群\ntags: ceph\ncategories:\n  - ceph\nabbrlink: c3d7e91e\ndate: 2018-11-15 15:54:19\n---\n\n## 1、机器选择\n\n### 1.1 系统要求\n\nceph 最新 LTS 版本 (luminous) 推荐 linux 内核版本 `4.1.4` 及以上, 最低版本要求 `3.10.*`。\n\n\n### 1.2 服务器\n\n这里选择三台服务器来部署ceph集群，一台Mon+五台OSD\n\n------\n\n| 节点            | 服务             | cluster network  | public network   |\n| --------------- | ---------------- | ---------------- | ---------------- |\n| 192.168.226.20  | osd.1,mon.node2  | 192.168.226.0/24 | 192.168.226.0/24 |\n| 192.168.226.21  | osd.4            | 192.168.226.0/24 | 192.168.226.0/24 |\n| 192.168.226.22  | osd.2, mon.node1 | 192.168.226.0/24 | 192.168.226.0/24 |\n| 192.168.226.96  | osd.3,mon.node3  | 192.168.226.0/24 | 192.168.226.0/24 |\n| 192.168.226.106 | osd.0            | 192.168.226.0/24 | 192.168.226.0/24 |\n\n每个节点只能使用1块磁盘部署osd。所以，集群共有5个`osd`进程，3个`monitor`进程。\n\ncluster network 是处理osd间的数据复制，数据重平衡，osd进程心跳检测的网络，其不对外提供服务，只在各个osd节点间通信，本文使用eth1网卡作为cluster network，三个节点网卡eth1桥接到同一个网桥br1上\n\n\n\n## 2、环境配置 \n\n配置每个节点的host文件，在 `/etc/hosts`文件中添加如下内容：\n\n```shell\n192.168.226.20 ceph-1\n192.168.226.22 ceph-2\n192.168.226.96 ceph-3\n```\n\n### 2.2 ceph节点安装\n\n你的管理节点必须能够通过 SSH 无密码地访问各 Ceph 节点。如果 `ceph-deploy` 以某个普通用户登录，那么这个用户必须有无密码使用 `sudo` 的权限。\n\n#### 2.2.1 安装 NTP\n\n我们建议在所有 Ceph 节点上安装 NTP 服务（特别是 Ceph Monitor 节点），以免因时钟漂移导致故障，详情见[时钟](http://docs.ceph.org.cn/rados/configuration/mon-config-ref#clock)。\n\n```shell\nsudo yum install ntp ntpdate ntp-doc\n```\n\n确保在各 Ceph 节点上启动了 NTP 服务，并且要使用同一个 NTP 服务器，详情见 [NTP](http://www.ntp.org/) 。\n\n#### 2.2.2 安装 SSH 服务器\n\n在**所有 Ceph** 节点上执行如下步骤：\n\n1. 在各 Ceph 节点安装 SSH 服务器（如果还没有）\n\n   ```shell\n   sudo yum install openssh-server\n   ```\n\n2. 确保**所有** Ceph 节点上的 SSH 服务器都在运行。\n\n#### 2.2.3 安装ceph\n\n由于蚂蚁内部物理机不能访问外网，使用以下步骤安装ceph。\n\n在**所有Ceph**节点上执行如下步骤：\n\n下载ceph所有的依赖rpm，并解压缩\n\n```shell\nsudo wget http://qianli-lzh.oss-cn-hangzhou-zmf.aliyuncs.com/bill_inference_public%2Fceph.tar\nsudo tar -xvf bill_inference_public%2Fceph.tar\n```\n\n手动安装所有的rpm\n\n```shell\nsudo rpm -ivh --force --nodeps ceph/*.rpm\n```\n\n验证ceph是否正确安装\n\n```shell\nceph -v\nceph version 12.2.8 (ae699615bac534ea496ee965ac6192cb7e0e07c0) luminous (stable)\n```\n\n#### 2.2.4 关闭防火墙\n\n```shell\nsudo sed -i 's/SELINUX=.*/SELINUX=disabled/' /etc/selinux/config\nsudo setenforce 0\nsudo systemctl stop firewalld \nsudo systemctl disable firewalld\n```\n\n## 3、集群搭建\n\n### 3.1 搭建Mon集群 (使用admin账户)\n\n**创建配置文件**\n\n在**每台节点机器**上创建配置文件`/etc/ceph/ceph.conf`：\n\n```shell\n[global]\nfsid = 932XXXXX-fba7-XXXX-9526-a858c613f468\nmon initial members = e15p13447.ew9\nmon host = 192.168.226.20,192.168.226.22,192.168.226.96\nrbd default features = 1\nauth_cluster_required = none\nauth_service_required = none\nauth_client_required = none\npublic network = 192.168.226.0/24\ncluster network = 192.168.226.0/24\nosd journal size = 1024\nosd pool default size = 2\nosd pool default min size = 1\nosd pool default pg num = 128\nosd pool default pgp num = 128\nosd crush chooseleaf type = 1\nmon_max_pg_per_osd = 200\n\n[mds.ceph-1]\nhost = ceph-1\n[mds.ceph-2]\nhost = ceph-2\n[mds.ceph-3]\nhost = ceph-3\n\n[mon]\nmon allow pool delete = true\n```\n\n其中 `fsid` 是为集群分配的一个 uuid, 初始化 mon 节点其实只需要这一个配置就够了。\n`mon host` 配置 ceph 命令行工具访问操作 ceph 集群时查找 mon 节点入口。\nceph 集群可包含多个 mon 节点实现高可用容灾, 避免单点故障。\n`rbd default features = 1` 配置 rbd 客户端创建磁盘时禁用一些需要高版本内核才能支持的特性。\n\n#### 3.1.2 主mon节点 （192.168.226.20）\n\n1、为此集群创建密钥环、并生成Monitor密钥 (3台机器一样)\n\n```shell\nsudo ceph-authtool --create-keyring /tmp/ceph.mon.keyring --gen-key -n mon. --cap mon 'allow *'\n```\n\n2、生成管理员密钥环，生成 `client.admin` 用户并加入密钥环 (3台机器一样)\n\n```shell\nsudo ceph-authtool --create-keyring /etc/ceph/ceph.client.admin.keyring --gen-key -n client.admin --set-uid=0 --cap mon 'allow *' --cap osd 'allow *' --cap mds 'allow *' --cap mgr 'allow *' \n```\n\n3、把 `client.admin` 密钥加入 `ceph.mon.keyring`  (3台机器一样)\n\n```shell\nsudo ceph-authtool /tmp/ceph.mon.keyring --import-keyring /etc/ceph/ceph.client.admin.keyring\n```\n\n4、用规划好的主机名、对应 IP 地址、和 FSID 生成一个Monitor Map，并保存为 `/tmp/monmap`\n\n```shell\nhost_name=`hostname`\nsudo monmaptool --create --add $host_name 192.168.226.20  --fsid 932XXXXX-fba7-XXXX-9526-a858c613f468 /tmp/monmap --clobber\n```\n\n5、在Monitor主机上分别创建数据目录\n\n```shell\nhost_name=`hostname`\n#在admin账户下\nsudo mkdir /var/lib/ceph/mon/ceph-$host_name/\n```\n\n6、用Monitor Map和密钥环组装守护进程所需的初始数据\n\n```shell\nsudo ceph-mon --mkfs -i $host_name --monmap /tmp/monmap --keyring /tmp/ceph.mon.keyring\n```\n\n7、建一个空文件 `done` ，表示监视器已创建、可以启动了\n\n```shell\nsudo touch /var/lib/ceph/mon/ceph-$host_name/done\n```\n\n8、启动Monitor\n\n```shell\n#sudo ceph-mon -f --cluster ceph --id $host_name &\nsudo cp /usr/lib/systemd/system/ceph-mon@.service /usr/lib/systemd/system/ceph-mon@$host_name.service\nsudo systemctl start ceph-mon@$host_name\nsudo systemctl enable ceph-mon@$host_name\n```\n\n9、确认下集群在运行\n\n```shell\nceph -s\n```\n\n事例：\n\n```shell\n  cluster:\n    id:     932XXXXX-fba7-XXXX-9526-a858c613f468\n    health: HEALTH_OK\n \n  services:\n    mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3\n    mgr: no daemons active\n    osd: 0 osds: 0 up, 0 in\n \n  data:\n    pools:   0 pools, 0 pgs\n    objects: 0 objects, 0B\n    usage:   0B used, 0B / 0B avail\n    pgs:     \n```\n\n#### 3.1.2 从mon节点 (192.168.226.22 & 192.168.226.96)\n\n```shell\nhost_name=`hostname`\nsudo ceph mon getmap -o /tmp/monmap\nsudo rm -rf /var/lib/ceph/mon/ceph-$host_name\nsudo ceph-mon -i $host_name --mkfs --monmap /tmp/monmap\nsudo chown -R ceph:ceph /var/lib/ceph/mon/ceph-$host_name/\n#nohup ceph-mon -f --cluster ceph --id $host_name --setuser ceph --setgroup ceph &\n#ceph-mon -f --cluster ceph --id $host_name &\nsudo cp /usr/lib/systemd/system/ceph-mon@.service /usr/lib/systemd/system/ceph-mon@$host_name.service\nsudo systemctl start ceph-mon@$host_name\nsudo systemctl enable ceph-mon@$host_name\n```\n\n\n\n### 3.2 创建ceph-mgr\n\n#### 3.2.1 创建用户 openstack 用于 MGR 监控\n\n```shell\nceph auth get-or-create mgr.openstack mon 'allow *' osd 'allow *' mds 'allow *'\n输出：\n[mgr.openstack]\n        key = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxugvXkLfgauLA==\n```\n\n需要将之前创建的用户密码存放至对应位置\n\n```shell\nmkdir /var/lib/ceph/mgr/ceph-openstack\nceph auth get mgr.openstack -o  /var/lib/ceph/mgr/ceph-openstack/keyring\nexported keyring for mgr.openstack\n```\n\n#### 3.2.2 启动mgr\n\n```shell\nceph-mgr -i openstack\n```\n\n监控状态\n\n```shell\n$ceph -s\n  cluster:\n    id:     932e88a6-fba7-45a9-9526-a858c613f468\n    health: HEALTH_OK\n \n  services:\n    mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3\n    mgr: openstack(active)\n    mds: cephfs-1/1/1 up  {0=2=up:active}, 2 up:standby\n    osd: 3 osds: 3 up, 3 in\n \n  data:\n    pools:   2 pools, 256 pgs\n    objects: 21 objects, 3.04KiB\n    usage:   3.32GiB used, 1.17TiB / 1.17TiB avail\n    pgs:     256 active+clean\n```\n\n当 mgr 服务被激活之后, service 中 mgr 会显示 mgr-$name(active) \ndata 部分信息将变得可用\n\n### 3.3 手动搭建osd集群(三台机器上做相同的操作，注意osd_id的变化)\n\n添加一个新osd，`id`可以省略，ceph会自动使用最小可用整数，第一个osd从0开始\n\n```shell\n#ceph osd create {id}\nceph osd create\n0\n```\n\n#### 3.3.1 初始化osd目录\n\n创建osd.0目录，目录名格式`{cluster-name}-{id}`\n\n```shell\n#mkdir /var/lib/ceph/osd/{cluster-name}-{id}\nsudo mkdir /var/lib/ceph/osd/ceph-0\n```\n\n挂载osd.0的数据盘/dev/sdb2\n\n```shell\nsudo mkfs.xfs /dev/sdb2\nsudo mount /dev/sdb2 /var/lib/ceph/osd/ceph-0\n```\n\n初始化osd数据目录\n\n```shell\n# sudo ceph-osd -i {id} --mkfs --mkkey\nsudo ceph-osd -i 0 --mkfs --mkkey\n#--mkkey要求osd数据目录为空\n#这会创建osd.0的keyring /var/lib/ceph/osd/ceph-0/keyring\n```\n\n初始化后，默认使用普通文件/var/lib/ceph/osd/ceph-3/journal作为osd.0的journal分区，普通文件作为journal分区性能不高，若只是测试环境，可以跳过更改journal分区这一步骤\n\n#### 3.3.2 创建journal\n\n生成journal分区，一般选ssd盘作为journal分区，这里使用ssd的/dev/sdb1分区作为journal\n\n使用fdisk工分出磁盘/dev/sdb1,\n\n```shell\n#清除磁盘所有分区(重新添加时需要)\n#sgdisk --zap-all --clear --mbrtogpt /dev/sdb\n#生成分区/dev/sdb1的uuid\n#uuidgen\n#b3897364-8807-48eb-9905-e2c8400d0cd4\n#创建分区\n#1:0:+100G 表示创建第一个分区，100G大小\n#sudo sgdisk --new=1:0:+100G --change-name=1:'ceph journal' --partition-guid=1:b3897364-8807-48eb-9905-e2c8400d0cd4 --typecode=1:b3897364-8807-48eb-9905-e2c8400d0cd4 --mbrtogpt -- /dev/vdf\n#格式化\nsudo mkfs.xfs /dev/sdb1\nsudo rm -f /var/lib/ceph/osd/ceph-4/journal \n#查看分区对应的partuuid， 找出/dev/sdb1对应的partuuid\nsudo blkid\nsudo ln -s /dev/disk/by-partuuid/b3897364-8807-48eb-9905-e2c8400d0cd4 /var/lib/ceph/osd/ceph-0/journal\n\nsudo chown ceph:ceph -R /var/lib/ceph/osd/ceph-0\nsudo chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal\n#初始化新的journal\nsudo ceph-osd --mkjournal -i 0\nsudo chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal\n```\n\n\n\n#### 3.3.3 注册osd.{id}，id为osd编号，默认从0开始\n\n```shell\n# sudo ceph auth add osd.{id} osd 'allow *' mon 'allow profile osd' -i /var/lib/ceph/osd/ceph-{id}/keyring\nsudo ceph auth add osd.0 osd 'allow *' mon 'allow profile osd' -i /var/lib/ceph/osd/ceph-0/keyring\n#ceph auth list 中出现osd.0\n```\n\n#### 3.3.4 加入crush map\n\n这是m1上新创建的第一个osd，CRUSH map中还没有m1节点，因此首先要把m1节点加入CRUSH map，同理，m2/m3节点也需要加入CRUSH map\n\n```shell\n#ceph osd crush add-bucket {hostname} host\nsudo ceph osd crush add-bucket `hostname` host\n```\n\n然后把三个节点移动到默认的root `default`下面\n\n```shell\nsudo ceph osd crush move `hostname` root=default\n```\n\n添加osd.0到CRUSH map中的m1节点下面，加入后，osd.0就能够接收数据\n\n```shell\n#ceph osd crush add osd.{id} 0.4 root=sata rack=sata-rack01 host=sata-node5\nsudo ceph osd crush add osd.4 1.7 root=default host=`hostname`\n#0.4为此osd在CRUSH map中的权重值，它表示数据落在此osd上的比重，是一个相对值，一般按照1T磁盘比重值为1来计算，这里的osd数据盘1.7，所以值为1.7  \n```\n\n此时osd.0状态是`down`且`in`，`in`表示此osd位于CRUSH map，已经准备好接受数据，`down`表示osd进程运行异常，因为我们还没有启动osd.0进程\n\n#### 3.3.5 启动ceph-osd进程\n\n需要向systemctl传递osd的`id`以启动指定的osd进程，如下，我们准备启动osd.0进程\n\n```shell\n#systemctl start ceph-osd@{id}  id表示osd编号，从数字0开始\nsudo cp /usr/lib/systemd/system/ceph-osd@.service /usr/lib/systemd/system/ceph-osd@0.service\nsudo systemctl start ceph-osd@0\nsudo systemctl enable ceph-osd@0\n#sudo ceph-osd -i 0\n```\n\n上面就是添加osd.0的步骤，然后可以接着在其他`hostname`节点上添加osd.{1,2}，添加了这3个osd后，可以查看集群状态 ceph -s。\n\n### 3.4 搭建MDS\n\n创建目录：\n\n```shell\nsudo mkdir /var/lib/ceph/mds/ceph-`hostname`\nsudo chown ceph:ceph -R /var/lib/ceph/mds/ceph-`hostname`\n```\n\n在ceph.conf中添加如下信息：\n\n```shell\n[mds.{id}]\nhost = {id}\n例如：\n[mds.0]\nhost = 0\n```\n\n启动mds\n\n```shell\n#ceph-mds --cluster {cluster-name} -i {id} -m {mon-hostname}:{mon-port} [-f]\nsudo cp /usr/lib/systemd/system/ceph-mds@.service /usr/lib/systemd/system/ceph-mds@`hostname`.service \nsudo systemctl start ceph-mds@`hostname`\nsudo systemctl enable ceph-mds@`hostname`\n#ceph-mds --cluster ceph -i 0 -m e15p13447.ew9:6789\n```\n\n查看mds状态\n\n```shell\nceph mds stat\ncephfs-1/1/1 up  {0=1=up:active}, 2 up:standby\n```\n\n至此ceph集群搭建完成。","slug":"manual-deploy-ceph","published":1,"updated":"2018-11-15T14:56:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoitzopj0031tejebboldcqr","content":"<h2 id=\"1、机器选择\"><a href=\"#1、机器选择\" class=\"headerlink\" title=\"1、机器选择\"></a>1、机器选择</h2><h3 id=\"1-1-系统要求\"><a href=\"#1-1-系统要求\" class=\"headerlink\" title=\"1.1 系统要求\"></a>1.1 系统要求</h3><p>ceph 最新 LTS 版本 (luminous) 推荐 linux 内核版本 <code>4.1.4</code> 及以上, 最低版本要求 <code>3.10.*</code>。</p>\n<h3 id=\"1-2-服务器\"><a href=\"#1-2-服务器\" class=\"headerlink\" title=\"1.2 服务器\"></a>1.2 服务器</h3><p>这里选择三台服务器来部署ceph集群，一台Mon+五台OSD</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>节点</th>\n<th>服务</th>\n<th>cluster network</th>\n<th>public network</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>192.168.226.20</td>\n<td>osd.1,mon.node2</td>\n<td>192.168.226.0/24</td>\n<td>192.168.226.0/24</td>\n</tr>\n<tr>\n<td>192.168.226.21</td>\n<td>osd.4</td>\n<td>192.168.226.0/24</td>\n<td>192.168.226.0/24</td>\n</tr>\n<tr>\n<td>192.168.226.22</td>\n<td>osd.2, mon.node1</td>\n<td>192.168.226.0/24</td>\n<td>192.168.226.0/24</td>\n</tr>\n<tr>\n<td>192.168.226.96</td>\n<td>osd.3,mon.node3</td>\n<td>192.168.226.0/24</td>\n<td>192.168.226.0/24</td>\n</tr>\n<tr>\n<td>192.168.226.106</td>\n<td>osd.0</td>\n<td>192.168.226.0/24</td>\n<td>192.168.226.0/24</td>\n</tr>\n</tbody>\n</table>\n<p>每个节点只能使用1块磁盘部署osd。所以，集群共有5个<code>osd</code>进程，3个<code>monitor</code>进程。</p>\n<p>cluster network 是处理osd间的数据复制，数据重平衡，osd进程心跳检测的网络，其不对外提供服务，只在各个osd节点间通信，本文使用eth1网卡作为cluster network，三个节点网卡eth1桥接到同一个网桥br1上</p>\n<h2 id=\"2、环境配置\"><a href=\"#2、环境配置\" class=\"headerlink\" title=\"2、环境配置\"></a>2、环境配置</h2><p>配置每个节点的host文件，在 <code>/etc/hosts</code>文件中添加如下内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">192.168.226.20 ceph-1</span><br><span class=\"line\">192.168.226.22 ceph-2</span><br><span class=\"line\">192.168.226.96 ceph-3</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-ceph节点安装\"><a href=\"#2-2-ceph节点安装\" class=\"headerlink\" title=\"2.2 ceph节点安装\"></a>2.2 ceph节点安装</h3><p>你的管理节点必须能够通过 SSH 无密码地访问各 Ceph 节点。如果 <code>ceph-deploy</code> 以某个普通用户登录，那么这个用户必须有无密码使用 <code>sudo</code> 的权限。</p>\n<h4 id=\"2-2-1-安装-NTP\"><a href=\"#2-2-1-安装-NTP\" class=\"headerlink\" title=\"2.2.1 安装 NTP\"></a>2.2.1 安装 NTP</h4><p>我们建议在所有 Ceph 节点上安装 NTP 服务（特别是 Ceph Monitor 节点），以免因时钟漂移导致故障，详情见<a href=\"http://docs.ceph.org.cn/rados/configuration/mon-config-ref#clock\" target=\"_blank\" rel=\"noopener\">时钟</a>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install ntp ntpdate ntp-doc</span><br></pre></td></tr></table></figure>\n<p>确保在各 Ceph 节点上启动了 NTP 服务，并且要使用同一个 NTP 服务器，详情见 <a href=\"http://www.ntp.org/\" target=\"_blank\" rel=\"noopener\">NTP</a> 。</p>\n<h4 id=\"2-2-2-安装-SSH-服务器\"><a href=\"#2-2-2-安装-SSH-服务器\" class=\"headerlink\" title=\"2.2.2 安装 SSH 服务器\"></a>2.2.2 安装 SSH 服务器</h4><p>在<strong>所有 Ceph</strong> 节点上执行如下步骤：</p>\n<ol>\n<li><p>在各 Ceph 节点安装 SSH 服务器（如果还没有）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install openssh-server</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确保<strong>所有</strong> Ceph 节点上的 SSH 服务器都在运行。</p>\n</li>\n</ol>\n<h4 id=\"2-2-3-安装ceph\"><a href=\"#2-2-3-安装ceph\" class=\"headerlink\" title=\"2.2.3 安装ceph\"></a>2.2.3 安装ceph</h4><p>由于蚂蚁内部物理机不能访问外网，使用以下步骤安装ceph。</p>\n<p>在<strong>所有Ceph</strong>节点上执行如下步骤：</p>\n<p>下载ceph所有的依赖rpm，并解压缩</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo wget http://qianli-lzh.oss-cn-hangzhou-zmf.aliyuncs.com/bill_inference_public%2Fceph.tar</span><br><span class=\"line\">sudo tar -xvf bill_inference_public%2Fceph.tar</span><br></pre></td></tr></table></figure>\n<p>手动安装所有的rpm</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rpm -ivh --force --nodeps ceph/*.rpm</span><br></pre></td></tr></table></figure>\n<p>验证ceph是否正确安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ceph -v</span><br><span class=\"line\">ceph version 12.2.8 (ae699615bac534ea496ee965ac6192cb7e0e07c0) luminous (stable)</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-4-关闭防火墙\"><a href=\"#2-2-4-关闭防火墙\" class=\"headerlink\" title=\"2.2.4 关闭防火墙\"></a>2.2.4 关闭防火墙</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo sed -i 's/SELINUX=.*/SELINUX=disabled/' /etc/selinux/config</span><br><span class=\"line\">sudo setenforce 0</span><br><span class=\"line\">sudo systemctl stop firewalld </span><br><span class=\"line\">sudo systemctl disable firewalld</span><br></pre></td></tr></table></figure>\n<h2 id=\"3、集群搭建\"><a href=\"#3、集群搭建\" class=\"headerlink\" title=\"3、集群搭建\"></a>3、集群搭建</h2><h3 id=\"3-1-搭建Mon集群-使用admin账户\"><a href=\"#3-1-搭建Mon集群-使用admin账户\" class=\"headerlink\" title=\"3.1 搭建Mon集群 (使用admin账户)\"></a>3.1 搭建Mon集群 (使用admin账户)</h3><p><strong>创建配置文件</strong></p>\n<p>在<strong>每台节点机器</strong>上创建配置文件<code>/etc/ceph/ceph.conf</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">fsid = 932XXXXX-fba7-XXXX-9526-a858c613f468</span><br><span class=\"line\">mon initial members = e15p13447.ew9</span><br><span class=\"line\">mon host = 192.168.226.20,192.168.226.22,192.168.226.96</span><br><span class=\"line\">rbd default features = 1</span><br><span class=\"line\">auth_cluster_required = none</span><br><span class=\"line\">auth_service_required = none</span><br><span class=\"line\">auth_client_required = none</span><br><span class=\"line\">public network = 192.168.226.0/24</span><br><span class=\"line\">cluster network = 192.168.226.0/24</span><br><span class=\"line\">osd journal size = 1024</span><br><span class=\"line\">osd pool default size = 2</span><br><span class=\"line\">osd pool default min size = 1</span><br><span class=\"line\">osd pool default pg num = 128</span><br><span class=\"line\">osd pool default pgp num = 128</span><br><span class=\"line\">osd crush chooseleaf type = 1</span><br><span class=\"line\">mon_max_pg_per_osd = 200</span><br><span class=\"line\"></span><br><span class=\"line\">[mds.ceph-1]</span><br><span class=\"line\">host = ceph-1</span><br><span class=\"line\">[mds.ceph-2]</span><br><span class=\"line\">host = ceph-2</span><br><span class=\"line\">[mds.ceph-3]</span><br><span class=\"line\">host = ceph-3</span><br><span class=\"line\"></span><br><span class=\"line\">[mon]</span><br><span class=\"line\">mon allow pool delete = true</span><br></pre></td></tr></table></figure>\n<p>其中 <code>fsid</code> 是为集群分配的一个 uuid, 初始化 mon 节点其实只需要这一个配置就够了。<br><code>mon host</code> 配置 ceph 命令行工具访问操作 ceph 集群时查找 mon 节点入口。<br>ceph 集群可包含多个 mon 节点实现高可用容灾, 避免单点故障。<br><code>rbd default features = 1</code> 配置 rbd 客户端创建磁盘时禁用一些需要高版本内核才能支持的特性。</p>\n<h4 id=\"3-1-2-主mon节点-（192-168-226-20）\"><a href=\"#3-1-2-主mon节点-（192-168-226-20）\" class=\"headerlink\" title=\"3.1.2 主mon节点 （192.168.226.20）\"></a>3.1.2 主mon节点 （192.168.226.20）</h4><p>1、为此集群创建密钥环、并生成Monitor密钥 (3台机器一样)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ceph-authtool --create-keyring /tmp/ceph.mon.keyring --gen-key -n mon. --cap mon 'allow *'</span><br></pre></td></tr></table></figure>\n<p>2、生成管理员密钥环，生成 <code>client.admin</code> 用户并加入密钥环 (3台机器一样)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ceph-authtool --create-keyring /etc/ceph/ceph.client.admin.keyring --gen-key -n client.admin --set-uid=0 --cap mon 'allow *' --cap osd 'allow *' --cap mds 'allow *' --cap mgr 'allow *'</span><br></pre></td></tr></table></figure>\n<p>3、把 <code>client.admin</code> 密钥加入 <code>ceph.mon.keyring</code>  (3台机器一样)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ceph-authtool /tmp/ceph.mon.keyring --import-keyring /etc/ceph/ceph.client.admin.keyring</span><br></pre></td></tr></table></figure>\n<p>4、用规划好的主机名、对应 IP 地址、和 FSID 生成一个Monitor Map，并保存为 <code>/tmp/monmap</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host_name=`hostname`</span><br><span class=\"line\">sudo monmaptool --create --add $host_name 192.168.226.20  --fsid 932XXXXX-fba7-XXXX-9526-a858c613f468 /tmp/monmap --clobber</span><br></pre></td></tr></table></figure>\n<p>5、在Monitor主机上分别创建数据目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host_name=`hostname`</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">在admin账户下</span></span><br><span class=\"line\">sudo mkdir /var/lib/ceph/mon/ceph-$host_name/</span><br></pre></td></tr></table></figure>\n<p>6、用Monitor Map和密钥环组装守护进程所需的初始数据</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ceph-mon --mkfs -i $host_name --monmap /tmp/monmap --keyring /tmp/ceph.mon.keyring</span><br></pre></td></tr></table></figure>\n<p>7、建一个空文件 <code>done</code> ，表示监视器已创建、可以启动了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo touch /var/lib/ceph/mon/ceph-$host_name/done</span><br></pre></td></tr></table></figure>\n<p>8、启动Monitor</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">sudo ceph-mon -f --cluster ceph --id <span class=\"variable\">$host_name</span> &amp;</span></span><br><span class=\"line\">sudo cp /usr/lib/systemd/system/ceph-mon@.service /usr/lib/systemd/system/ceph-mon@$host_name.service</span><br><span class=\"line\">sudo systemctl start ceph-mon@$host_name</span><br><span class=\"line\">sudo systemctl enable ceph-mon@$host_name</span><br></pre></td></tr></table></figure>\n<p>9、确认下集群在运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ceph -s</span><br></pre></td></tr></table></figure>\n<p>事例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster:</span><br><span class=\"line\">  id:     932XXXXX-fba7-XXXX-9526-a858c613f468</span><br><span class=\"line\">  health: HEALTH_OK</span><br><span class=\"line\"> </span><br><span class=\"line\">services:</span><br><span class=\"line\">  mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3</span><br><span class=\"line\">  mgr: no daemons active</span><br><span class=\"line\">  osd: 0 osds: 0 up, 0 in</span><br><span class=\"line\"> </span><br><span class=\"line\">data:</span><br><span class=\"line\">  pools:   0 pools, 0 pgs</span><br><span class=\"line\">  objects: 0 objects, 0B</span><br><span class=\"line\">  usage:   0B used, 0B / 0B avail</span><br><span class=\"line\">  pgs:</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-2-从mon节点-192-168-226-22-amp-192-168-226-96\"><a href=\"#3-1-2-从mon节点-192-168-226-22-amp-192-168-226-96\" class=\"headerlink\" title=\"3.1.2 从mon节点 (192.168.226.22 &amp; 192.168.226.96)\"></a>3.1.2 从mon节点 (192.168.226.22 &amp; 192.168.226.96)</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host_name=`hostname`</span><br><span class=\"line\">sudo ceph mon getmap -o /tmp/monmap</span><br><span class=\"line\">sudo rm -rf /var/lib/ceph/mon/ceph-$host_name</span><br><span class=\"line\">sudo ceph-mon -i $host_name --mkfs --monmap /tmp/monmap</span><br><span class=\"line\">sudo chown -R ceph:ceph /var/lib/ceph/mon/ceph-$host_name/</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">nohup ceph-mon -f --cluster ceph --id <span class=\"variable\">$host_name</span> --setuser ceph --setgroup ceph &amp;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph-mon -f --cluster ceph --id <span class=\"variable\">$host_name</span> &amp;</span></span><br><span class=\"line\">sudo cp /usr/lib/systemd/system/ceph-mon@.service /usr/lib/systemd/system/ceph-mon@$host_name.service</span><br><span class=\"line\">sudo systemctl start ceph-mon@$host_name</span><br><span class=\"line\">sudo systemctl enable ceph-mon@$host_name</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-创建ceph-mgr\"><a href=\"#3-2-创建ceph-mgr\" class=\"headerlink\" title=\"3.2 创建ceph-mgr\"></a>3.2 创建ceph-mgr</h3><h4 id=\"3-2-1-创建用户-openstack-用于-MGR-监控\"><a href=\"#3-2-1-创建用户-openstack-用于-MGR-监控\" class=\"headerlink\" title=\"3.2.1 创建用户 openstack 用于 MGR 监控\"></a>3.2.1 创建用户 openstack 用于 MGR 监控</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ceph auth get-or-create mgr.openstack mon 'allow *' osd 'allow *' mds 'allow *'</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[mgr.openstack]</span><br><span class=\"line\">        key = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxugvXkLfgauLA==</span><br></pre></td></tr></table></figure>\n<p>需要将之前创建的用户密码存放至对应位置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /var/lib/ceph/mgr/ceph-openstack</span><br><span class=\"line\">ceph auth get mgr.openstack -o  /var/lib/ceph/mgr/ceph-openstack/keyring</span><br><span class=\"line\">exported keyring for mgr.openstack</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-2-启动mgr\"><a href=\"#3-2-2-启动mgr\" class=\"headerlink\" title=\"3.2.2 启动mgr\"></a>3.2.2 启动mgr</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ceph-mgr -i openstack</span><br></pre></td></tr></table></figure>\n<p>监控状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">ceph -s</span></span><br><span class=\"line\">  cluster:</span><br><span class=\"line\">    id:     932e88a6-fba7-45a9-9526-a858c613f468</span><br><span class=\"line\">    health: HEALTH_OK</span><br><span class=\"line\"> </span><br><span class=\"line\">  services:</span><br><span class=\"line\">    mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3</span><br><span class=\"line\">    mgr: openstack(active)</span><br><span class=\"line\">    mds: cephfs-1/1/1 up  &#123;0=2=up:active&#125;, 2 up:standby</span><br><span class=\"line\">    osd: 3 osds: 3 up, 3 in</span><br><span class=\"line\"> </span><br><span class=\"line\">  data:</span><br><span class=\"line\">    pools:   2 pools, 256 pgs</span><br><span class=\"line\">    objects: 21 objects, 3.04KiB</span><br><span class=\"line\">    usage:   3.32GiB used, 1.17TiB / 1.17TiB avail</span><br><span class=\"line\">    pgs:     256 active+clean</span><br></pre></td></tr></table></figure>\n<p>当 mgr 服务被激活之后, service 中 mgr 会显示 mgr-$name(active)<br>data 部分信息将变得可用</p>\n<h3 id=\"3-3-手动搭建osd集群-三台机器上做相同的操作，注意osd-id的变化\"><a href=\"#3-3-手动搭建osd集群-三台机器上做相同的操作，注意osd-id的变化\" class=\"headerlink\" title=\"3.3 手动搭建osd集群(三台机器上做相同的操作，注意osd_id的变化)\"></a>3.3 手动搭建osd集群(三台机器上做相同的操作，注意osd_id的变化)</h3><p>添加一个新osd，<code>id</code>可以省略，ceph会自动使用最小可用整数，第一个osd从0开始</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph osd create &#123;id&#125;</span></span><br><span class=\"line\">ceph osd create</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-1-初始化osd目录\"><a href=\"#3-3-1-初始化osd目录\" class=\"headerlink\" title=\"3.3.1 初始化osd目录\"></a>3.3.1 初始化osd目录</h4><p>创建osd.0目录，目录名格式<code>{cluster-name}-{id}</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">mkdir /var/lib/ceph/osd/&#123;cluster-name&#125;-&#123;id&#125;</span></span><br><span class=\"line\">sudo mkdir /var/lib/ceph/osd/ceph-0</span><br></pre></td></tr></table></figure>\n<p>挂载osd.0的数据盘/dev/sdb2</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkfs.xfs /dev/sdb2</span><br><span class=\"line\">sudo mount /dev/sdb2 /var/lib/ceph/osd/ceph-0</span><br></pre></td></tr></table></figure>\n<p>初始化osd数据目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo ceph-osd -i &#123;id&#125; --mkfs --mkkey</span></span><br><span class=\"line\">sudo ceph-osd -i 0 --mkfs --mkkey</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">--mkkey要求osd数据目录为空</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">这会创建osd.0的keyring /var/lib/ceph/osd/ceph-0/keyring</span></span><br></pre></td></tr></table></figure>\n<p>初始化后，默认使用普通文件/var/lib/ceph/osd/ceph-3/journal作为osd.0的journal分区，普通文件作为journal分区性能不高，若只是测试环境，可以跳过更改journal分区这一步骤</p>\n<h4 id=\"3-3-2-创建journal\"><a href=\"#3-3-2-创建journal\" class=\"headerlink\" title=\"3.3.2 创建journal\"></a>3.3.2 创建journal</h4><p>生成journal分区，一般选ssd盘作为journal分区，这里使用ssd的/dev/sdb1分区作为journal</p>\n<p>使用fdisk工分出磁盘/dev/sdb1,</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">清除磁盘所有分区(重新添加时需要)</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">sgdisk --zap-all --clear --mbrtogpt /dev/sdb</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">生成分区/dev/sdb1的uuid</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">uuidgen</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">b3897364-8807-48eb-9905-e2c8400d0cd4</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">创建分区</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">1:0:+100G 表示创建第一个分区，100G大小</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">sudo sgdisk --new=1:0:+100G --change-name=1:<span class=\"string\">'ceph journal'</span> --partition-guid=1:b3897364-8807-48eb-9905-e2c8400d0cd4 --typecode=1:b3897364-8807-48eb-9905-e2c8400d0cd4 --mbrtogpt -- /dev/vdf</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">格式化</span></span><br><span class=\"line\">sudo mkfs.xfs /dev/sdb1</span><br><span class=\"line\">sudo rm -f /var/lib/ceph/osd/ceph-4/journal </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">查看分区对应的partuuid， 找出/dev/sdb1对应的partuuid</span></span><br><span class=\"line\">sudo blkid</span><br><span class=\"line\">sudo ln -s /dev/disk/by-partuuid/b3897364-8807-48eb-9905-e2c8400d0cd4 /var/lib/ceph/osd/ceph-0/journal</span><br><span class=\"line\"></span><br><span class=\"line\">sudo chown ceph:ceph -R /var/lib/ceph/osd/ceph-0</span><br><span class=\"line\">sudo chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">初始化新的journal</span></span><br><span class=\"line\">sudo ceph-osd --mkjournal -i 0</span><br><span class=\"line\">sudo chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-3-注册osd-id-，id为osd编号，默认从0开始\"><a href=\"#3-3-3-注册osd-id-，id为osd编号，默认从0开始\" class=\"headerlink\" title=\"3.3.3 注册osd.{id}，id为osd编号，默认从0开始\"></a>3.3.3 注册osd.{id}，id为osd编号，默认从0开始</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo ceph auth add osd.&#123;id&#125; osd <span class=\"string\">'allow *'</span> mon <span class=\"string\">'allow profile osd'</span> -i /var/lib/ceph/osd/ceph-&#123;id&#125;/keyring</span></span><br><span class=\"line\">sudo ceph auth add osd.0 osd 'allow *' mon 'allow profile osd' -i /var/lib/ceph/osd/ceph-0/keyring</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph auth list 中出现osd.0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-4-加入crush-map\"><a href=\"#3-3-4-加入crush-map\" class=\"headerlink\" title=\"3.3.4 加入crush map\"></a>3.3.4 加入crush map</h4><p>这是m1上新创建的第一个osd，CRUSH map中还没有m1节点，因此首先要把m1节点加入CRUSH map，同理，m2/m3节点也需要加入CRUSH map</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph osd crush add-bucket &#123;hostname&#125; host</span></span><br><span class=\"line\">sudo ceph osd crush add-bucket `hostname` host</span><br></pre></td></tr></table></figure>\n<p>然后把三个节点移动到默认的root <code>default</code>下面</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ceph osd crush move `hostname` root=default</span><br></pre></td></tr></table></figure>\n<p>添加osd.0到CRUSH map中的m1节点下面，加入后，osd.0就能够接收数据</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph osd crush add osd.&#123;id&#125; 0.4 root=sata rack=sata-rack01 host=sata-node5</span></span><br><span class=\"line\">sudo ceph osd crush add osd.4 1.7 root=default host=`hostname`</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">0.4为此osd在CRUSH map中的权重值，它表示数据落在此osd上的比重，是一个相对值，一般按照1T磁盘比重值为1来计算，这里的osd数据盘1.7，所以值为1.7</span></span><br></pre></td></tr></table></figure>\n<p>此时osd.0状态是<code>down</code>且<code>in</code>，<code>in</code>表示此osd位于CRUSH map，已经准备好接受数据，<code>down</code>表示osd进程运行异常，因为我们还没有启动osd.0进程</p>\n<h4 id=\"3-3-5-启动ceph-osd进程\"><a href=\"#3-3-5-启动ceph-osd进程\" class=\"headerlink\" title=\"3.3.5 启动ceph-osd进程\"></a>3.3.5 启动ceph-osd进程</h4><p>需要向systemctl传递osd的<code>id</code>以启动指定的osd进程，如下，我们准备启动osd.0进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">systemctl start ceph-osd@&#123;id&#125;  id表示osd编号，从数字0开始</span></span><br><span class=\"line\">sudo cp /usr/lib/systemd/system/ceph-osd@.service /usr/lib/systemd/system/ceph-osd@0.service</span><br><span class=\"line\">sudo systemctl start ceph-osd@0</span><br><span class=\"line\">sudo systemctl enable ceph-osd@0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">sudo ceph-osd -i 0</span></span><br></pre></td></tr></table></figure>\n<p>上面就是添加osd.0的步骤，然后可以接着在其他<code>hostname</code>节点上添加osd.{1,2}，添加了这3个osd后，可以查看集群状态 ceph -s。</p>\n<h3 id=\"3-4-搭建MDS\"><a href=\"#3-4-搭建MDS\" class=\"headerlink\" title=\"3.4 搭建MDS\"></a>3.4 搭建MDS</h3><p>创建目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir /var/lib/ceph/mds/ceph-`hostname`</span><br><span class=\"line\">sudo chown ceph:ceph -R /var/lib/ceph/mds/ceph-`hostname`</span><br></pre></td></tr></table></figure>\n<p>在ceph.conf中添加如下信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mds.&#123;id&#125;]</span><br><span class=\"line\">host = &#123;id&#125;</span><br><span class=\"line\">例如：</span><br><span class=\"line\">[mds.0]</span><br><span class=\"line\">host = 0</span><br></pre></td></tr></table></figure>\n<p>启动mds</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph-mds --cluster &#123;cluster-name&#125; -i &#123;id&#125; -m &#123;mon-hostname&#125;:&#123;mon-port&#125; [-f]</span></span><br><span class=\"line\">sudo cp /usr/lib/systemd/system/ceph-mds@.service /usr/lib/systemd/system/ceph-mds@`hostname`.service </span><br><span class=\"line\">sudo systemctl start ceph-mds@`hostname`</span><br><span class=\"line\">sudo systemctl enable ceph-mds@`hostname`</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph-mds --cluster ceph -i 0 -m e15p13447.ew9:6789</span></span><br></pre></td></tr></table></figure>\n<p>查看mds状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ceph mds stat</span><br><span class=\"line\">cephfs-1/1/1 up  &#123;0=1=up:active&#125;, 2 up:standby</span><br></pre></td></tr></table></figure>\n<p>至此ceph集群搭建完成。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1、机器选择\"><a href=\"#1、机器选择\" class=\"headerlink\" title=\"1、机器选择\"></a>1、机器选择</h2><h3 id=\"1-1-系统要求\"><a href=\"#1-1-系统要求\" class=\"headerlink\" title=\"1.1 系统要求\"></a>1.1 系统要求</h3><p>ceph 最新 LTS 版本 (luminous) 推荐 linux 内核版本 <code>4.1.4</code> 及以上, 最低版本要求 <code>3.10.*</code>。</p>\n<h3 id=\"1-2-服务器\"><a href=\"#1-2-服务器\" class=\"headerlink\" title=\"1.2 服务器\"></a>1.2 服务器</h3><p>这里选择三台服务器来部署ceph集群，一台Mon+五台OSD</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>节点</th>\n<th>服务</th>\n<th>cluster network</th>\n<th>public network</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>192.168.226.20</td>\n<td>osd.1,mon.node2</td>\n<td>192.168.226.0/24</td>\n<td>192.168.226.0/24</td>\n</tr>\n<tr>\n<td>192.168.226.21</td>\n<td>osd.4</td>\n<td>192.168.226.0/24</td>\n<td>192.168.226.0/24</td>\n</tr>\n<tr>\n<td>192.168.226.22</td>\n<td>osd.2, mon.node1</td>\n<td>192.168.226.0/24</td>\n<td>192.168.226.0/24</td>\n</tr>\n<tr>\n<td>192.168.226.96</td>\n<td>osd.3,mon.node3</td>\n<td>192.168.226.0/24</td>\n<td>192.168.226.0/24</td>\n</tr>\n<tr>\n<td>192.168.226.106</td>\n<td>osd.0</td>\n<td>192.168.226.0/24</td>\n<td>192.168.226.0/24</td>\n</tr>\n</tbody>\n</table>\n<p>每个节点只能使用1块磁盘部署osd。所以，集群共有5个<code>osd</code>进程，3个<code>monitor</code>进程。</p>\n<p>cluster network 是处理osd间的数据复制，数据重平衡，osd进程心跳检测的网络，其不对外提供服务，只在各个osd节点间通信，本文使用eth1网卡作为cluster network，三个节点网卡eth1桥接到同一个网桥br1上</p>\n<h2 id=\"2、环境配置\"><a href=\"#2、环境配置\" class=\"headerlink\" title=\"2、环境配置\"></a>2、环境配置</h2><p>配置每个节点的host文件，在 <code>/etc/hosts</code>文件中添加如下内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">192.168.226.20 ceph-1</span><br><span class=\"line\">192.168.226.22 ceph-2</span><br><span class=\"line\">192.168.226.96 ceph-3</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-ceph节点安装\"><a href=\"#2-2-ceph节点安装\" class=\"headerlink\" title=\"2.2 ceph节点安装\"></a>2.2 ceph节点安装</h3><p>你的管理节点必须能够通过 SSH 无密码地访问各 Ceph 节点。如果 <code>ceph-deploy</code> 以某个普通用户登录，那么这个用户必须有无密码使用 <code>sudo</code> 的权限。</p>\n<h4 id=\"2-2-1-安装-NTP\"><a href=\"#2-2-1-安装-NTP\" class=\"headerlink\" title=\"2.2.1 安装 NTP\"></a>2.2.1 安装 NTP</h4><p>我们建议在所有 Ceph 节点上安装 NTP 服务（特别是 Ceph Monitor 节点），以免因时钟漂移导致故障，详情见<a href=\"http://docs.ceph.org.cn/rados/configuration/mon-config-ref#clock\" target=\"_blank\" rel=\"noopener\">时钟</a>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install ntp ntpdate ntp-doc</span><br></pre></td></tr></table></figure>\n<p>确保在各 Ceph 节点上启动了 NTP 服务，并且要使用同一个 NTP 服务器，详情见 <a href=\"http://www.ntp.org/\" target=\"_blank\" rel=\"noopener\">NTP</a> 。</p>\n<h4 id=\"2-2-2-安装-SSH-服务器\"><a href=\"#2-2-2-安装-SSH-服务器\" class=\"headerlink\" title=\"2.2.2 安装 SSH 服务器\"></a>2.2.2 安装 SSH 服务器</h4><p>在<strong>所有 Ceph</strong> 节点上执行如下步骤：</p>\n<ol>\n<li><p>在各 Ceph 节点安装 SSH 服务器（如果还没有）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install openssh-server</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确保<strong>所有</strong> Ceph 节点上的 SSH 服务器都在运行。</p>\n</li>\n</ol>\n<h4 id=\"2-2-3-安装ceph\"><a href=\"#2-2-3-安装ceph\" class=\"headerlink\" title=\"2.2.3 安装ceph\"></a>2.2.3 安装ceph</h4><p>由于蚂蚁内部物理机不能访问外网，使用以下步骤安装ceph。</p>\n<p>在<strong>所有Ceph</strong>节点上执行如下步骤：</p>\n<p>下载ceph所有的依赖rpm，并解压缩</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo wget http://qianli-lzh.oss-cn-hangzhou-zmf.aliyuncs.com/bill_inference_public%2Fceph.tar</span><br><span class=\"line\">sudo tar -xvf bill_inference_public%2Fceph.tar</span><br></pre></td></tr></table></figure>\n<p>手动安装所有的rpm</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rpm -ivh --force --nodeps ceph/*.rpm</span><br></pre></td></tr></table></figure>\n<p>验证ceph是否正确安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ceph -v</span><br><span class=\"line\">ceph version 12.2.8 (ae699615bac534ea496ee965ac6192cb7e0e07c0) luminous (stable)</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-4-关闭防火墙\"><a href=\"#2-2-4-关闭防火墙\" class=\"headerlink\" title=\"2.2.4 关闭防火墙\"></a>2.2.4 关闭防火墙</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo sed -i 's/SELINUX=.*/SELINUX=disabled/' /etc/selinux/config</span><br><span class=\"line\">sudo setenforce 0</span><br><span class=\"line\">sudo systemctl stop firewalld </span><br><span class=\"line\">sudo systemctl disable firewalld</span><br></pre></td></tr></table></figure>\n<h2 id=\"3、集群搭建\"><a href=\"#3、集群搭建\" class=\"headerlink\" title=\"3、集群搭建\"></a>3、集群搭建</h2><h3 id=\"3-1-搭建Mon集群-使用admin账户\"><a href=\"#3-1-搭建Mon集群-使用admin账户\" class=\"headerlink\" title=\"3.1 搭建Mon集群 (使用admin账户)\"></a>3.1 搭建Mon集群 (使用admin账户)</h3><p><strong>创建配置文件</strong></p>\n<p>在<strong>每台节点机器</strong>上创建配置文件<code>/etc/ceph/ceph.conf</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">fsid = 932XXXXX-fba7-XXXX-9526-a858c613f468</span><br><span class=\"line\">mon initial members = e15p13447.ew9</span><br><span class=\"line\">mon host = 192.168.226.20,192.168.226.22,192.168.226.96</span><br><span class=\"line\">rbd default features = 1</span><br><span class=\"line\">auth_cluster_required = none</span><br><span class=\"line\">auth_service_required = none</span><br><span class=\"line\">auth_client_required = none</span><br><span class=\"line\">public network = 192.168.226.0/24</span><br><span class=\"line\">cluster network = 192.168.226.0/24</span><br><span class=\"line\">osd journal size = 1024</span><br><span class=\"line\">osd pool default size = 2</span><br><span class=\"line\">osd pool default min size = 1</span><br><span class=\"line\">osd pool default pg num = 128</span><br><span class=\"line\">osd pool default pgp num = 128</span><br><span class=\"line\">osd crush chooseleaf type = 1</span><br><span class=\"line\">mon_max_pg_per_osd = 200</span><br><span class=\"line\"></span><br><span class=\"line\">[mds.ceph-1]</span><br><span class=\"line\">host = ceph-1</span><br><span class=\"line\">[mds.ceph-2]</span><br><span class=\"line\">host = ceph-2</span><br><span class=\"line\">[mds.ceph-3]</span><br><span class=\"line\">host = ceph-3</span><br><span class=\"line\"></span><br><span class=\"line\">[mon]</span><br><span class=\"line\">mon allow pool delete = true</span><br></pre></td></tr></table></figure>\n<p>其中 <code>fsid</code> 是为集群分配的一个 uuid, 初始化 mon 节点其实只需要这一个配置就够了。<br><code>mon host</code> 配置 ceph 命令行工具访问操作 ceph 集群时查找 mon 节点入口。<br>ceph 集群可包含多个 mon 节点实现高可用容灾, 避免单点故障。<br><code>rbd default features = 1</code> 配置 rbd 客户端创建磁盘时禁用一些需要高版本内核才能支持的特性。</p>\n<h4 id=\"3-1-2-主mon节点-（192-168-226-20）\"><a href=\"#3-1-2-主mon节点-（192-168-226-20）\" class=\"headerlink\" title=\"3.1.2 主mon节点 （192.168.226.20）\"></a>3.1.2 主mon节点 （192.168.226.20）</h4><p>1、为此集群创建密钥环、并生成Monitor密钥 (3台机器一样)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ceph-authtool --create-keyring /tmp/ceph.mon.keyring --gen-key -n mon. --cap mon 'allow *'</span><br></pre></td></tr></table></figure>\n<p>2、生成管理员密钥环，生成 <code>client.admin</code> 用户并加入密钥环 (3台机器一样)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ceph-authtool --create-keyring /etc/ceph/ceph.client.admin.keyring --gen-key -n client.admin --set-uid=0 --cap mon 'allow *' --cap osd 'allow *' --cap mds 'allow *' --cap mgr 'allow *'</span><br></pre></td></tr></table></figure>\n<p>3、把 <code>client.admin</code> 密钥加入 <code>ceph.mon.keyring</code>  (3台机器一样)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ceph-authtool /tmp/ceph.mon.keyring --import-keyring /etc/ceph/ceph.client.admin.keyring</span><br></pre></td></tr></table></figure>\n<p>4、用规划好的主机名、对应 IP 地址、和 FSID 生成一个Monitor Map，并保存为 <code>/tmp/monmap</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host_name=`hostname`</span><br><span class=\"line\">sudo monmaptool --create --add $host_name 192.168.226.20  --fsid 932XXXXX-fba7-XXXX-9526-a858c613f468 /tmp/monmap --clobber</span><br></pre></td></tr></table></figure>\n<p>5、在Monitor主机上分别创建数据目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host_name=`hostname`</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">在admin账户下</span></span><br><span class=\"line\">sudo mkdir /var/lib/ceph/mon/ceph-$host_name/</span><br></pre></td></tr></table></figure>\n<p>6、用Monitor Map和密钥环组装守护进程所需的初始数据</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ceph-mon --mkfs -i $host_name --monmap /tmp/monmap --keyring /tmp/ceph.mon.keyring</span><br></pre></td></tr></table></figure>\n<p>7、建一个空文件 <code>done</code> ，表示监视器已创建、可以启动了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo touch /var/lib/ceph/mon/ceph-$host_name/done</span><br></pre></td></tr></table></figure>\n<p>8、启动Monitor</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">sudo ceph-mon -f --cluster ceph --id <span class=\"variable\">$host_name</span> &amp;</span></span><br><span class=\"line\">sudo cp /usr/lib/systemd/system/ceph-mon@.service /usr/lib/systemd/system/ceph-mon@$host_name.service</span><br><span class=\"line\">sudo systemctl start ceph-mon@$host_name</span><br><span class=\"line\">sudo systemctl enable ceph-mon@$host_name</span><br></pre></td></tr></table></figure>\n<p>9、确认下集群在运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ceph -s</span><br></pre></td></tr></table></figure>\n<p>事例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster:</span><br><span class=\"line\">  id:     932XXXXX-fba7-XXXX-9526-a858c613f468</span><br><span class=\"line\">  health: HEALTH_OK</span><br><span class=\"line\"> </span><br><span class=\"line\">services:</span><br><span class=\"line\">  mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3</span><br><span class=\"line\">  mgr: no daemons active</span><br><span class=\"line\">  osd: 0 osds: 0 up, 0 in</span><br><span class=\"line\"> </span><br><span class=\"line\">data:</span><br><span class=\"line\">  pools:   0 pools, 0 pgs</span><br><span class=\"line\">  objects: 0 objects, 0B</span><br><span class=\"line\">  usage:   0B used, 0B / 0B avail</span><br><span class=\"line\">  pgs:</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-2-从mon节点-192-168-226-22-amp-192-168-226-96\"><a href=\"#3-1-2-从mon节点-192-168-226-22-amp-192-168-226-96\" class=\"headerlink\" title=\"3.1.2 从mon节点 (192.168.226.22 &amp; 192.168.226.96)\"></a>3.1.2 从mon节点 (192.168.226.22 &amp; 192.168.226.96)</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host_name=`hostname`</span><br><span class=\"line\">sudo ceph mon getmap -o /tmp/monmap</span><br><span class=\"line\">sudo rm -rf /var/lib/ceph/mon/ceph-$host_name</span><br><span class=\"line\">sudo ceph-mon -i $host_name --mkfs --monmap /tmp/monmap</span><br><span class=\"line\">sudo chown -R ceph:ceph /var/lib/ceph/mon/ceph-$host_name/</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">nohup ceph-mon -f --cluster ceph --id <span class=\"variable\">$host_name</span> --setuser ceph --setgroup ceph &amp;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph-mon -f --cluster ceph --id <span class=\"variable\">$host_name</span> &amp;</span></span><br><span class=\"line\">sudo cp /usr/lib/systemd/system/ceph-mon@.service /usr/lib/systemd/system/ceph-mon@$host_name.service</span><br><span class=\"line\">sudo systemctl start ceph-mon@$host_name</span><br><span class=\"line\">sudo systemctl enable ceph-mon@$host_name</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-创建ceph-mgr\"><a href=\"#3-2-创建ceph-mgr\" class=\"headerlink\" title=\"3.2 创建ceph-mgr\"></a>3.2 创建ceph-mgr</h3><h4 id=\"3-2-1-创建用户-openstack-用于-MGR-监控\"><a href=\"#3-2-1-创建用户-openstack-用于-MGR-监控\" class=\"headerlink\" title=\"3.2.1 创建用户 openstack 用于 MGR 监控\"></a>3.2.1 创建用户 openstack 用于 MGR 监控</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ceph auth get-or-create mgr.openstack mon 'allow *' osd 'allow *' mds 'allow *'</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[mgr.openstack]</span><br><span class=\"line\">        key = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxugvXkLfgauLA==</span><br></pre></td></tr></table></figure>\n<p>需要将之前创建的用户密码存放至对应位置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /var/lib/ceph/mgr/ceph-openstack</span><br><span class=\"line\">ceph auth get mgr.openstack -o  /var/lib/ceph/mgr/ceph-openstack/keyring</span><br><span class=\"line\">exported keyring for mgr.openstack</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-2-启动mgr\"><a href=\"#3-2-2-启动mgr\" class=\"headerlink\" title=\"3.2.2 启动mgr\"></a>3.2.2 启动mgr</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ceph-mgr -i openstack</span><br></pre></td></tr></table></figure>\n<p>监控状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">ceph -s</span></span><br><span class=\"line\">  cluster:</span><br><span class=\"line\">    id:     932e88a6-fba7-45a9-9526-a858c613f468</span><br><span class=\"line\">    health: HEALTH_OK</span><br><span class=\"line\"> </span><br><span class=\"line\">  services:</span><br><span class=\"line\">    mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3</span><br><span class=\"line\">    mgr: openstack(active)</span><br><span class=\"line\">    mds: cephfs-1/1/1 up  &#123;0=2=up:active&#125;, 2 up:standby</span><br><span class=\"line\">    osd: 3 osds: 3 up, 3 in</span><br><span class=\"line\"> </span><br><span class=\"line\">  data:</span><br><span class=\"line\">    pools:   2 pools, 256 pgs</span><br><span class=\"line\">    objects: 21 objects, 3.04KiB</span><br><span class=\"line\">    usage:   3.32GiB used, 1.17TiB / 1.17TiB avail</span><br><span class=\"line\">    pgs:     256 active+clean</span><br></pre></td></tr></table></figure>\n<p>当 mgr 服务被激活之后, service 中 mgr 会显示 mgr-$name(active)<br>data 部分信息将变得可用</p>\n<h3 id=\"3-3-手动搭建osd集群-三台机器上做相同的操作，注意osd-id的变化\"><a href=\"#3-3-手动搭建osd集群-三台机器上做相同的操作，注意osd-id的变化\" class=\"headerlink\" title=\"3.3 手动搭建osd集群(三台机器上做相同的操作，注意osd_id的变化)\"></a>3.3 手动搭建osd集群(三台机器上做相同的操作，注意osd_id的变化)</h3><p>添加一个新osd，<code>id</code>可以省略，ceph会自动使用最小可用整数，第一个osd从0开始</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph osd create &#123;id&#125;</span></span><br><span class=\"line\">ceph osd create</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-1-初始化osd目录\"><a href=\"#3-3-1-初始化osd目录\" class=\"headerlink\" title=\"3.3.1 初始化osd目录\"></a>3.3.1 初始化osd目录</h4><p>创建osd.0目录，目录名格式<code>{cluster-name}-{id}</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">mkdir /var/lib/ceph/osd/&#123;cluster-name&#125;-&#123;id&#125;</span></span><br><span class=\"line\">sudo mkdir /var/lib/ceph/osd/ceph-0</span><br></pre></td></tr></table></figure>\n<p>挂载osd.0的数据盘/dev/sdb2</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkfs.xfs /dev/sdb2</span><br><span class=\"line\">sudo mount /dev/sdb2 /var/lib/ceph/osd/ceph-0</span><br></pre></td></tr></table></figure>\n<p>初始化osd数据目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo ceph-osd -i &#123;id&#125; --mkfs --mkkey</span></span><br><span class=\"line\">sudo ceph-osd -i 0 --mkfs --mkkey</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">--mkkey要求osd数据目录为空</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">这会创建osd.0的keyring /var/lib/ceph/osd/ceph-0/keyring</span></span><br></pre></td></tr></table></figure>\n<p>初始化后，默认使用普通文件/var/lib/ceph/osd/ceph-3/journal作为osd.0的journal分区，普通文件作为journal分区性能不高，若只是测试环境，可以跳过更改journal分区这一步骤</p>\n<h4 id=\"3-3-2-创建journal\"><a href=\"#3-3-2-创建journal\" class=\"headerlink\" title=\"3.3.2 创建journal\"></a>3.3.2 创建journal</h4><p>生成journal分区，一般选ssd盘作为journal分区，这里使用ssd的/dev/sdb1分区作为journal</p>\n<p>使用fdisk工分出磁盘/dev/sdb1,</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">清除磁盘所有分区(重新添加时需要)</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">sgdisk --zap-all --clear --mbrtogpt /dev/sdb</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">生成分区/dev/sdb1的uuid</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">uuidgen</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">b3897364-8807-48eb-9905-e2c8400d0cd4</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">创建分区</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">1:0:+100G 表示创建第一个分区，100G大小</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">sudo sgdisk --new=1:0:+100G --change-name=1:<span class=\"string\">'ceph journal'</span> --partition-guid=1:b3897364-8807-48eb-9905-e2c8400d0cd4 --typecode=1:b3897364-8807-48eb-9905-e2c8400d0cd4 --mbrtogpt -- /dev/vdf</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">格式化</span></span><br><span class=\"line\">sudo mkfs.xfs /dev/sdb1</span><br><span class=\"line\">sudo rm -f /var/lib/ceph/osd/ceph-4/journal </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">查看分区对应的partuuid， 找出/dev/sdb1对应的partuuid</span></span><br><span class=\"line\">sudo blkid</span><br><span class=\"line\">sudo ln -s /dev/disk/by-partuuid/b3897364-8807-48eb-9905-e2c8400d0cd4 /var/lib/ceph/osd/ceph-0/journal</span><br><span class=\"line\"></span><br><span class=\"line\">sudo chown ceph:ceph -R /var/lib/ceph/osd/ceph-0</span><br><span class=\"line\">sudo chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">初始化新的journal</span></span><br><span class=\"line\">sudo ceph-osd --mkjournal -i 0</span><br><span class=\"line\">sudo chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-3-注册osd-id-，id为osd编号，默认从0开始\"><a href=\"#3-3-3-注册osd-id-，id为osd编号，默认从0开始\" class=\"headerlink\" title=\"3.3.3 注册osd.{id}，id为osd编号，默认从0开始\"></a>3.3.3 注册osd.{id}，id为osd编号，默认从0开始</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sudo ceph auth add osd.&#123;id&#125; osd <span class=\"string\">'allow *'</span> mon <span class=\"string\">'allow profile osd'</span> -i /var/lib/ceph/osd/ceph-&#123;id&#125;/keyring</span></span><br><span class=\"line\">sudo ceph auth add osd.0 osd 'allow *' mon 'allow profile osd' -i /var/lib/ceph/osd/ceph-0/keyring</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph auth list 中出现osd.0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-4-加入crush-map\"><a href=\"#3-3-4-加入crush-map\" class=\"headerlink\" title=\"3.3.4 加入crush map\"></a>3.3.4 加入crush map</h4><p>这是m1上新创建的第一个osd，CRUSH map中还没有m1节点，因此首先要把m1节点加入CRUSH map，同理，m2/m3节点也需要加入CRUSH map</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph osd crush add-bucket &#123;hostname&#125; host</span></span><br><span class=\"line\">sudo ceph osd crush add-bucket `hostname` host</span><br></pre></td></tr></table></figure>\n<p>然后把三个节点移动到默认的root <code>default</code>下面</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ceph osd crush move `hostname` root=default</span><br></pre></td></tr></table></figure>\n<p>添加osd.0到CRUSH map中的m1节点下面，加入后，osd.0就能够接收数据</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph osd crush add osd.&#123;id&#125; 0.4 root=sata rack=sata-rack01 host=sata-node5</span></span><br><span class=\"line\">sudo ceph osd crush add osd.4 1.7 root=default host=`hostname`</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">0.4为此osd在CRUSH map中的权重值，它表示数据落在此osd上的比重，是一个相对值，一般按照1T磁盘比重值为1来计算，这里的osd数据盘1.7，所以值为1.7</span></span><br></pre></td></tr></table></figure>\n<p>此时osd.0状态是<code>down</code>且<code>in</code>，<code>in</code>表示此osd位于CRUSH map，已经准备好接受数据，<code>down</code>表示osd进程运行异常，因为我们还没有启动osd.0进程</p>\n<h4 id=\"3-3-5-启动ceph-osd进程\"><a href=\"#3-3-5-启动ceph-osd进程\" class=\"headerlink\" title=\"3.3.5 启动ceph-osd进程\"></a>3.3.5 启动ceph-osd进程</h4><p>需要向systemctl传递osd的<code>id</code>以启动指定的osd进程，如下，我们准备启动osd.0进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">systemctl start ceph-osd@&#123;id&#125;  id表示osd编号，从数字0开始</span></span><br><span class=\"line\">sudo cp /usr/lib/systemd/system/ceph-osd@.service /usr/lib/systemd/system/ceph-osd@0.service</span><br><span class=\"line\">sudo systemctl start ceph-osd@0</span><br><span class=\"line\">sudo systemctl enable ceph-osd@0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">sudo ceph-osd -i 0</span></span><br></pre></td></tr></table></figure>\n<p>上面就是添加osd.0的步骤，然后可以接着在其他<code>hostname</code>节点上添加osd.{1,2}，添加了这3个osd后，可以查看集群状态 ceph -s。</p>\n<h3 id=\"3-4-搭建MDS\"><a href=\"#3-4-搭建MDS\" class=\"headerlink\" title=\"3.4 搭建MDS\"></a>3.4 搭建MDS</h3><p>创建目录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir /var/lib/ceph/mds/ceph-`hostname`</span><br><span class=\"line\">sudo chown ceph:ceph -R /var/lib/ceph/mds/ceph-`hostname`</span><br></pre></td></tr></table></figure>\n<p>在ceph.conf中添加如下信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mds.&#123;id&#125;]</span><br><span class=\"line\">host = &#123;id&#125;</span><br><span class=\"line\">例如：</span><br><span class=\"line\">[mds.0]</span><br><span class=\"line\">host = 0</span><br></pre></td></tr></table></figure>\n<p>启动mds</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph-mds --cluster &#123;cluster-name&#125; -i &#123;id&#125; -m &#123;mon-hostname&#125;:&#123;mon-port&#125; [-f]</span></span><br><span class=\"line\">sudo cp /usr/lib/systemd/system/ceph-mds@.service /usr/lib/systemd/system/ceph-mds@`hostname`.service </span><br><span class=\"line\">sudo systemctl start ceph-mds@`hostname`</span><br><span class=\"line\">sudo systemctl enable ceph-mds@`hostname`</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">ceph-mds --cluster ceph -i 0 -m e15p13447.ew9:6789</span></span><br></pre></td></tr></table></figure>\n<p>查看mds状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ceph mds stat</span><br><span class=\"line\">cephfs-1/1/1 up  &#123;0=1=up:active&#125;, 2 up:standby</span><br></pre></td></tr></table></figure>\n<p>至此ceph集群搭建完成。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjoitzonr0007teje4czdgibi","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzony000fteje6emy1w0t"},{"post_id":"cjoitzonf0000tejeb2fz3azn","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzoo1000ktejek5y8ruuk"},{"post_id":"cjoitzons0008tejeniqeau1z","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzoo4000ntejenchgmq53"},{"post_id":"cjoitzonv000ctejebjvn4qi2","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzoo5000rtejeefd6tar9"},{"post_id":"cjoitzonk0002tejego15bsh1","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzoo6000tteje8wppuub6"},{"post_id":"cjoitzonw000etejevskqx5rl","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzoo9000xteje680vmuun"},{"post_id":"cjoitzonz000jteje2i094l5w","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzooa0010tejeask98woi"},{"post_id":"cjoitzonp0006tejetrfx7o3v","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzooc0014tejeufm37ytg"},{"post_id":"cjoitzoo2000mtejedoxw2apq","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzood0017tejebm6spls0"},{"post_id":"cjoitzoo4000qtejeqfw34mql","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzoof001btejemofr0pn5"},{"post_id":"cjoitzoo6000stejed7gsxlvt","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzoog001eteje7rafub08"},{"post_id":"cjoitzoo8000wteje61mwsvwc","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzooh001itejeyy9f2d7q"},{"post_id":"cjoitzoo9000zteje70viyxh0","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzooi001ltejephwpj0vo"},{"post_id":"cjoitzoob0013tejebbfa5gcw","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzook001pteje2pmdfkqo"},{"post_id":"cjoitzood0016tejep24oux1h","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzool001stejekm6c8afg"},{"post_id":"cjoitzooe001atejelnlvwhed","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzoon001wtejeu9gjy2wi"},{"post_id":"cjoitzoof001dteje3dqwcnxk","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzooo001ztejegjj4tq0p"},{"post_id":"cjoitzooh001hteje5fwsbwcz","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzoop0023tejeqjtz5d8e"},{"post_id":"cjoitzooi001ktejeyla27kgp","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzooq0025tejeiueltl4y"},{"post_id":"cjoitzooj001otejei9physvq","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzooq0028tejexdb1bp8h"},{"post_id":"cjoitzook001rtejextiyieal","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzoor002atejeq5coxh4r"},{"post_id":"cjoitzoom001vtejeoongrlbg","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzoor002dtejejtr0q562"},{"post_id":"cjoitzoon001yteje5cedm6cb","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzoos002ftejecvjuh7ne"},{"post_id":"cjoitzooo0022tejebl6yyj8i","category_id":"cjoitzonn0004tejenaq8lp48","_id":"cjoitzoos002htejea9hkrjuo"},{"post_id":"cjoitzopj0031tejebboldcqr","category_id":"cjoitzopm0033tejexx10d571","_id":"cjoitzopo0036tejej3p0uoes"}],"PostTag":[{"post_id":"cjoitzonr0007teje4czdgibi","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzonv000btejejwti8ggx"},{"post_id":"cjoitzonf0000tejeb2fz3azn","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzonw000dtejem5zaeqif"},{"post_id":"cjoitzonk0002tejego15bsh1","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzonz000iteje1k5v113u"},{"post_id":"cjoitzonw000etejevskqx5rl","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoo2000ltejeuyktyrz3"},{"post_id":"cjoitzonp0006tejetrfx7o3v","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoo4000ptejekvanjtp9"},{"post_id":"cjoitzoo4000qtejeqfw34mql","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoo8000vtejehznh7063"},{"post_id":"cjoitzoo4000qtejeqfw34mql","tag_id":"cjoitzoo4000oteje2ji9m4bl","_id":"cjoitzoo9000ytejex2wlhcax"},{"post_id":"cjoitzons0008tejeniqeau1z","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoob0012tejeufu1j3xw"},{"post_id":"cjoitzons0008tejeniqeau1z","tag_id":"cjoitzoo4000oteje2ji9m4bl","_id":"cjoitzood0015teje4eiy3tae"},{"post_id":"cjoitzoo6000stejed7gsxlvt","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzooe0019tejepbni9e6q"},{"post_id":"cjoitzonv000ctejebjvn4qi2","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoof001ctejewmfini3j"},{"post_id":"cjoitzonv000ctejebjvn4qi2","tag_id":"cjoitzoo4000oteje2ji9m4bl","_id":"cjoitzooh001gteje25vk1le1"},{"post_id":"cjoitzoob0013tejebbfa5gcw","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzooi001jteje5f3ih5g4"},{"post_id":"cjoitzonz000jteje2i094l5w","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzooj001ntejez3ph4git"},{"post_id":"cjoitzonz000jteje2i094l5w","tag_id":"cjoitzoo4000oteje2ji9m4bl","_id":"cjoitzook001qtejet2fkrp8n"},{"post_id":"cjoitzooe001atejelnlvwhed","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoom001uteje2emkll7j"},{"post_id":"cjoitzoo2000mtejedoxw2apq","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoon001xtejei4o9sxhl"},{"post_id":"cjoitzoo2000mtejedoxw2apq","tag_id":"cjoitzoo4000oteje2ji9m4bl","_id":"cjoitzooo0020teje68luxvx4"},{"post_id":"cjoitzoo8000wteje61mwsvwc","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzooq0024tejefaegb6ca"},{"post_id":"cjoitzoo8000wteje61mwsvwc","tag_id":"cjoitzoog001fteje9koh8yqh","_id":"cjoitzooq0026tejev7qtxkyo"},{"post_id":"cjoitzooi001ktejeyla27kgp","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoor0029tejeb7gjvce3"},{"post_id":"cjoitzoo9000zteje70viyxh0","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoor002btejehhp6s10y"},{"post_id":"cjoitzoo9000zteje70viyxh0","tag_id":"cjoitzoog001fteje9koh8yqh","_id":"cjoitzoor002eteje45vvhxgb"},{"post_id":"cjoitzook001rtejextiyieal","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoos002gteje6cg3mr22"},{"post_id":"cjoitzoom001vtejeoongrlbg","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoos002jteje6i75or7i"},{"post_id":"cjoitzoom001vtejeoongrlbg","tag_id":"cjoitzool001tteje6t93409l","_id":"cjoitzoos002kteje06vitnrx"},{"post_id":"cjoitzood0016tejep24oux1h","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoot002mtejel9t01wwq"},{"post_id":"cjoitzood0016tejep24oux1h","tag_id":"cjoitzoo4000oteje2ji9m4bl","_id":"cjoitzoot002ntejeupk2ezea"},{"post_id":"cjoitzood0016tejep24oux1h","tag_id":"cjoitzool001tteje6t93409l","_id":"cjoitzoot002otejezm00bxha"},{"post_id":"cjoitzoof001dteje3dqwcnxk","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoot002ptejey7s64w3m"},{"post_id":"cjoitzoof001dteje3dqwcnxk","tag_id":"cjoitzoog001fteje9koh8yqh","_id":"cjoitzoot002qteje5e1qew4g"},{"post_id":"cjoitzooh001hteje5fwsbwcz","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoot002rtejeby6wyoew"},{"post_id":"cjoitzooh001hteje5fwsbwcz","tag_id":"cjoitzoo4000oteje2ji9m4bl","_id":"cjoitzoot002steje7t0sivcz"},{"post_id":"cjoitzooh001hteje5fwsbwcz","tag_id":"cjoitzool001tteje6t93409l","_id":"cjoitzoou002ttejepp952fpl"},{"post_id":"cjoitzooj001otejei9physvq","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoou002utejekqrlusyh"},{"post_id":"cjoitzooj001otejei9physvq","tag_id":"cjoitzoo4000oteje2ji9m4bl","_id":"cjoitzoou002vtejeeww5sje4"},{"post_id":"cjoitzooj001otejei9physvq","tag_id":"cjoitzoor002ctejen0cxpau6","_id":"cjoitzoou002wtejeyvgtb1gy"},{"post_id":"cjoitzoon001yteje5cedm6cb","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoou002xteje5uxbxr8y"},{"post_id":"cjoitzoon001yteje5cedm6cb","tag_id":"cjoitzoos002itejeo2q3ar3s","_id":"cjoitzoou002ytejehcsg0boz"},{"post_id":"cjoitzooo0022tejebl6yyj8i","tag_id":"cjoitzonp0005tejentvulruf","_id":"cjoitzoou002ztejelgaux5pu"},{"post_id":"cjoitzooo0022tejebl6yyj8i","tag_id":"cjoitzoos002ltejeozqn4qy6","_id":"cjoitzoou0030tejexq194s8w"},{"post_id":"cjoitzopj0031tejebboldcqr","tag_id":"cjoitzopm0034tejep1jeq0xe","_id":"cjoitzopo0035tejepg0y5idz"}],"Tag":[{"name":"C++","_id":"cjoitzonp0005tejentvulruf"},{"name":"Binary Tree","_id":"cjoitzoo4000oteje2ji9m4bl"},{"name":"List","_id":"cjoitzoog001fteje9koh8yqh"},{"name":"DFS","_id":"cjoitzool001tteje6t93409l"},{"name":"BST","_id":"cjoitzoor002ctejen0cxpau6"},{"name":"String","_id":"cjoitzoos002itejeo2q3ar3s"},{"name":"Stack","_id":"cjoitzoos002ltejeozqn4qy6"},{"name":"ceph","_id":"cjoitzopm0034tejep1jeq0xe"}]}}