{"meta":{"title":"zuoyang's blog","subtitle":null,"description":"welcome to my blog","author":"zuoyang","url":"https://www.zuoyangblog.com"},"pages":[{"title":"Tags","date":"2018-11-15T14:56:49.000Z","updated":"2018-11-15T14:56:49.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.zuoyangblog.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-11-15T14:56:49.000Z","updated":"2018-11-15T14:56:49.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.zuoyangblog.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-11-15T14:56:49.000Z","updated":"2018-11-15T14:56:49.000Z","comments":true,"path":"about/index.html","permalink":"https://www.zuoyangblog.com/about/index.html","excerpt":"","text":"hi,大家好！欢迎大家来到我的blog，希望以后能跟各位大佬一起学习进步。 我叫左杨，目前就职于蚂蚁金服人工智能部，从事于蚂蚁人工智能相关的开发工作，对Machine Learning，Deep Learning比较感兴趣。"}],"posts":[{"title":"第一篇：Ceph简介","slug":"Ceph_introduction","date":"2018-11-19T12:15:07.000Z","updated":"2018-11-19T13:33:19.000Z","comments":true,"path":"post/3a6a8a8c.html","link":"","permalink":"https://www.zuoyangblog.com/post/3a6a8a8c.html","excerpt":"","text":"Ceph架构简介最近工作中要使用ceph作为底层存储架构，故对其进行了一番调研，本篇乃ceph系列的第一篇。 CephCeph是一个统一的分布式存储系统，设计初衷是提供较好的性能、可靠性和可扩展性。 Ceph项目最早起源于Sage就读博士期间的工作（最早的成果于2004年发表），并随后贡献给开源社区。在经过了数年的发展之后，目前已得到众多云计算厂商的支持并被广泛应用。RedHat及OpenStack都可与Ceph整合以支持虚拟机镜像的后端存储。 Ceph is a distributed object, block, and file storage platform. 使用Ceph系统可以提供对象存储、块设备存储和文件系统服务. Ceph底层提供了分布式的RADOS存储，用与支撑上层的librados和RGW、RBD、CephFS等服务。Ceph实现了非常底层的object storage，是纯粹的SDS，并且支持通用的ZFS、BtrFS和Ext4文件系统，能轻易得Scale，没有单点故障。 Ceph特点 高性能a. 摒弃了传统的集中式存储元数据寻址的方案，采用CRUSH算法，数据分布均衡，并行度高。b.考虑了容灾域的隔离，能够实现各类负载的副本放置规则，例如跨机房、机架感知等。c. 能够支持上千个存储节点的规模，支持TB到PB级的数据。 高可用性a. 副本数可以灵活控制。b. 支持故障域分隔，数据强一致性。c. 多种故障场景自动进行修复自愈。d. 没有单点故障，自动管理。 高可扩展性a. 去中心化。b. 扩展灵活。c. 随着节点增加而线性增长。 特性丰富a. 支持三种存储接口：块存储、文件存储、对象存储。b. 支持自定义接口，支持多种语言驱动。 Ceph架构支持三种接口： Object：有原生的API，而且也兼容Swift和S3的API。 Block：支持精简配置、快照、克隆。 File：Posix接口，支持快照。 Ceph核心组件及概念介绍 Monitor 一个Ceph集群需要多个Monitor组成的小集群，它们通过Paxos同步数据，用来保存OSD的元数据。 OSD OSD全称Object Storage Device，也就是负责响应客户端请求返回具体数据的进程。一个Ceph集群一般都有很多个OSD。 MDS MDS全称Ceph Metadata Server，是CephFS服务依赖的元数据服务。 Object Ceph最底层的存储单元是Object对象，每个Object包含元数据和原始数据。 PG PG全称Placement Grouops，是一个逻辑的概念，一个PG包含多个OSD。引入PG这一层其实是为了更好的分配数据和定位数据。 RADOS RADOS全称Reliable Autonomic Distributed Object Store，是Ceph集群的精华，用户实现数据分配、Failover等集群操作。 Libradio Librados是Rados提供库，因为RADOS是协议很难直接访问，因此上层的RBD、RGW和CephFS都是通过librados访问的，目前提供PHP、Ruby、Java、Python、C和C++支持。 CRUSH CRUSH是Ceph使用的数据分布算法，类似一致性哈希，让数据分配到预期的地方。 RBD RBD全称RADOS block device，是Ceph对外提供的块设备服务。 RGW RGW全称RADOS gateway，是Ceph对外提供的对象存储服务，接口与S3和Swift兼容。 CephFS CephFS全称Ceph File System，是Ceph对外提供的文件系统服务。 CEPH Filesystem文件存储 典型设备： FTP、NFS服务器为了克服块存储文件无法共享的问题，所以有了文件存储。在服务器上架设FTP与NFS服务，就是文件存储。 优点： 造价低，随便一台机器就可以了。 方便文件共享。 缺点： 读写速率低。 传输速率慢。 使用场景： 日志存储。 有目录结构的文件存储。 … Ceph 文件系统Ceph 文件系统（ Ceph FS ）是个 POSIX 兼容的文件系统，它使用 Ceph 存储集群来存储数据。 Ceph 文件系统与 Ceph 块设备、同时提供 S3 和 Swift API 的 Ceph 对象存储、或者原生库（ librados ）一样，都使用着相同的 Ceph 存储集群系统。 Ceph 文件系统要求 Ceph 存储集群内至少有一个 Ceph 元数据服务器。 当前， CephFS 还缺乏健壮得像 ‘fsck’ 这样的检查和修复功能。存储重要数据时需小心使用，因为灾难恢复工具还没开发完。 cephfs目前发展比较慢，之前一直没有稳定版本，2016年4月21日官方发布的jewel V10.2.0才公布第一个稳定版本，当前在生产环节中使用很少，所以还是建议谨慎使用，如果要使用需要进行严格的测试后才能上线。 CEPH Block Device块存储 典型设备： 磁盘阵列，硬盘 主要是将裸磁盘空间映射给主机使用的。 优点： 通过Raid与LVM等手段，对数据提供了保护。 多块廉价的硬盘组合起来，提高容量。 多块磁盘组合出来的逻辑盘，提升读写效率。 缺点： 采用SAN架构组网时，光纤交换机，造价成本高。 主机之间无法共享数据。 使用场景： docker容器、虚拟机磁盘存储分配。 日志存储。 文件存储。 … Ceph 块设备 (RBD)块是一个字节序列（例如，一个 512 字节的数据块）。基于块的存储接口是最常见的存储数据方法，它们基于旋转介质，像硬盘、 CD 、软盘、甚至传统的 9 磁道磁带。无处不在的块设备接口使虚拟块设备成为与 Ceph 这样的海量存储系统交互的理想之选。 Ceph 块设备是精简配置的、大小可调且将数据条带化存储到集群内的多个 OSD 。 Ceph 块设备利用 RADOS 的多种能力，如快照、复制和一致性。 Ceph 的 RADOS 块设备（ RBD ）使用内核模块或 librbd 库与 OSD 交互。 内核模块可使用 Linux 页缓存。对基于 librbd 的应用程序， Ceph 可提供 RBD 缓存。 客户端可以通过内核模块挂在rbd使用，客户端使用rbd块设备就像使用普通硬盘一样，可以对其就行格式化然后使用；客户应用也可以通过librbd使用ceph块，典型的是云平台的块存储服务（如下图），云平台可以使用rbd作为云的存储后端提供镜像存储、volume块或者客户的系统引导盘等。 Ceph 块设备靠无限伸缩性提供了高性能，如向内核模块、或向 abbr:KVM (kernel virtual machines) （如 Qemu 、 OpenStack 和 CloudStack等云计算系统通过 libvirt 和 Qemu 可与 Ceph 块设备集成）。你可以用同一个集群同时运行 Ceph RADOS gateway、 Ceph FS 文件系统、和 Ceph 块设备。 目前ceph rbd在云平台使用比较广泛而且也很稳定，社区的支持力度也非常大。 CEPH Object Gateway对象存储对象存储是提供restful接口并数据组织形式扁平化的存储方法，对象存储同兼具块存储高速直接访问磁盘及文件存储的分布式共享特点。 典型设备： 内置大容量硬盘的分布式服务器(swift, s3)多台服务器内置大容量硬盘，安装上对象存储管理软件，对外提供读写访问功能。 优点： 具备块存储的读写高速。 具备文件存储的共享等特性。 使用场景： (适合更新变动较少的数据) 图片存储。 视频存储。 … Ceph 对象存储 (radosgw)Ceph 对象网关是一个构建在 librados 之上的对象存储接口，它为应用程序访问Ceph 存储集群提供了一个 RESTful 风格的网关 。 Ceph 对象存储支持 2 种接口： 兼容S3: 提供了对象存储接口，兼容大部分 亚马逊S3 RESTful 接口。 兼容Swift: 提供了对象存储接口，兼容大部分 Openstack Swift 接口。 Ceph 对象存储使用 Ceph 对象网关守护进程（ radosgw ），它是个与 Ceph 存储集群交互的 FastCGI 模块。因为它提供了与 OpenStack Swift 和 Amazon S3 兼容的接口， RADOS 要有它自己的用户管理。 Ceph 对象网关可与 Ceph FS 客户端或 Ceph 块设备客户端共用一个存储集群。 S3 和 Swift 接口共用一个通用命名空间，所以你可以用一个接口写入数据、然后用另一个接口取出数据。 Ceph 对象存储不使用 Ceph 元数据服务器。 对象存储的应用场景： 1）资源分发下载 网站或者app需要上传、下载和分发视频图片等 分发和下载app安装包等 2）网盘 可以对用户提供网盘服务，用户可以通过网盘存储自己任何格式的文件 ceph对象存储目前已经有厂商在使用，但是大多会基于网关等做些优化以适应自己的使用场景。","categories":[{"name":"ceph","slug":"ceph","permalink":"https://www.zuoyangblog.com/categories/ceph/"}],"tags":[{"name":"ceph","slug":"ceph","permalink":"https://www.zuoyangblog.com/tags/ceph/"}]},{"title":"Single Number","slug":"Single-Number","date":"2018-11-15T16:49:48.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/f249b7a1.html","link":"","permalink":"https://www.zuoyangblog.com/post/f249b7a1.html","excerpt":"","text":"问题描述： Given an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解决思路： 本题主要是求出一组数组中唯一个没有相同元素的数字，这里要求时间复杂度为O(n)，空间复杂度为O(1)，所以我们只需遍历一次数组就必须得到结果，并且不能使用其他额外的内存空间。这里采用异或运算，能够保证相同的元素运算结果为0，所以最终便能找个那个唯一的数字。 代码： 1234567891011121314151617class Solution &#123; public: int singleNumber(int A[], int n) &#123; int result = 0; for(int i = 0;i &lt; n; i++) result ^= A[i]; return result; &#125; &#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Best Time to Buy and Sell Stock II","slug":"Best-Time-to-Buy-and-Sell-Stock-II","date":"2018-11-15T16:48:29.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/a10d34fe.html","link":"","permalink":"https://www.zuoyangblog.com/post/a10d34fe.html","excerpt":"","text":"问题描述： Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 解决思路： 依次将相邻的元素相减（后面减去前面）得到新的数组，再取新数组正数相加即可 代码： 12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; if(prices.empty()) return 0; vector&lt;int&gt; price_d(prices.size()); for(int i = 0; i &lt; prices.size()-1; i++) &#123; price_d[i] = prices[i+1] - prices[i]; &#125; int max = 0; for(int i = 0; i &lt; price_d.size(); i ++) &#123; if(price_d[i] &gt; 0) max += price_d[i]; &#125; return max; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Maximum Depth of Binary Tree","slug":"Maximum-Depth-of-Binary-Tree","date":"2018-11-15T16:47:11.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/2c2d1f13.html","link":"","permalink":"https://www.zuoyangblog.com/post/2c2d1f13.html","excerpt":"","text":"问题描述：Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 解决思路： DFS分别求出左子树和右子树的最大深度然后比较即可 代码： 1234567891011121314151617181920/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode *root) &#123; if (root == NULL) return 0; int l = maxDepth(root-&gt;left); int r = maxDepth(root-&gt;right); return l&gt;r?1+l:1+r; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"},{"name":"DFS","slug":"DFS","permalink":"https://www.zuoyangblog.com/tags/DFS/"}]},{"title":"Same Tree","slug":"Same-Tree","date":"2018-11-15T16:45:40.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/f4467b0e.html","link":"","permalink":"https://www.zuoyangblog.com/post/f4467b0e.html","excerpt":"","text":"问题描述： Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 解决思路： DFS遍历两颗二叉树的结点，只要有一个不同就返回false 12345678910111213141516171819202122232425262728293031323334/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSameTree(TreeNode *p, TreeNode *q) &#123; if(p == NULL) &#123; if (q == NULL) return true; return false; &#125; if(q == NULL) &#123; if (p == NULL) return true; return false; &#125; if (p-&gt;val != q-&gt;val) return false; bool lsame = isSameTree(p-&gt;left,q-&gt;left); bool rsame = isSameTree(p-&gt;right,q-&gt;right); if(lsame==false||rsame==false) return false; return true; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"},{"name":"DFS","slug":"DFS","permalink":"https://www.zuoyangblog.com/tags/DFS/"}]},{"title":"Unique Binary Search Trees","slug":"Unique-Binary-Search-Trees","date":"2018-11-15T16:42:32.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/20d2cb13.html","link":"","permalink":"https://www.zuoyangblog.com/post/20d2cb13.html","excerpt":"","text":"问题描述： Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example,Given n = 3, there are a total of 5 unique BST’s. 123451 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\2 1 2 3 解决思路： 首先分析一下当n=0,1,2这三种情况下BTS个数，我们可以得到当n=0,1时，BTS个数为1，当n=2时，BTS个数为2.这就可以转化为一个递归求解的问题，我们将根结点从1到n依次代替，这样左右子树结点的个数就会发生变化，我们在分别求解左右子树BTS的个数，以此递归求解便可得到BTS的总数目。 代码： 1234567891011class Solution &#123;public: int numTrees(int n) &#123; if(n == 1 || n == 0) return 1; int num = 0; for(int i = 1; i &lt;= n; i++) num += numTrees(i-1) * numTrees(n-i); return num; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"},{"name":"BST","slug":"BST","permalink":"https://www.zuoyangblog.com/tags/BST/"}]},{"title":"Binary Tree Level Order Traversal II","slug":"Binary-Tree-Level-Order-Traversal-II","date":"2018-11-15T16:40:06.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/8adb33dd.html","link":"","permalink":"https://www.zuoyangblog.com/post/8adb33dd.html","excerpt":"","text":"问题描述： Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree {3,9,20,#,#,15,7}, 3 / \\ 9 20 / \\ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ. OJ’s Binary Tree Serialization:The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below. Here’s an example: 1234567 1 / \\2 3 / 4 \\ 5 The above binary tree is serialized as “{1,2,3,#,#,4,#,#,5}”. 解决思路： 和前面一样 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; levelOrderBottom(TreeNode *root) &#123; vector&lt;vector&lt;int&gt;&gt; LOB; if (root == NULL) return LOB; int level = 0; int count = 1; queue&lt;TreeNode *&gt; node; node.push(root); stack&lt;vector&lt;int&gt;&gt; stk; vector&lt;int&gt; sub(0); while(!node.empty())&#123; sub.clear(); level = 0; for(int i = 0; i &lt; count; i++)&#123; root = node.front(); node.pop(); sub.push_back(root-&gt;val); if(root-&gt;left != NULL)&#123; node.push(root-&gt;left); ++level; &#125; if(root-&gt;right != NULL)&#123; node.push(root-&gt;right); ++level; &#125; &#125; stk.push(sub); count = level; &#125; while(!stk.empty())&#123; vector&lt;int&gt; tmp = stk.top(); LOB.push_back(tmp); stk.pop(); &#125; return LOB; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Binary Tree Level Order Traversal","slug":"Binary-Tree-Level-Order-Traversal","date":"2018-11-15T16:37:35.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/a971a08f.html","link":"","permalink":"https://www.zuoyangblog.com/post/a971a08f.html","excerpt":"","text":"问题描述： Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree {3,9,20,#,#,15,7}, 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ. OJ’s Binary Tree Serialization:The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below. Here’s an example: 1234567 1 / \\2 3 / 4 \\ 5 The above binary tree is serialized as “{1,2,3,#,#,4,#,#,5}”. 解决思路： 这里需要用到队列，因为根据题意要求，我们的输出结果应该是包含vector的vector，里面的每个vector包含的是该层的所有节点的值。由于队列是先进先出的，所以首先建立一个节点队列，从根节点开始插入，另外用count记录每层节点的总个数，level计算每层节点的个数。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt;&gt; LO; if(root == NULL) return LO; queue&lt;TreeNode *&gt; node; node.push(root); int count = 1; int level = 0; vector&lt;int&gt; sub(0); while(!node.empty())&#123; sub.clear(); level = 0; for(int i = 0; i &lt; count; i++)&#123; root = node.front(); node.pop(); sub.push_back(root-&gt;val); if(root-&gt;left != NULL)&#123; node.push(root-&gt;left); ++level; &#125; if(root-&gt;right != NULL)&#123; node.push(root-&gt;right); ++level; &#125; &#125; count = level; LO.push_back(sub); &#125; return LO; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Binary Tree Preorder Traversal","slug":"Binary-Tree-Preorder-Traversal","date":"2018-11-15T16:35:34.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/d13d2726.html","link":"","permalink":"https://www.zuoyangblog.com/post/d13d2726.html","excerpt":"","text":"问题描述： Given a binary tree, return the preorder traversal of its nodes’ values. For example:Given binary tree {1,#,2,3}, 1​ \\​ 2​ / 3return [1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? 非递归实现，不过超时了。 123456789101112131415161718192021222324252627/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; pretr; if(root == NULL) return pretr; stack&lt;TreeNode *&gt; node; node.push(root); while(!node.empty())&#123; TreeNode *p = node.top(); pretr.push_back(p-&gt;val); node.pop(); if(p-&gt;right) node.push(p); if(p-&gt;left) node.push(p); &#125; return pretr; &#125;&#125;; 递归实现 1234567891011121314151617181920212223242526/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; pretr; process(root,pretr); return pretr; &#125; void process(TreeNode *root,vector&lt;int&gt; &amp;pretr)&#123; if(root == NULL) return; TreeNode *p; p = root; pretr.push_back(p-&gt;val); process(p-&gt;left,pretr); process(p-&gt;right,pretr); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Binary Tree Inorder Traversal","slug":"Binary-Tree-Inorder-Traversal","date":"2018-11-15T16:33:28.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/8a5e7d39.html","link":"","permalink":"https://www.zuoyangblog.com/post/8a5e7d39.html","excerpt":"","text":"问题描述： Given a binary tree, return the inorder traversal of its nodes’ values. For example:Given binary tree {1,#,2,3}, 1​ \\​ 2​ / 3return [1,3,2]. Note: Recursive solution is trivial, could you do it iteratively? confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ. 解决思路： 本想用栈去实现，但是这上面好像没有栈的定义，没办法只好用vector去解决了。 代码： 123456789101112131415161718192021222324252627282930313233/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; intr; if (root == NULL) return intr; vector&lt;TreeNode*&gt; node; TreeNode *p; p = root; while(p != NULL || !node.empty())&#123; if(p != NULL)&#123; node.push_back(p); p =p-&gt;left; &#125; else&#123; TreeNode *t = node.back(); node.pop_back(); intr.push_back(t-&gt;val); p = t-&gt;right; &#125; &#125; return intr; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Linked List Cycle","slug":"Linked-List-Cycle","date":"2018-11-15T16:20:05.000Z","updated":"2018-11-15T16:25:35.000Z","comments":true,"path":"post/c94099d8.html","link":"","permalink":"https://www.zuoyangblog.com/post/c94099d8.html","excerpt":"","text":"问题描述： Given a linked list, determine if it has a cycle in it. Follow up:Can you solve it without using extra space? 解决思路： 采用快慢指针的方法，快指针一次走两步，慢指针一次走一步，如果链表中有环的话，经过走一定的步数之后快慢指针一定会相遇的，当然如果没有环就需考虑循环结束的条件，这里主要要考虑快指针的情况即可。 代码： 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == NULL) return false; if(head-&gt;next == NULL) return false; ListNode *p,*q; p = head; q = head; while(p != NULL &amp;&amp; p-&gt;next != NULL) &#123; p = p-&gt;next-&gt;next; q = q-&gt;next; if(p == q) return true; &#125; return false; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"List","slug":"List","permalink":"https://www.zuoyangblog.com/tags/List/"}]},{"title":"Remove Duplicates from Sorted List","slug":"Remove-Duplicates-from-Sorted-List","date":"2018-11-15T16:18:19.000Z","updated":"2018-11-15T16:28:43.000Z","comments":true,"path":"post/1d8b65b1.html","link":"","permalink":"https://www.zuoyangblog.com/post/1d8b65b1.html","excerpt":"","text":"问题描述： Given a sorted linked list, delete all duplicates such that each element appear only once. For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 解决思路： 定义两个指针base和cmp,base指针指向被比较的结点，cmp指向base的后一个结点，由于链表是有序的，所以cmp找到第一个不等于base的结点之后，就分别将base和cmp后移。如果相等，只要将相等的结点删除即可。 代码: 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *deleteDuplicates(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *base,*cmp; base = head; cmp = base-&gt;next; while(cmp != NULL)&#123; ListNode *tmp; tmp = cmp-&gt;next; if(cmp-&gt;val == base-&gt;val)&#123; base-&gt;next = tmp; free(cmp); cmp = tmp; &#125; else&#123; base = cmp; cmp = tmp; &#125; &#125; return head; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"List","slug":"List","permalink":"https://www.zuoyangblog.com/tags/List/"}]},{"title":"ZigZag Conversion","slug":"ZigZag-Conversion","date":"2018-11-15T16:16:46.000Z","updated":"2018-11-15T16:25:35.000Z","comments":true,"path":"post/61984fa2.html","link":"","permalink":"https://www.zuoyangblog.com/post/61984fa2.html","excerpt":"","text":"问题描述： The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows);convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”. 解决思路： 找出规律即可，每次的周期为2nRows-2,但是在1到nRows-1的行数还需要判断周期为2（nRows-1-i）的元素，i是处于1到nRows-1的行数。 代码： 12345678910111213141516171819class Solution &#123;public: string convert(string s, int nRows) &#123; if(s.empty() || nRows &lt;= 1 || s.length() &lt; nRows) return s; string result; int cycle = 2 * nRows - 2; for(int i = 0; i &lt; nRows; i++)&#123; for(int j = i; j &lt; s.length(); j += cycle)&#123; result.push_back(s[j]); if( i &gt; 0 &amp;&amp; i &lt; nRows-1)&#123; if (j + 2 *(nRows - 1 - i) &lt; s.length()) result.push_back(s[j + 2 *(nRows - 1 - i)]); &#125; &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Balanced Binary Tree","slug":"Balanced-Binary-Tree","date":"2018-11-15T16:14:50.000Z","updated":"2018-11-15T16:28:07.000Z","comments":true,"path":"post/5c1c4dd0.html","link":"","permalink":"https://www.zuoyangblog.com/post/5c1c4dd0.html","excerpt":"","text":"问题描述： Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 解决思路： 首先设计一个求二叉树高度的函数，然后调用该函数比较左右子树的高度差即可。 123456789101112131415161718192021222324252627282930313233/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int height(TreeNode *root)&#123; if(root == NULL) return 0; int hr,hl; hl = height(root-&gt;left); hr = height(root-&gt;right); int h; h =1 + (hl &gt; hr ? hl : hr); return h; &#125; bool isBalanced(TreeNode *root) &#123; if(root == NULL) return true; int hl = height(root-&gt;left); int hr = height(root-&gt;right); int diff = hl - hr; if(diff &gt; 1 || diff &lt; -1) return false; return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Majority Element","slug":"Majority-Element","date":"2018-11-15T16:12:02.000Z","updated":"2018-11-15T16:14:30.000Z","comments":true,"path":"post/ed8e0613.html","link":"","permalink":"https://www.zuoyangblog.com/post/ed8e0613.html","excerpt":"","text":"问题描述： Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 解决思路： 这是一个求解数组主元素的题目，数组的主元素是指数组中出现次数超过一半的元素。此题是假设数组非空并且主元素存在，所以比较简单。主元素总会比其他元素多，我们设置两个变量maj_index用于记录主元素的位置，count用于记录主元素出现的次数，然后一次比较数组元素，如果相同则count加1，不同则减1，若count为零，则替换maj_index，并将count置为1. 代码： 12345678910111213141516171819class Solution &#123;public: int majorityElement(vector&lt;int&gt; &amp;num) &#123; int maj_index,count; maj_index = 0; count = 1; for(int i =1; i &lt; num.size(); i++)&#123; if (num[i] == num[maj_index]) count ++; else count --; if (count == 0)&#123; maj_index = i; count = 1; &#125; &#125; return num[maj_index]; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Intersection of Two Linked Lists","slug":"Intersection-of-Two-Linked-Lists","date":"2018-11-15T16:09:39.000Z","updated":"2018-11-15T16:28:26.000Z","comments":true,"path":"post/42870ae4.html","link":"","permalink":"https://www.zuoyangblog.com/post/42870ae4.html","excerpt":"","text":"问题描述： For example, the following two linked lists: A: a1 → a2​ ↘​ c1 → c2 → c3​ ↗B: b1 → b2 → b3begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null.The linked lists must retain their original structure after the function returns.You may assume there are no cycles anywhere in the entire linked structure.Your code should preferably run in O(n) time and use only O(1) memory. 解决思路： 这题要求的时间复杂度是O(n)和空间复杂度O(1)，所以只能用以下方法解决：(1)首先分别求出两个单链表的长度lenA和lenB；(2)求出两个链表的长度差，然后将长链表的比较位置移到长度差的位置，因为这些位置上的两个链表的元素是肯定不相同的；(3)此时，两个链表的长度一致，在分别依次比较元素即可 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if(headA == NULL || headB == NULL) return NULL; int lenA,lenB; lenA = 0,lenB = 0; ListNode *p,*q; for(p = headA;p != NULL;p=p-&gt;next) lenA ++; for(q = headB;q != NULL;q=q-&gt;next) lenB ++; int diff = abs(lenB-lenA); if(lenA &gt; lenB)&#123; p = headA; for(int i = 0;i &lt; diff;i++) p = p-&gt;next; q = headB; while(p != NULL &amp;&amp; q != NULL)&#123; if(p-&gt;val == q-&gt;val) return p; else&#123; p = p-&gt;next; q = q-&gt;next; &#125; &#125; return NULL; &#125; else&#123; p = headB; for(int i = 0;i &lt; diff;i++) p = p-&gt;next; q = headA; while(p != NULL &amp;&amp; q != NULL)&#123; if(p-&gt;val == q-&gt;val) return p; else&#123; p = p-&gt;next; q = q-&gt;next; &#125; &#125; return NULL; &#125; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"List","slug":"List","permalink":"https://www.zuoyangblog.com/tags/List/"}]},{"title":"Palindrome Number","slug":"Palindrome-Number","date":"2018-11-15T16:06:52.000Z","updated":"2018-11-15T16:14:30.000Z","comments":true,"path":"post/b216f26b.html","link":"","permalink":"https://www.zuoyangblog.com/post/b216f26b.html","excerpt":"","text":"问题描述： Determine whether an integer is a palindrome. Do this without extra space. click to show spoilers. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 解决思路： 这里要求不能使用额外的空间，基本思路是首先求出数据的位数，然后编写一个函数能够求出每一位的数字，然后遍历比较即可。 代码1： 123456789101112131415161718192021222324class Solution &#123;public: bool isPalindrome(int x) &#123; if (x &lt; 0) return false; int num = 0; int y = x; while( y != 0)&#123; num ++; y /= 10; &#125; int i,j; for(i = 1, j = num; i &lt; j;i++,j--)&#123; if (search(x,num,i) != search(x,num,j)) return false; &#125; return true; &#125; int search(int x,int n,int index)&#123; int d = pow(10,n-index); int y = x/d; return y%10; &#125;&#125;; 代码2： 123456789101112131415161718class Solution &#123;public: bool isPalindrome(int x) &#123; if (x &lt; 0) return false; int z = x; int y = 0; while( x != 0)&#123; y *= 10; y += x%10; x /= 10; &#125; if(z == y) return true; else return false; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Excel Sheet Column Number","slug":"Excel-Sheet-Column-Number","date":"2018-11-15T16:03:44.000Z","updated":"2018-11-15T16:14:30.000Z","comments":true,"path":"post/50445eba.html","link":"","permalink":"https://www.zuoyangblog.com/post/50445eba.html","excerpt":"","text":"问题描述： Related to question Excel Sheet Column Title Given a column title as appear in an Excel sheet, return its corresponding column number. For example: 1234567A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 解决思路： 本题类似于进制转换，将一个字符串转化为一个十进制的数字，而要求的字符串可以看作是一个26进制的数字。 代码： 12345678910111213class Solution &#123;public: int titleToNumber(string s) &#123; if(s.empty()) return 0; int n = 0; for(int i = 0; i &lt; s.length()-1; i ++)&#123; n = (int(s[i]-'A')+1+n) * 26; &#125; n += int(s[s.length()-1]-'A')+1; return n; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"2Sum","slug":"2Sum","date":"2018-11-15T15:50:54.000Z","updated":"2018-11-16T08:53:36.000Z","comments":true,"path":"post/74d7ef89.html","link":"","permalink":"https://www.zuoyangblog.com/post/74d7ef89.html","excerpt":"","text":"问题描述： Given an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 解决思路： 本题主要是在给定的一个数组中找到两个数的下标，使得这个两个数和为给定的值，要求给出的下标从1 开始，且满足递增顺序，有三种解决方法，复杂度分别为O(n^2),O(nlogn),O(n),具体实现如下： 复杂度为O(n^2) 代码： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; // Start typing your C/C++ solution below // DO NOT write int main() function vector&lt;int&gt; ret(2, 0); int len = numbers.size(); for(int i = 0; i &lt; len; i++) &#123; int tmp = target - numbers[i]; // another number for(int j = i + 1; j &lt; len; j++) &#123; if(tmp == numbers[j]) &#123; ret[0] = i + 1; // +1 for not zero-based ret[1] = j + 1; return ret; &#125; &#125; &#125; return ret; &#125;&#125;; 复杂度O(nlogn)代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; vector&lt;int&gt; index; int len = numbers.size(); vector&lt;int&gt; bak = numbers; sort(bak.begin(),bak.end()); int l = 0,r = len-1; int sum = 0; while(l &lt; r)&#123; sum = bak[l]+bak[r]; if(sum == target) &#123; for(int i = 0; i &lt; len;i++) &#123; if (bak[l] == numbers[i]) &#123; index.push_back(i+1); &#125; else if(bak[r] == numbers[i]) &#123; index.push_back(i+1); &#125; if(index.size() == 2) &#123; break; &#125; &#125; break; &#125; else if(sum &lt; target) &#123; ++l; &#125; else &#123; --r; &#125; &#125; return index; &#125;&#125;; 复杂度O(n)代码: 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; int len = numbers.size(); assert(len &gt;= 2); vector&lt;int&gt; ret(2, 0); map&lt;int, int&gt; mapping; // default all are 0 vector&lt;long long&gt; mul(len, 0); for(int i = 0; i &lt; len; i++)&#123; mul[i] = (target - numbers[i]) * numbers[i]; if(mapping[mul[i]] &gt; 0)&#123; // not default 0 if(numbers[i] + numbers[mapping[mul[i]] - 1] == target)&#123; ret[0] = mapping[mul[i]]; ret[1] = i + 1; break; &#125; &#125; else &#123; mapping[mul[i]] = i + 1; // larger than 0 &#125; &#125; return ret; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"3Sum","slug":"3Sum","date":"2018-11-15T15:50:50.000Z","updated":"2018-11-15T16:28:12.000Z","comments":true,"path":"post/cc6b88ec.html","link":"","permalink":"https://www.zuoyangblog.com/post/cc6b88ec.html","excerpt":"","text":"问题描述： Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)The solution set must not contain duplicate triplets.​ For example, given array S = {-1 0 1 2 -1 -4}, A solution set is: (-1, 0, 1) (-1, -1, 2) 解决思路： 3sum的时候，先整体排一次序，然后枚举第三个数字的时候不需要重复， 比如排好序以后的数字是 a b c d e f, 那么第一次枚举a, 在剩下的b c d e f中进行2 sum, 完了以后第二次枚举b, 只需要在 c d e f中进行2sum好了，而不是在a c d e f中进行2sum, 这个大家可以自己体会一下，想通了还是挺有帮助的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123; sort(num.begin(),num.end()); int len = num.size(); vector&lt;vector&lt;int&gt;&gt; result; if(len &lt; 3) return result; int iCount = len - 2; vector&lt;int&gt; truple(3,0); int CurrentVal = num[0]; for(int i = 0; i &lt; iCount;i++) &#123; if(i &amp;&amp; num[i] == CurrentVal) &#123; continue; &#125; truple[0] = num[i]; int l = i + 1; int r = len - 1; while(l&lt;r) &#123; int iSum = num[l] + num[r]; if(iSum + truple[0] == 0) &#123; truple[1] = num[l]; truple[2] = num[r]; if(result.size() == 0 || truple != result[result.size()-1]) result.push_back(truple); ++l; --r; &#125; else if(iSum + truple[0] &lt; 0) &#123; ++l; &#125; else &#123; --r; &#125; &#125; CurrentVal = num[i]; &#125; return result; &#125; &#125;; 这是一篇关于kSum问题的总结性文章。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"3Sum Closest","slug":"3Sum-Closest","date":"2018-11-15T15:44:35.000Z","updated":"2018-11-15T16:28:11.000Z","comments":true,"path":"post/c85f0a37.html","link":"","permalink":"https://www.zuoyangblog.com/post/c85f0a37.html","excerpt":"","text":"问题描述： Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. For example, given array S = {-1 2 1 -4}, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 解决思路： 我们可以在 2sum问题 的基础上来解决3sum问题，假设3sum问题的目标是target。每次从数组中选出一个数k，从剩下的数中求目标等于target-k的2sum问题。这里需要注意的是有个小的trick：当我们从数组中选出第i数时，我们只需要求数值中从第i+1个到最后一个范围内字数组的2sum问题。我们以选第一个和第二个举例，假设数组为A[],总共有n个元素A1，A2….An。很显然，当选出A1时，我们在子数组[A2~An]中求目标位target-A1的2sum问题，我们要证明的是当选出A2时，我们只需要在子数组[A3~An]中计算目标位target-A2的2sum问题，而不是在子数组[A1,A3~An]中，证明如下：假设在子数组[A1,A3~An]目标位target-A2的2sum问题中，存在A1 + m = target-A2（m为A3~An中的某个数），即A2 + m = target-A1，这刚好是“对于子数组[A3~An],目标位target-A1的2sum问题”的一个解。即我们相当于对满足3sum的三个数A1+A2+m = target重复计算了。因此为了避免重复计算，在子数组[A1，A3~An]中，可以把A1去掉，再来计算目标是target-A2的2sum问题。 对于本题要求的求最接近解，只需要保存当前解以及当前解和目标的距离，如果新的解更接近，则更新解。算法复杂度为O（n^2）;注意：我们这里是求的和是一个非确定性的数，因此2sum问题的hashtable解法就不适合这里了 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: int threeSumClosest(vector&lt;int&gt; &amp;num, int target) &#123; int n = num.size(); sort(num.begin(),num.end()); int res,dis=INT_MAX; for(int i = 0;i&lt;n-2;i++) &#123; int target2 = target - num[i]; int tmpdis; int tmpres = twoSumClosest(num,i+1,target2); if((tmpdis = abs(tmpres-target2)) &lt; dis) &#123; res = tmpres + num[i]; dis = tmpdis; if(res == target) return res; &#125; &#125; return res; &#125; int twoSumClosest(vector&lt;int&gt; &amp;sortnum,int start,int target)&#123; int res,dis=INT_MAX; int l = start,r = sortnum.size()-1; while(l&lt;r) &#123; int sum = sortnum[l]+sortnum[r]; if(sum &lt; target) &#123; if(target-sum &lt; dis) &#123; res = sum; dis = target - sum; &#125; ++l; &#125; else if(sum &gt; target) &#123; if(sum - target &lt; dis) &#123; res = sum; dis = sum - target; &#125; --r; &#125; else return target; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"4Sum","slug":"4Sum","date":"2018-11-15T15:44:12.000Z","updated":"2018-11-15T16:28:10.000Z","comments":true,"path":"post/51bcb055.html","link":"","permalink":"https://www.zuoyangblog.com/post/51bcb055.html","excerpt":"","text":"问题描述Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: 12345[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 算法1：O(n^3) 我们可以仿照3sum的解决方法。这里枚举第一个和第二个数，然后对余下数的求2sum，算法复杂度为O（n^3） 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target) &#123; int n = num.size(); sort(num.begin(),num.end()); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; quard(4,0); for(int i = 0; i &lt; n-3; i++) &#123; if(i &gt; 0 &amp;&amp; num[i] == num[i-1]) continue; for(int j = i + 1; j &lt; n -2; j++) &#123; if(j &gt; i+1 &amp;&amp; num[j] == num[j-1]) continue; int l = j+1,r=n-1; int target2 = target - num[i] - num[j]; while(l&lt;r) &#123; int sum = num[l] + num[r]; if(sum &lt; target2) &#123; ++l; &#125; else if(sum &gt; target2) &#123; --r; &#125; else &#123; quard[0] = num[i]; quard[1] = num[j]; quard[2] = num[l]; quard[3] = num[r]; res.push_back(quard); int k = l + 1; while(k &lt; r &amp;&amp; num[k] == num[l])k++; l = k; k = r-1; while(k &gt; l &amp;&amp; num[k] == num[r])k--; r = k; &#125; &#125; &#125; &#125; return res; &#125;&#125;; 算法2：O（n^2）的算法 和前面相同，都是先对数组排序。我们先枚举出所有二个数的和存放在哈希map中，其中map的key对应的是二个数的和，因为多对元素求和可能是相同的值，故哈希map的value是一个链表（下面的代码中用数组代替），链表每个节点存的是这两个数在数组的下标；这个预处理的时间复杂度是O（n^2）。接着和算法1类似，枚举第一个和第二个元素，假设分别为v1,v2, 然后在哈希map中查找和为target-v1-v2的所有二元对（在对应的链表中），查找的时间为O（1），为了保证不重复计算，我们只保留两个数下标都大于V2的二元对（其实我们在前面3sum问题中所求得的三个数在排序后的数组中下标都是递增的），即时是这样也有可能重复：比如排好序后数组为-9 -4 -2 0 2 4 4，target = 0，当第一个和第二个元素分别是-4，-2时，我们要得到和为0-（-2）-（-4） = 6的二元对，这样的二元对有两个,都是(2,4)，且他们在数组中的下标都大于-4和-2，如果都加入结果，则(-4,-2,2,4)会出现两次，因此在加入二元对时，要判断是否和已经加入的二元对重复（由于过早二元对之前数组已经排过序，所以两个元素都相同的二元对可以保证在链表中是相邻的，链表不会出现(2,4)-&gt;(1,5)-&gt;(2,4)的情况，因此只要判断新加入的二元对和上一个加入的二元对是否重复即可），因为同一个链表中的二元对两个元素的和都是相同的，因此只要二元对的一个元素不同，则这个二元对就不同。我们可以认为哈希map中key对应的链表长度为常数，那么算法总的复杂度为O（n^2） 代码： 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target) &#123; int n = num.size(); vector&lt;vector&lt;int&gt; &gt; res; unordered_map&lt;int, vector&lt;pair&lt;int, int&gt; &gt; &gt;pairs; pairs.reserve(n*n); sort(num.begin(), num.end()); for(int i = 0; i &lt; n; i++) for(int j = i+1 ; j &lt; n; j++) pairs[num[i]+num[j]].push_back(make_pair(i,j)); for(int i = 0; i &lt; n - 3; i++) &#123; if(i != 0 &amp;&amp; num[i] == num[i-1])continue;//防止第一个元素重复 for(int j = i+1; j &lt; n - 2; j++) &#123; if(j != i+1 &amp;&amp; num[j] == num[j-1])continue;//防止第二个元素重复 if(pairs.find(target - num[i] - num[j]) != pairs.end()) &#123; vector&lt;pair&lt;int, int&gt;&gt; &amp;sum2 = pairs[target - num[i] - num[j]]; bool isFirstPush = true; for(int k = 0; k &lt; sum2.size(); k++) &#123; if(sum2[k].first &lt;= j)continue;//保证所求的四元组的数组下标是递增的 if(isFirstPush || (res.back())[2] != num[sum2[k].first]) &#123; res.push_back(vector&lt;int&gt;&#123;num[i], num[j], num[sum2[k].first], num[sum2[k].second]&#125;); isFirstPush = false; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"有效的括号序列","slug":"有效的括号序列","date":"2018-11-15T15:41:20.000Z","updated":"2018-11-15T16:28:04.000Z","comments":true,"path":"post/cf94e2fe.html","link":"","permalink":"https://www.zuoyangblog.com/post/cf94e2fe.html","excerpt":"","text":"问题描述： 给定一个字符串所表示的括号序列，包含以下字符： &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;， 判定是否是有效的括号序列。 样例 括号必须依照 &quot;()&quot; 顺序表示， &quot;()[]{}&quot; 是有效的括号，但 &quot;([)]&quot;则是无效的括号。 解题思路：使用栈 代码： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: /** * @param s A string * @return whether the string is a valid parentheses */ bool isMatch(char a, char b) &#123; if(a == '(' &amp;&amp; b == ')') return true; if(a == '[' &amp;&amp; b == ']') return true; if(a == '&#123;' &amp;&amp; b == '&#125;') return true; return false; &#125; bool isValidParentheses(string&amp; s) &#123; // Write your code here int n = s.length(); if(n &lt; 1) return true; if(n % 2) return false; stack&lt;char&gt; paren; paren.push(s[0]); int i = 1; while(i &lt; n) &#123; if(!paren.empty() &amp;&amp; isMatch(paren.top(),s[i])) paren.pop(); else paren.push(s[i]); i++; &#125; if(!paren.empty()) return false; else return true; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Stack","slug":"Stack","permalink":"https://www.zuoyangblog.com/tags/Stack/"}]},{"title":"岛屿个数","slug":"岛屿个数","date":"2018-11-15T15:36:58.000Z","updated":"2018-11-15T16:28:09.000Z","comments":true,"path":"post/cc03a9fe.html","link":"","permalink":"https://www.zuoyangblog.com/post/cc03a9fe.html","excerpt":"","text":"问题描述： 给一个0,1矩阵，求不同的岛屿的个数。 0代表海，1代表岛，如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。 样例 在矩阵： 1234567[ [1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1]] 中有 3 个岛. 解题思路：深度遍历 dfs 代码： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: /** * @param grid a boolean 2D matrix * @return an integer */ int step[4][2] = &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;; int numIslands(vector&lt;vector&lt;bool&gt;&gt;&amp; grid) &#123; // Write your code here int n = grid.size(); if(n &lt; 1) return 0; int m = grid[0].size(); int count = 0; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(grid[i][j] == true)&#123; dfs(grid,i,j); count++; &#125; &#125; &#125; return count; &#125; void dfs(vector&lt;vector&lt;bool&gt;&gt;&amp; grid, int i, int j)&#123; grid[i][j] = false; for(int k = 0; k &lt; 4; k++)&#123; int x = step[k][0] + i; int y = step[k][1] + j; if(x &gt;= 0 &amp;&amp; x &lt; grid.size() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; grid[0].size() &amp;&amp; grid[x][y] == true)&#123; dfs(grid,x,y); &#125; &#125; return; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"DFS","slug":"DFS","permalink":"https://www.zuoyangblog.com/tags/DFS/"}]},{"title":"最后一个单词的长度","slug":"最后一个单词的长度","date":"2018-11-15T15:19:54.000Z","updated":"2018-11-15T16:28:05.000Z","comments":true,"path":"post/f055ffc7.html","link":"","permalink":"https://www.zuoyangblog.com/post/f055ffc7.html","excerpt":"","text":"问题描述： 给定一个字符串， 包含大小写字母、空格&#39; &#39;，请返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 样例： 给定 s = &quot;Hello World&quot;，返回 5。 代码： 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: /** * @param s A string * @return the length of last word */ int lengthOfLastWord(string&amp; s) &#123; // Write your code here int n = s.length(); int len = 0; if(n &lt; 1) return 0; int i = n - 1; while(i &gt;= 0) &#123; if(s[i] == ' ') i--; else break; &#125; if(i &gt;= 0) &#123; while(s[i] != ' ' &amp;&amp; i &gt;= 0) &#123; len++; i--; &#125; return len; &#125; else return len; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"String","slug":"String","permalink":"https://www.zuoyangblog.com/tags/String/"}]}]}