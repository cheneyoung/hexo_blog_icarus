{"meta":{"title":"zuoyang's blog","subtitle":null,"description":"welcome to my blog","author":"zuoyang","url":"https://www.zuoyangblog.com"},"pages":[{"title":"","date":"2018-11-15T14:56:49.000Z","updated":"2018-11-15T14:56:49.000Z","comments":true,"path":"about/index.html","permalink":"https://www.zuoyangblog.com/about/index.html","excerpt":"","text":"hi,大家好！欢迎大家来到我的blog，希望以后能跟各位大佬一起学习进步。 我叫左杨，目前就职于蚂蚁金服人工智能部，从事于蚂蚁人工智能相关的开发工作，对Machine Learning，Deep Learning比较感兴趣。"},{"title":"Categories","date":"2018-11-15T14:56:49.000Z","updated":"2018-11-15T14:56:49.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.zuoyangblog.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-15T14:56:49.000Z","updated":"2018-11-15T14:56:49.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.zuoyangblog.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Single Number","slug":"Single-Number","date":"2018-11-15T16:49:48.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/f249b7a1.html","link":"","permalink":"https://www.zuoyangblog.com/post/f249b7a1.html","excerpt":"","text":"问题描述： Given an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解决思路： 本题主要是求出一组数组中唯一个没有相同元素的数字，这里要求时间复杂度为O(n)，空间复杂度为O(1)，所以我们只需遍历一次数组就必须得到结果，并且不能使用其他额外的内存空间。这里采用异或运算，能够保证相同的元素运算结果为0，所以最终便能找个那个唯一的数字。 代码： 1234567891011121314151617class Solution &#123; public: int singleNumber(int A[], int n) &#123; int result = 0; for(int i = 0;i &lt; n; i++) result ^= A[i]; return result; &#125; &#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Best Time to Buy and Sell Stock II","slug":"Best-Time-to-Buy-and-Sell-Stock-II","date":"2018-11-15T16:48:29.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/a10d34fe.html","link":"","permalink":"https://www.zuoyangblog.com/post/a10d34fe.html","excerpt":"","text":"问题描述： Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 解决思路： 依次将相邻的元素相减（后面减去前面）得到新的数组，再取新数组正数相加即可 代码： 12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; if(prices.empty()) return 0; vector&lt;int&gt; price_d(prices.size()); for(int i = 0; i &lt; prices.size()-1; i++) &#123; price_d[i] = prices[i+1] - prices[i]; &#125; int max = 0; for(int i = 0; i &lt; price_d.size(); i ++) &#123; if(price_d[i] &gt; 0) max += price_d[i]; &#125; return max; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Maximum Depth of Binary Tree","slug":"Maximum-Depth-of-Binary-Tree","date":"2018-11-15T16:47:11.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/2c2d1f13.html","link":"","permalink":"https://www.zuoyangblog.com/post/2c2d1f13.html","excerpt":"","text":"问题描述：Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 解决思路： DFS分别求出左子树和右子树的最大深度然后比较即可 代码： 1234567891011121314151617181920/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode *root) &#123; if (root == NULL) return 0; int l = maxDepth(root-&gt;left); int r = maxDepth(root-&gt;right); return l&gt;r?1+l:1+r; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"},{"name":"DFS","slug":"DFS","permalink":"https://www.zuoyangblog.com/tags/DFS/"}]},{"title":"Same Tree","slug":"Same-Tree","date":"2018-11-15T16:45:40.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/f4467b0e.html","link":"","permalink":"https://www.zuoyangblog.com/post/f4467b0e.html","excerpt":"","text":"问题描述： Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 解决思路： DFS遍历两颗二叉树的结点，只要有一个不同就返回false 12345678910111213141516171819202122232425262728293031323334/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSameTree(TreeNode *p, TreeNode *q) &#123; if(p == NULL) &#123; if (q == NULL) return true; return false; &#125; if(q == NULL) &#123; if (p == NULL) return true; return false; &#125; if (p-&gt;val != q-&gt;val) return false; bool lsame = isSameTree(p-&gt;left,q-&gt;left); bool rsame = isSameTree(p-&gt;right,q-&gt;right); if(lsame==false||rsame==false) return false; return true; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"},{"name":"DFS","slug":"DFS","permalink":"https://www.zuoyangblog.com/tags/DFS/"}]},{"title":"Unique Binary Search Trees","slug":"Unique-Binary-Search-Trees","date":"2018-11-15T16:42:32.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/20d2cb13.html","link":"","permalink":"https://www.zuoyangblog.com/post/20d2cb13.html","excerpt":"","text":"问题描述： Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example,Given n = 3, there are a total of 5 unique BST’s. 123451 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\2 1 2 3 解决思路： 首先分析一下当n=0,1,2这三种情况下BTS个数，我们可以得到当n=0,1时，BTS个数为1，当n=2时，BTS个数为2.这就可以转化为一个递归求解的问题，我们将根结点从1到n依次代替，这样左右子树结点的个数就会发生变化，我们在分别求解左右子树BTS的个数，以此递归求解便可得到BTS的总数目。 代码： 1234567891011class Solution &#123;public: int numTrees(int n) &#123; if(n == 1 || n == 0) return 1; int num = 0; for(int i = 1; i &lt;= n; i++) num += numTrees(i-1) * numTrees(n-i); return num; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"},{"name":"BST","slug":"BST","permalink":"https://www.zuoyangblog.com/tags/BST/"}]},{"title":"Binary Tree Level Order Traversal II","slug":"Binary-Tree-Level-Order-Traversal-II","date":"2018-11-15T16:40:06.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/8adb33dd.html","link":"","permalink":"https://www.zuoyangblog.com/post/8adb33dd.html","excerpt":"","text":"问题描述： Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree {3,9,20,#,#,15,7}, 3 / \\ 9 20 / \\ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ. OJ’s Binary Tree Serialization:The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below. Here’s an example: 1234567 1 / \\2 3 / 4 \\ 5 The above binary tree is serialized as “{1,2,3,#,#,4,#,#,5}”. 解决思路： 和前面一样 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; levelOrderBottom(TreeNode *root) &#123; vector&lt;vector&lt;int&gt;&gt; LOB; if (root == NULL) return LOB; int level = 0; int count = 1; queue&lt;TreeNode *&gt; node; node.push(root); stack&lt;vector&lt;int&gt;&gt; stk; vector&lt;int&gt; sub(0); while(!node.empty())&#123; sub.clear(); level = 0; for(int i = 0; i &lt; count; i++)&#123; root = node.front(); node.pop(); sub.push_back(root-&gt;val); if(root-&gt;left != NULL)&#123; node.push(root-&gt;left); ++level; &#125; if(root-&gt;right != NULL)&#123; node.push(root-&gt;right); ++level; &#125; &#125; stk.push(sub); count = level; &#125; while(!stk.empty())&#123; vector&lt;int&gt; tmp = stk.top(); LOB.push_back(tmp); stk.pop(); &#125; return LOB; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Binary Tree Level Order Traversal","slug":"Binary-Tree-Level-Order-Traversal","date":"2018-11-15T16:37:35.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/a971a08f.html","link":"","permalink":"https://www.zuoyangblog.com/post/a971a08f.html","excerpt":"","text":"问题描述： Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree {3,9,20,#,#,15,7}, 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ. OJ’s Binary Tree Serialization:The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below. Here’s an example: 1234567 1 / \\2 3 / 4 \\ 5 The above binary tree is serialized as “{1,2,3,#,#,4,#,#,5}”. 解决思路： 这里需要用到队列，因为根据题意要求，我们的输出结果应该是包含vector的vector，里面的每个vector包含的是该层的所有节点的值。由于队列是先进先出的，所以首先建立一个节点队列，从根节点开始插入，另外用count记录每层节点的总个数，level计算每层节点的个数。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt;&gt; LO; if(root == NULL) return LO; queue&lt;TreeNode *&gt; node; node.push(root); int count = 1; int level = 0; vector&lt;int&gt; sub(0); while(!node.empty())&#123; sub.clear(); level = 0; for(int i = 0; i &lt; count; i++)&#123; root = node.front(); node.pop(); sub.push_back(root-&gt;val); if(root-&gt;left != NULL)&#123; node.push(root-&gt;left); ++level; &#125; if(root-&gt;right != NULL)&#123; node.push(root-&gt;right); ++level; &#125; &#125; count = level; LO.push_back(sub); &#125; return LO; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Binary Tree Preorder Traversal","slug":"Binary-Tree-Preorder-Traversal","date":"2018-11-15T16:35:34.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/d13d2726.html","link":"","permalink":"https://www.zuoyangblog.com/post/d13d2726.html","excerpt":"","text":"问题描述： Given a binary tree, return the preorder traversal of its nodes’ values. For example:Given binary tree {1,#,2,3}, 1​ \\​ 2​ / 3return [1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? 非递归实现，不过超时了。 123456789101112131415161718192021222324252627/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; pretr; if(root == NULL) return pretr; stack&lt;TreeNode *&gt; node; node.push(root); while(!node.empty())&#123; TreeNode *p = node.top(); pretr.push_back(p-&gt;val); node.pop(); if(p-&gt;right) node.push(p); if(p-&gt;left) node.push(p); &#125; return pretr; &#125;&#125;; 递归实现 1234567891011121314151617181920212223242526/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; pretr; process(root,pretr); return pretr; &#125; void process(TreeNode *root,vector&lt;int&gt; &amp;pretr)&#123; if(root == NULL) return; TreeNode *p; p = root; pretr.push_back(p-&gt;val); process(p-&gt;left,pretr); process(p-&gt;right,pretr); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Binary Tree Inorder Traversal","slug":"Binary-Tree-Inorder-Traversal","date":"2018-11-15T16:33:28.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/8a5e7d39.html","link":"","permalink":"https://www.zuoyangblog.com/post/8a5e7d39.html","excerpt":"","text":"问题描述： Given a binary tree, return the inorder traversal of its nodes’ values. For example:Given binary tree {1,#,2,3}, 1​ \\​ 2​ / 3return [1,3,2]. Note: Recursive solution is trivial, could you do it iteratively? confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ. 解决思路： 本想用栈去实现，但是这上面好像没有栈的定义，没办法只好用vector去解决了。 代码： 123456789101112131415161718192021222324252627282930313233/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; intr; if (root == NULL) return intr; vector&lt;TreeNode*&gt; node; TreeNode *p; p = root; while(p != NULL || !node.empty())&#123; if(p != NULL)&#123; node.push_back(p); p =p-&gt;left; &#125; else&#123; TreeNode *t = node.back(); node.pop_back(); intr.push_back(t-&gt;val); p = t-&gt;right; &#125; &#125; return intr; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Linked List Cycle","slug":"Linked-List-Cycle","date":"2018-11-15T16:20:05.000Z","updated":"2018-11-15T16:25:35.000Z","comments":true,"path":"post/c94099d8.html","link":"","permalink":"https://www.zuoyangblog.com/post/c94099d8.html","excerpt":"","text":"问题描述： Given a linked list, determine if it has a cycle in it. Follow up:Can you solve it without using extra space? 解决思路： 采用快慢指针的方法，快指针一次走两步，慢指针一次走一步，如果链表中有环的话，经过走一定的步数之后快慢指针一定会相遇的，当然如果没有环就需考虑循环结束的条件，这里主要要考虑快指针的情况即可。 代码： 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == NULL) return false; if(head-&gt;next == NULL) return false; ListNode *p,*q; p = head; q = head; while(p != NULL &amp;&amp; p-&gt;next != NULL) &#123; p = p-&gt;next-&gt;next; q = q-&gt;next; if(p == q) return true; &#125; return false; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"List","slug":"List","permalink":"https://www.zuoyangblog.com/tags/List/"}]},{"title":"Remove Duplicates from Sorted List","slug":"Remove-Duplicates-from-Sorted-List","date":"2018-11-15T16:18:19.000Z","updated":"2018-11-15T16:28:43.000Z","comments":true,"path":"post/1d8b65b1.html","link":"","permalink":"https://www.zuoyangblog.com/post/1d8b65b1.html","excerpt":"","text":"问题描述： Given a sorted linked list, delete all duplicates such that each element appear only once. For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 解决思路： 定义两个指针base和cmp,base指针指向被比较的结点，cmp指向base的后一个结点，由于链表是有序的，所以cmp找到第一个不等于base的结点之后，就分别将base和cmp后移。如果相等，只要将相等的结点删除即可。 代码: 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *deleteDuplicates(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *base,*cmp; base = head; cmp = base-&gt;next; while(cmp != NULL)&#123; ListNode *tmp; tmp = cmp-&gt;next; if(cmp-&gt;val == base-&gt;val)&#123; base-&gt;next = tmp; free(cmp); cmp = tmp; &#125; else&#123; base = cmp; cmp = tmp; &#125; &#125; return head; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"List","slug":"List","permalink":"https://www.zuoyangblog.com/tags/List/"}]},{"title":"ZigZag Conversion","slug":"ZigZag-Conversion","date":"2018-11-15T16:16:46.000Z","updated":"2018-11-15T16:25:35.000Z","comments":true,"path":"post/61984fa2.html","link":"","permalink":"https://www.zuoyangblog.com/post/61984fa2.html","excerpt":"","text":"问题描述： The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows);convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”. 解决思路： 找出规律即可，每次的周期为2nRows-2,但是在1到nRows-1的行数还需要判断周期为2（nRows-1-i）的元素，i是处于1到nRows-1的行数。 代码： 12345678910111213141516171819class Solution &#123;public: string convert(string s, int nRows) &#123; if(s.empty() || nRows &lt;= 1 || s.length() &lt; nRows) return s; string result; int cycle = 2 * nRows - 2; for(int i = 0; i &lt; nRows; i++)&#123; for(int j = i; j &lt; s.length(); j += cycle)&#123; result.push_back(s[j]); if( i &gt; 0 &amp;&amp; i &lt; nRows-1)&#123; if (j + 2 *(nRows - 1 - i) &lt; s.length()) result.push_back(s[j + 2 *(nRows - 1 - i)]); &#125; &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Balanced Binary Tree","slug":"Balanced-Binary-Tree","date":"2018-11-15T16:14:50.000Z","updated":"2018-11-15T16:28:07.000Z","comments":true,"path":"post/5c1c4dd0.html","link":"","permalink":"https://www.zuoyangblog.com/post/5c1c4dd0.html","excerpt":"","text":"问题描述： Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 解决思路： 首先设计一个求二叉树高度的函数，然后调用该函数比较左右子树的高度差即可。 123456789101112131415161718192021222324252627282930313233/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int height(TreeNode *root)&#123; if(root == NULL) return 0; int hr,hl; hl = height(root-&gt;left); hr = height(root-&gt;right); int h; h =1 + (hl &gt; hr ? hl : hr); return h; &#125; bool isBalanced(TreeNode *root) &#123; if(root == NULL) return true; int hl = height(root-&gt;left); int hr = height(root-&gt;right); int diff = hl - hr; if(diff &gt; 1 || diff &lt; -1) return false; return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Majority Element","slug":"Majority-Element","date":"2018-11-15T16:12:02.000Z","updated":"2018-11-15T16:14:30.000Z","comments":true,"path":"post/ed8e0613.html","link":"","permalink":"https://www.zuoyangblog.com/post/ed8e0613.html","excerpt":"","text":"问题描述： Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 解决思路： 这是一个求解数组主元素的题目，数组的主元素是指数组中出现次数超过一半的元素。此题是假设数组非空并且主元素存在，所以比较简单。主元素总会比其他元素多，我们设置两个变量maj_index用于记录主元素的位置，count用于记录主元素出现的次数，然后一次比较数组元素，如果相同则count加1，不同则减1，若count为零，则替换maj_index，并将count置为1. 代码： 12345678910111213141516171819class Solution &#123;public: int majorityElement(vector&lt;int&gt; &amp;num) &#123; int maj_index,count; maj_index = 0; count = 1; for(int i =1; i &lt; num.size(); i++)&#123; if (num[i] == num[maj_index]) count ++; else count --; if (count == 0)&#123; maj_index = i; count = 1; &#125; &#125; return num[maj_index]; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Intersection of Two Linked Lists","slug":"Intersection-of-Two-Linked-Lists","date":"2018-11-15T16:09:39.000Z","updated":"2018-11-15T16:28:26.000Z","comments":true,"path":"post/42870ae4.html","link":"","permalink":"https://www.zuoyangblog.com/post/42870ae4.html","excerpt":"","text":"问题描述： For example, the following two linked lists: A: a1 → a2​ ↘​ c1 → c2 → c3​ ↗B: b1 → b2 → b3begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null.The linked lists must retain their original structure after the function returns.You may assume there are no cycles anywhere in the entire linked structure.Your code should preferably run in O(n) time and use only O(1) memory. 解决思路： 这题要求的时间复杂度是O(n)和空间复杂度O(1)，所以只能用以下方法解决：(1)首先分别求出两个单链表的长度lenA和lenB；(2)求出两个链表的长度差，然后将长链表的比较位置移到长度差的位置，因为这些位置上的两个链表的元素是肯定不相同的；(3)此时，两个链表的长度一致，在分别依次比较元素即可 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if(headA == NULL || headB == NULL) return NULL; int lenA,lenB; lenA = 0,lenB = 0; ListNode *p,*q; for(p = headA;p != NULL;p=p-&gt;next) lenA ++; for(q = headB;q != NULL;q=q-&gt;next) lenB ++; int diff = abs(lenB-lenA); if(lenA &gt; lenB)&#123; p = headA; for(int i = 0;i &lt; diff;i++) p = p-&gt;next; q = headB; while(p != NULL &amp;&amp; q != NULL)&#123; if(p-&gt;val == q-&gt;val) return p; else&#123; p = p-&gt;next; q = q-&gt;next; &#125; &#125; return NULL; &#125; else&#123; p = headB; for(int i = 0;i &lt; diff;i++) p = p-&gt;next; q = headA; while(p != NULL &amp;&amp; q != NULL)&#123; if(p-&gt;val == q-&gt;val) return p; else&#123; p = p-&gt;next; q = q-&gt;next; &#125; &#125; return NULL; &#125; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"List","slug":"List","permalink":"https://www.zuoyangblog.com/tags/List/"}]},{"title":"Palindrome Number","slug":"Palindrome-Number","date":"2018-11-15T16:06:52.000Z","updated":"2018-11-15T16:14:30.000Z","comments":true,"path":"post/b216f26b.html","link":"","permalink":"https://www.zuoyangblog.com/post/b216f26b.html","excerpt":"","text":"问题描述： Determine whether an integer is a palindrome. Do this without extra space. click to show spoilers. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 解决思路： 这里要求不能使用额外的空间，基本思路是首先求出数据的位数，然后编写一个函数能够求出每一位的数字，然后遍历比较即可。 代码1： 123456789101112131415161718192021222324class Solution &#123;public: bool isPalindrome(int x) &#123; if (x &lt; 0) return false; int num = 0; int y = x; while( y != 0)&#123; num ++; y /= 10; &#125; int i,j; for(i = 1, j = num; i &lt; j;i++,j--)&#123; if (search(x,num,i) != search(x,num,j)) return false; &#125; return true; &#125; int search(int x,int n,int index)&#123; int d = pow(10,n-index); int y = x/d; return y%10; &#125;&#125;; 代码2： 123456789101112131415161718class Solution &#123;public: bool isPalindrome(int x) &#123; if (x &lt; 0) return false; int z = x; int y = 0; while( x != 0)&#123; y *= 10; y += x%10; x /= 10; &#125; if(z == y) return true; else return false; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Excel Sheet Column Number","slug":"Excel-Sheet-Column-Number","date":"2018-11-15T16:03:44.000Z","updated":"2018-11-15T16:14:30.000Z","comments":true,"path":"post/50445eba.html","link":"","permalink":"https://www.zuoyangblog.com/post/50445eba.html","excerpt":"","text":"问题描述： Related to question Excel Sheet Column Title Given a column title as appear in an Excel sheet, return its corresponding column number. For example: 1234567A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 解决思路： 本题类似于进制转换，将一个字符串转化为一个十进制的数字，而要求的字符串可以看作是一个26进制的数字。 代码： 12345678910111213class Solution &#123;public: int titleToNumber(string s) &#123; if(s.empty()) return 0; int n = 0; for(int i = 0; i &lt; s.length()-1; i ++)&#123; n = (int(s[i]-'A')+1+n) * 26; &#125; n += int(s[s.length()-1]-'A')+1; return n; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"2Sum","slug":"2Sum","date":"2018-11-15T15:50:54.000Z","updated":"2018-11-16T08:53:36.000Z","comments":true,"path":"post/74d7ef89.html","link":"","permalink":"https://www.zuoyangblog.com/post/74d7ef89.html","excerpt":"","text":"问题描述： Given an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 解决思路： 本题主要是在给定的一个数组中找到两个数的下标，使得这个两个数和为给定的值，要求给出的下标从1 开始，且满足递增顺序，有三种解决方法，复杂度分别为O(n^2),O(nlogn),O(n),具体实现如下： 复杂度为O(n^2) 代码： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; // Start typing your C/C++ solution below // DO NOT write int main() function vector&lt;int&gt; ret(2, 0); int len = numbers.size(); for(int i = 0; i &lt; len; i++) &#123; int tmp = target - numbers[i]; // another number for(int j = i + 1; j &lt; len; j++) &#123; if(tmp == numbers[j]) &#123; ret[0] = i + 1; // +1 for not zero-based ret[1] = j + 1; return ret; &#125; &#125; &#125; return ret; &#125;&#125;; 复杂度O(nlogn)代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; vector&lt;int&gt; index; int len = numbers.size(); vector&lt;int&gt; bak = numbers; sort(bak.begin(),bak.end()); int l = 0,r = len-1; int sum = 0; while(l &lt; r)&#123; sum = bak[l]+bak[r]; if(sum == target) &#123; for(int i = 0; i &lt; len;i++) &#123; if (bak[l] == numbers[i]) &#123; index.push_back(i+1); &#125; else if(bak[r] == numbers[i]) &#123; index.push_back(i+1); &#125; if(index.size() == 2) &#123; break; &#125; &#125; break; &#125; else if(sum &lt; target) &#123; ++l; &#125; else &#123; --r; &#125; &#125; return index; &#125;&#125;; 复杂度O(n)代码: 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; int len = numbers.size(); assert(len &gt;= 2); vector&lt;int&gt; ret(2, 0); map&lt;int, int&gt; mapping; // default all are 0 vector&lt;long long&gt; mul(len, 0); for(int i = 0; i &lt; len; i++)&#123; mul[i] = (target - numbers[i]) * numbers[i]; if(mapping[mul[i]] &gt; 0)&#123; // not default 0 if(numbers[i] + numbers[mapping[mul[i]] - 1] == target)&#123; ret[0] = mapping[mul[i]]; ret[1] = i + 1; break; &#125; &#125; else &#123; mapping[mul[i]] = i + 1; // larger than 0 &#125; &#125; return ret; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"3Sum","slug":"3Sum","date":"2018-11-15T15:50:50.000Z","updated":"2018-11-15T16:28:12.000Z","comments":true,"path":"post/cc6b88ec.html","link":"","permalink":"https://www.zuoyangblog.com/post/cc6b88ec.html","excerpt":"","text":"问题描述： Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)The solution set must not contain duplicate triplets.​ For example, given array S = {-1 0 1 2 -1 -4}, A solution set is: (-1, 0, 1) (-1, -1, 2) 解决思路： 3sum的时候，先整体排一次序，然后枚举第三个数字的时候不需要重复， 比如排好序以后的数字是 a b c d e f, 那么第一次枚举a, 在剩下的b c d e f中进行2 sum, 完了以后第二次枚举b, 只需要在 c d e f中进行2sum好了，而不是在a c d e f中进行2sum, 这个大家可以自己体会一下，想通了还是挺有帮助的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123; sort(num.begin(),num.end()); int len = num.size(); vector&lt;vector&lt;int&gt;&gt; result; if(len &lt; 3) return result; int iCount = len - 2; vector&lt;int&gt; truple(3,0); int CurrentVal = num[0]; for(int i = 0; i &lt; iCount;i++) &#123; if(i &amp;&amp; num[i] == CurrentVal) &#123; continue; &#125; truple[0] = num[i]; int l = i + 1; int r = len - 1; while(l&lt;r) &#123; int iSum = num[l] + num[r]; if(iSum + truple[0] == 0) &#123; truple[1] = num[l]; truple[2] = num[r]; if(result.size() == 0 || truple != result[result.size()-1]) result.push_back(truple); ++l; --r; &#125; else if(iSum + truple[0] &lt; 0) &#123; ++l; &#125; else &#123; --r; &#125; &#125; CurrentVal = num[i]; &#125; return result; &#125; &#125;; 这是一篇关于kSum问题的总结性文章。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"3Sum Closest","slug":"3Sum-Closest","date":"2018-11-15T15:44:35.000Z","updated":"2018-11-15T16:28:11.000Z","comments":true,"path":"post/c85f0a37.html","link":"","permalink":"https://www.zuoyangblog.com/post/c85f0a37.html","excerpt":"","text":"问题描述： Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. For example, given array S = {-1 2 1 -4}, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 解决思路： 我们可以在 2sum问题 的基础上来解决3sum问题，假设3sum问题的目标是target。每次从数组中选出一个数k，从剩下的数中求目标等于target-k的2sum问题。这里需要注意的是有个小的trick：当我们从数组中选出第i数时，我们只需要求数值中从第i+1个到最后一个范围内字数组的2sum问题。我们以选第一个和第二个举例，假设数组为A[],总共有n个元素A1，A2….An。很显然，当选出A1时，我们在子数组[A2~An]中求目标位target-A1的2sum问题，我们要证明的是当选出A2时，我们只需要在子数组[A3~An]中计算目标位target-A2的2sum问题，而不是在子数组[A1,A3~An]中，证明如下：假设在子数组[A1,A3~An]目标位target-A2的2sum问题中，存在A1 + m = target-A2（m为A3~An中的某个数），即A2 + m = target-A1，这刚好是“对于子数组[A3~An],目标位target-A1的2sum问题”的一个解。即我们相当于对满足3sum的三个数A1+A2+m = target重复计算了。因此为了避免重复计算，在子数组[A1，A3~An]中，可以把A1去掉，再来计算目标是target-A2的2sum问题。 对于本题要求的求最接近解，只需要保存当前解以及当前解和目标的距离，如果新的解更接近，则更新解。算法复杂度为O（n^2）;注意：我们这里是求的和是一个非确定性的数，因此2sum问题的hashtable解法就不适合这里了 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: int threeSumClosest(vector&lt;int&gt; &amp;num, int target) &#123; int n = num.size(); sort(num.begin(),num.end()); int res,dis=INT_MAX; for(int i = 0;i&lt;n-2;i++) &#123; int target2 = target - num[i]; int tmpdis; int tmpres = twoSumClosest(num,i+1,target2); if((tmpdis = abs(tmpres-target2)) &lt; dis) &#123; res = tmpres + num[i]; dis = tmpdis; if(res == target) return res; &#125; &#125; return res; &#125; int twoSumClosest(vector&lt;int&gt; &amp;sortnum,int start,int target)&#123; int res,dis=INT_MAX; int l = start,r = sortnum.size()-1; while(l&lt;r) &#123; int sum = sortnum[l]+sortnum[r]; if(sum &lt; target) &#123; if(target-sum &lt; dis) &#123; res = sum; dis = target - sum; &#125; ++l; &#125; else if(sum &gt; target) &#123; if(sum - target &lt; dis) &#123; res = sum; dis = sum - target; &#125; --r; &#125; else return target; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"4Sum","slug":"4Sum","date":"2018-11-15T15:44:12.000Z","updated":"2018-11-15T16:28:10.000Z","comments":true,"path":"post/51bcb055.html","link":"","permalink":"https://www.zuoyangblog.com/post/51bcb055.html","excerpt":"","text":"问题描述Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: 12345[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 算法1：O(n^3) 我们可以仿照3sum的解决方法。这里枚举第一个和第二个数，然后对余下数的求2sum，算法复杂度为O（n^3） 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target) &#123; int n = num.size(); sort(num.begin(),num.end()); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; quard(4,0); for(int i = 0; i &lt; n-3; i++) &#123; if(i &gt; 0 &amp;&amp; num[i] == num[i-1]) continue; for(int j = i + 1; j &lt; n -2; j++) &#123; if(j &gt; i+1 &amp;&amp; num[j] == num[j-1]) continue; int l = j+1,r=n-1; int target2 = target - num[i] - num[j]; while(l&lt;r) &#123; int sum = num[l] + num[r]; if(sum &lt; target2) &#123; ++l; &#125; else if(sum &gt; target2) &#123; --r; &#125; else &#123; quard[0] = num[i]; quard[1] = num[j]; quard[2] = num[l]; quard[3] = num[r]; res.push_back(quard); int k = l + 1; while(k &lt; r &amp;&amp; num[k] == num[l])k++; l = k; k = r-1; while(k &gt; l &amp;&amp; num[k] == num[r])k--; r = k; &#125; &#125; &#125; &#125; return res; &#125;&#125;; 算法2：O（n^2）的算法 和前面相同，都是先对数组排序。我们先枚举出所有二个数的和存放在哈希map中，其中map的key对应的是二个数的和，因为多对元素求和可能是相同的值，故哈希map的value是一个链表（下面的代码中用数组代替），链表每个节点存的是这两个数在数组的下标；这个预处理的时间复杂度是O（n^2）。接着和算法1类似，枚举第一个和第二个元素，假设分别为v1,v2, 然后在哈希map中查找和为target-v1-v2的所有二元对（在对应的链表中），查找的时间为O（1），为了保证不重复计算，我们只保留两个数下标都大于V2的二元对（其实我们在前面3sum问题中所求得的三个数在排序后的数组中下标都是递增的），即时是这样也有可能重复：比如排好序后数组为-9 -4 -2 0 2 4 4，target = 0，当第一个和第二个元素分别是-4，-2时，我们要得到和为0-（-2）-（-4） = 6的二元对，这样的二元对有两个,都是(2,4)，且他们在数组中的下标都大于-4和-2，如果都加入结果，则(-4,-2,2,4)会出现两次，因此在加入二元对时，要判断是否和已经加入的二元对重复（由于过早二元对之前数组已经排过序，所以两个元素都相同的二元对可以保证在链表中是相邻的，链表不会出现(2,4)-&gt;(1,5)-&gt;(2,4)的情况，因此只要判断新加入的二元对和上一个加入的二元对是否重复即可），因为同一个链表中的二元对两个元素的和都是相同的，因此只要二元对的一个元素不同，则这个二元对就不同。我们可以认为哈希map中key对应的链表长度为常数，那么算法总的复杂度为O（n^2） 代码： 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target) &#123; int n = num.size(); vector&lt;vector&lt;int&gt; &gt; res; unordered_map&lt;int, vector&lt;pair&lt;int, int&gt; &gt; &gt;pairs; pairs.reserve(n*n); sort(num.begin(), num.end()); for(int i = 0; i &lt; n; i++) for(int j = i+1 ; j &lt; n; j++) pairs[num[i]+num[j]].push_back(make_pair(i,j)); for(int i = 0; i &lt; n - 3; i++) &#123; if(i != 0 &amp;&amp; num[i] == num[i-1])continue;//防止第一个元素重复 for(int j = i+1; j &lt; n - 2; j++) &#123; if(j != i+1 &amp;&amp; num[j] == num[j-1])continue;//防止第二个元素重复 if(pairs.find(target - num[i] - num[j]) != pairs.end()) &#123; vector&lt;pair&lt;int, int&gt;&gt; &amp;sum2 = pairs[target - num[i] - num[j]]; bool isFirstPush = true; for(int k = 0; k &lt; sum2.size(); k++) &#123; if(sum2[k].first &lt;= j)continue;//保证所求的四元组的数组下标是递增的 if(isFirstPush || (res.back())[2] != num[sum2[k].first]) &#123; res.push_back(vector&lt;int&gt;&#123;num[i], num[j], num[sum2[k].first], num[sum2[k].second]&#125;); isFirstPush = false; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"有效的括号序列","slug":"有效的括号序列","date":"2018-11-15T15:41:20.000Z","updated":"2018-11-15T16:28:04.000Z","comments":true,"path":"post/cf94e2fe.html","link":"","permalink":"https://www.zuoyangblog.com/post/cf94e2fe.html","excerpt":"","text":"问题描述： 给定一个字符串所表示的括号序列，包含以下字符： &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;， 判定是否是有效的括号序列。 样例 括号必须依照 &quot;()&quot; 顺序表示， &quot;()[]{}&quot; 是有效的括号，但 &quot;([)]&quot;则是无效的括号。 解题思路：使用栈 代码： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: /** * @param s A string * @return whether the string is a valid parentheses */ bool isMatch(char a, char b) &#123; if(a == '(' &amp;&amp; b == ')') return true; if(a == '[' &amp;&amp; b == ']') return true; if(a == '&#123;' &amp;&amp; b == '&#125;') return true; return false; &#125; bool isValidParentheses(string&amp; s) &#123; // Write your code here int n = s.length(); if(n &lt; 1) return true; if(n % 2) return false; stack&lt;char&gt; paren; paren.push(s[0]); int i = 1; while(i &lt; n) &#123; if(!paren.empty() &amp;&amp; isMatch(paren.top(),s[i])) paren.pop(); else paren.push(s[i]); i++; &#125; if(!paren.empty()) return false; else return true; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Stack","slug":"Stack","permalink":"https://www.zuoyangblog.com/tags/Stack/"}]},{"title":"岛屿个数","slug":"岛屿个数","date":"2018-11-15T15:36:58.000Z","updated":"2018-11-15T16:28:09.000Z","comments":true,"path":"post/cc03a9fe.html","link":"","permalink":"https://www.zuoyangblog.com/post/cc03a9fe.html","excerpt":"","text":"问题描述： 给一个0,1矩阵，求不同的岛屿的个数。 0代表海，1代表岛，如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。 样例 在矩阵： 1234567[ [1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1]] 中有 3 个岛. 解题思路：深度遍历 dfs 代码： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: /** * @param grid a boolean 2D matrix * @return an integer */ int step[4][2] = &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;; int numIslands(vector&lt;vector&lt;bool&gt;&gt;&amp; grid) &#123; // Write your code here int n = grid.size(); if(n &lt; 1) return 0; int m = grid[0].size(); int count = 0; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(grid[i][j] == true)&#123; dfs(grid,i,j); count++; &#125; &#125; &#125; return count; &#125; void dfs(vector&lt;vector&lt;bool&gt;&gt;&amp; grid, int i, int j)&#123; grid[i][j] = false; for(int k = 0; k &lt; 4; k++)&#123; int x = step[k][0] + i; int y = step[k][1] + j; if(x &gt;= 0 &amp;&amp; x &lt; grid.size() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; grid[0].size() &amp;&amp; grid[x][y] == true)&#123; dfs(grid,x,y); &#125; &#125; return; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"DFS","slug":"DFS","permalink":"https://www.zuoyangblog.com/tags/DFS/"}]},{"title":"最后一个单词的长度","slug":"最后一个单词的长度","date":"2018-11-15T15:19:54.000Z","updated":"2018-11-15T16:28:05.000Z","comments":true,"path":"post/f055ffc7.html","link":"","permalink":"https://www.zuoyangblog.com/post/f055ffc7.html","excerpt":"","text":"问题描述： 给定一个字符串， 包含大小写字母、空格&#39; &#39;，请返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 样例： 给定 s = &quot;Hello World&quot;，返回 5。 代码： 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: /** * @param s A string * @return the length of last word */ int lengthOfLastWord(string&amp; s) &#123; // Write your code here int n = s.length(); int len = 0; if(n &lt; 1) return 0; int i = n - 1; while(i &gt;= 0) &#123; if(s[i] == ' ') i--; else break; &#125; if(i &gt;= 0) &#123; while(s[i] != ' ' &amp;&amp; i &gt;= 0) &#123; len++; i--; &#125; return len; &#125; else return len; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"String","slug":"String","permalink":"https://www.zuoyangblog.com/tags/String/"}]},{"title":"手动部署ceph集群","slug":"manual-deploy-ceph","date":"2018-11-15T07:54:19.000Z","updated":"2018-11-15T14:56:49.000Z","comments":true,"path":"post/c3d7e91e.html","link":"","permalink":"https://www.zuoyangblog.com/post/c3d7e91e.html","excerpt":"","text":"1、机器选择1.1 系统要求ceph 最新 LTS 版本 (luminous) 推荐 linux 内核版本 4.1.4 及以上, 最低版本要求 3.10.*。 1.2 服务器这里选择三台服务器来部署ceph集群，一台Mon+五台OSD 节点 服务 cluster network public network 192.168.226.20 osd.1,mon.node2 192.168.226.0/24 192.168.226.0/24 192.168.226.21 osd.4 192.168.226.0/24 192.168.226.0/24 192.168.226.22 osd.2, mon.node1 192.168.226.0/24 192.168.226.0/24 192.168.226.96 osd.3,mon.node3 192.168.226.0/24 192.168.226.0/24 192.168.226.106 osd.0 192.168.226.0/24 192.168.226.0/24 每个节点只能使用1块磁盘部署osd。所以，集群共有5个osd进程，3个monitor进程。 cluster network 是处理osd间的数据复制，数据重平衡，osd进程心跳检测的网络，其不对外提供服务，只在各个osd节点间通信，本文使用eth1网卡作为cluster network，三个节点网卡eth1桥接到同一个网桥br1上 2、环境配置配置每个节点的host文件，在 /etc/hosts文件中添加如下内容： 123192.168.226.20 ceph-1192.168.226.22 ceph-2192.168.226.96 ceph-3 2.2 ceph节点安装你的管理节点必须能够通过 SSH 无密码地访问各 Ceph 节点。如果 ceph-deploy 以某个普通用户登录，那么这个用户必须有无密码使用 sudo 的权限。 2.2.1 安装 NTP我们建议在所有 Ceph 节点上安装 NTP 服务（特别是 Ceph Monitor 节点），以免因时钟漂移导致故障，详情见时钟。 1sudo yum install ntp ntpdate ntp-doc 确保在各 Ceph 节点上启动了 NTP 服务，并且要使用同一个 NTP 服务器，详情见 NTP 。 2.2.2 安装 SSH 服务器在所有 Ceph 节点上执行如下步骤： 在各 Ceph 节点安装 SSH 服务器（如果还没有） 1sudo yum install openssh-server 确保所有 Ceph 节点上的 SSH 服务器都在运行。 2.2.3 安装ceph由于蚂蚁内部物理机不能访问外网，使用以下步骤安装ceph。 在所有Ceph节点上执行如下步骤： 下载ceph所有的依赖rpm，并解压缩 12sudo wget http://qianli-lzh.oss-cn-hangzhou-zmf.aliyuncs.com/bill_inference_public%2Fceph.tarsudo tar -xvf bill_inference_public%2Fceph.tar 手动安装所有的rpm 1sudo rpm -ivh --force --nodeps ceph/*.rpm 验证ceph是否正确安装 12ceph -vceph version 12.2.8 (ae699615bac534ea496ee965ac6192cb7e0e07c0) luminous (stable) 2.2.4 关闭防火墙1234sudo sed -i 's/SELINUX=.*/SELINUX=disabled/' /etc/selinux/configsudo setenforce 0sudo systemctl stop firewalld sudo systemctl disable firewalld 3、集群搭建3.1 搭建Mon集群 (使用admin账户)创建配置文件 在每台节点机器上创建配置文件/etc/ceph/ceph.conf： 123456789101112131415161718192021222324252627[global]fsid = 932XXXXX-fba7-XXXX-9526-a858c613f468mon initial members = e15p13447.ew9mon host = 192.168.226.20,192.168.226.22,192.168.226.96rbd default features = 1auth_cluster_required = noneauth_service_required = noneauth_client_required = nonepublic network = 192.168.226.0/24cluster network = 192.168.226.0/24osd journal size = 1024osd pool default size = 2osd pool default min size = 1osd pool default pg num = 128osd pool default pgp num = 128osd crush chooseleaf type = 1mon_max_pg_per_osd = 200[mds.ceph-1]host = ceph-1[mds.ceph-2]host = ceph-2[mds.ceph-3]host = ceph-3[mon]mon allow pool delete = true 其中 fsid 是为集群分配的一个 uuid, 初始化 mon 节点其实只需要这一个配置就够了。mon host 配置 ceph 命令行工具访问操作 ceph 集群时查找 mon 节点入口。ceph 集群可包含多个 mon 节点实现高可用容灾, 避免单点故障。rbd default features = 1 配置 rbd 客户端创建磁盘时禁用一些需要高版本内核才能支持的特性。 3.1.2 主mon节点 （192.168.226.20）1、为此集群创建密钥环、并生成Monitor密钥 (3台机器一样) 1sudo ceph-authtool --create-keyring /tmp/ceph.mon.keyring --gen-key -n mon. --cap mon 'allow *' 2、生成管理员密钥环，生成 client.admin 用户并加入密钥环 (3台机器一样) 1sudo ceph-authtool --create-keyring /etc/ceph/ceph.client.admin.keyring --gen-key -n client.admin --set-uid=0 --cap mon 'allow *' --cap osd 'allow *' --cap mds 'allow *' --cap mgr 'allow *' 3、把 client.admin 密钥加入 ceph.mon.keyring (3台机器一样) 1sudo ceph-authtool /tmp/ceph.mon.keyring --import-keyring /etc/ceph/ceph.client.admin.keyring 4、用规划好的主机名、对应 IP 地址、和 FSID 生成一个Monitor Map，并保存为 /tmp/monmap 12host_name=`hostname`sudo monmaptool --create --add $host_name 192.168.226.20 --fsid 932XXXXX-fba7-XXXX-9526-a858c613f468 /tmp/monmap --clobber 5、在Monitor主机上分别创建数据目录 123host_name=`hostname`#在admin账户下sudo mkdir /var/lib/ceph/mon/ceph-$host_name/ 6、用Monitor Map和密钥环组装守护进程所需的初始数据 1sudo ceph-mon --mkfs -i $host_name --monmap /tmp/monmap --keyring /tmp/ceph.mon.keyring 7、建一个空文件 done ，表示监视器已创建、可以启动了 1sudo touch /var/lib/ceph/mon/ceph-$host_name/done 8、启动Monitor 1234#sudo ceph-mon -f --cluster ceph --id $host_name &amp;sudo cp /usr/lib/systemd/system/ceph-mon@.service /usr/lib/systemd/system/ceph-mon@$host_name.servicesudo systemctl start ceph-mon@$host_namesudo systemctl enable ceph-mon@$host_name 9、确认下集群在运行 1ceph -s 事例： 1234567891011121314cluster: id: 932XXXXX-fba7-XXXX-9526-a858c613f468 health: HEALTH_OK services: mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3 mgr: no daemons active osd: 0 osds: 0 up, 0 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0B usage: 0B used, 0B / 0B avail pgs: 3.1.2 从mon节点 (192.168.226.22 &amp; 192.168.226.96)12345678910host_name=`hostname`sudo ceph mon getmap -o /tmp/monmapsudo rm -rf /var/lib/ceph/mon/ceph-$host_namesudo ceph-mon -i $host_name --mkfs --monmap /tmp/monmapsudo chown -R ceph:ceph /var/lib/ceph/mon/ceph-$host_name/#nohup ceph-mon -f --cluster ceph --id $host_name --setuser ceph --setgroup ceph &amp;#ceph-mon -f --cluster ceph --id $host_name &amp;sudo cp /usr/lib/systemd/system/ceph-mon@.service /usr/lib/systemd/system/ceph-mon@$host_name.servicesudo systemctl start ceph-mon@$host_namesudo systemctl enable ceph-mon@$host_name 3.2 创建ceph-mgr3.2.1 创建用户 openstack 用于 MGR 监控1234ceph auth get-or-create mgr.openstack mon 'allow *' osd 'allow *' mds 'allow *'输出：[mgr.openstack] key = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxugvXkLfgauLA== 需要将之前创建的用户密码存放至对应位置 123mkdir /var/lib/ceph/mgr/ceph-openstackceph auth get mgr.openstack -o /var/lib/ceph/mgr/ceph-openstack/keyringexported keyring for mgr.openstack 3.2.2 启动mgr1ceph-mgr -i openstack 监控状态 12345678910111213141516$ceph -s cluster: id: 932e88a6-fba7-45a9-9526-a858c613f468 health: HEALTH_OK services: mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3 mgr: openstack(active) mds: cephfs-1/1/1 up &#123;0=2=up:active&#125;, 2 up:standby osd: 3 osds: 3 up, 3 in data: pools: 2 pools, 256 pgs objects: 21 objects, 3.04KiB usage: 3.32GiB used, 1.17TiB / 1.17TiB avail pgs: 256 active+clean 当 mgr 服务被激活之后, service 中 mgr 会显示 mgr-$name(active)data 部分信息将变得可用 3.3 手动搭建osd集群(三台机器上做相同的操作，注意osd_id的变化)添加一个新osd，id可以省略，ceph会自动使用最小可用整数，第一个osd从0开始 123#ceph osd create &#123;id&#125;ceph osd create0 3.3.1 初始化osd目录创建osd.0目录，目录名格式{cluster-name}-{id} 12#mkdir /var/lib/ceph/osd/&#123;cluster-name&#125;-&#123;id&#125;sudo mkdir /var/lib/ceph/osd/ceph-0 挂载osd.0的数据盘/dev/sdb2 12sudo mkfs.xfs /dev/sdb2sudo mount /dev/sdb2 /var/lib/ceph/osd/ceph-0 初始化osd数据目录 1234# sudo ceph-osd -i &#123;id&#125; --mkfs --mkkeysudo ceph-osd -i 0 --mkfs --mkkey#--mkkey要求osd数据目录为空#这会创建osd.0的keyring /var/lib/ceph/osd/ceph-0/keyring 初始化后，默认使用普通文件/var/lib/ceph/osd/ceph-3/journal作为osd.0的journal分区，普通文件作为journal分区性能不高，若只是测试环境，可以跳过更改journal分区这一步骤 3.3.2 创建journal生成journal分区，一般选ssd盘作为journal分区，这里使用ssd的/dev/sdb1分区作为journal 使用fdisk工分出磁盘/dev/sdb1, 1234567891011121314151617181920#清除磁盘所有分区(重新添加时需要)#sgdisk --zap-all --clear --mbrtogpt /dev/sdb#生成分区/dev/sdb1的uuid#uuidgen#b3897364-8807-48eb-9905-e2c8400d0cd4#创建分区#1:0:+100G 表示创建第一个分区，100G大小#sudo sgdisk --new=1:0:+100G --change-name=1:'ceph journal' --partition-guid=1:b3897364-8807-48eb-9905-e2c8400d0cd4 --typecode=1:b3897364-8807-48eb-9905-e2c8400d0cd4 --mbrtogpt -- /dev/vdf#格式化sudo mkfs.xfs /dev/sdb1sudo rm -f /var/lib/ceph/osd/ceph-4/journal #查看分区对应的partuuid， 找出/dev/sdb1对应的partuuidsudo blkidsudo ln -s /dev/disk/by-partuuid/b3897364-8807-48eb-9905-e2c8400d0cd4 /var/lib/ceph/osd/ceph-0/journalsudo chown ceph:ceph -R /var/lib/ceph/osd/ceph-0sudo chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal#初始化新的journalsudo ceph-osd --mkjournal -i 0sudo chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal 3.3.3 注册osd.{id}，id为osd编号，默认从0开始123# sudo ceph auth add osd.&#123;id&#125; osd 'allow *' mon 'allow profile osd' -i /var/lib/ceph/osd/ceph-&#123;id&#125;/keyringsudo ceph auth add osd.0 osd 'allow *' mon 'allow profile osd' -i /var/lib/ceph/osd/ceph-0/keyring#ceph auth list 中出现osd.0 3.3.4 加入crush map这是m1上新创建的第一个osd，CRUSH map中还没有m1节点，因此首先要把m1节点加入CRUSH map，同理，m2/m3节点也需要加入CRUSH map 12#ceph osd crush add-bucket &#123;hostname&#125; hostsudo ceph osd crush add-bucket `hostname` host 然后把三个节点移动到默认的root default下面 1sudo ceph osd crush move `hostname` root=default 添加osd.0到CRUSH map中的m1节点下面，加入后，osd.0就能够接收数据 123#ceph osd crush add osd.&#123;id&#125; 0.4 root=sata rack=sata-rack01 host=sata-node5sudo ceph osd crush add osd.4 1.7 root=default host=`hostname`#0.4为此osd在CRUSH map中的权重值，它表示数据落在此osd上的比重，是一个相对值，一般按照1T磁盘比重值为1来计算，这里的osd数据盘1.7，所以值为1.7 此时osd.0状态是down且in，in表示此osd位于CRUSH map，已经准备好接受数据，down表示osd进程运行异常，因为我们还没有启动osd.0进程 3.3.5 启动ceph-osd进程需要向systemctl传递osd的id以启动指定的osd进程，如下，我们准备启动osd.0进程 12345#systemctl start ceph-osd@&#123;id&#125; id表示osd编号，从数字0开始sudo cp /usr/lib/systemd/system/ceph-osd@.service /usr/lib/systemd/system/ceph-osd@0.servicesudo systemctl start ceph-osd@0sudo systemctl enable ceph-osd@0#sudo ceph-osd -i 0 上面就是添加osd.0的步骤，然后可以接着在其他hostname节点上添加osd.{1,2}，添加了这3个osd后，可以查看集群状态 ceph -s。 3.4 搭建MDS创建目录： 12sudo mkdir /var/lib/ceph/mds/ceph-`hostname`sudo chown ceph:ceph -R /var/lib/ceph/mds/ceph-`hostname` 在ceph.conf中添加如下信息： 12345[mds.&#123;id&#125;]host = &#123;id&#125;例如：[mds.0]host = 0 启动mds 12345#ceph-mds --cluster &#123;cluster-name&#125; -i &#123;id&#125; -m &#123;mon-hostname&#125;:&#123;mon-port&#125; [-f]sudo cp /usr/lib/systemd/system/ceph-mds@.service /usr/lib/systemd/system/ceph-mds@`hostname`.service sudo systemctl start ceph-mds@`hostname`sudo systemctl enable ceph-mds@`hostname`#ceph-mds --cluster ceph -i 0 -m e15p13447.ew9:6789 查看mds状态 12ceph mds statcephfs-1/1/1 up &#123;0=1=up:active&#125;, 2 up:standby 至此ceph集群搭建完成。","categories":[{"name":"ceph","slug":"ceph","permalink":"https://www.zuoyangblog.com/categories/ceph/"}],"tags":[{"name":"ceph","slug":"ceph","permalink":"https://www.zuoyangblog.com/tags/ceph/"}]}]}