{"meta":{"title":"zuoyang's blog","subtitle":null,"description":"welcome to my blog","author":"zuoyang","url":"https://www.zuoyangblog.com"},"pages":[{"title":"","date":"2018-11-15T14:56:49.000Z","updated":"2018-11-15T14:56:49.000Z","comments":true,"path":"about/index.html","permalink":"https://www.zuoyangblog.com/about/index.html","excerpt":"","text":"hi,大家好！欢迎大家来到我的blog，希望以后能跟各位大佬一起学习进步。 我叫左杨，目前就职于蚂蚁金服人工智能部，从事于蚂蚁人工智能相关的开发工作，对Machine Learning，Deep Learning比较感兴趣。"},{"title":"Categories","date":"2018-11-15T14:56:49.000Z","updated":"2018-11-15T14:56:49.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.zuoyangblog.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-15T14:56:49.000Z","updated":"2018-11-15T14:56:49.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.zuoyangblog.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"第四篇：创建cephfs服务","slug":"create-cephfs","date":"2018-11-23T04:06:35.000Z","updated":"2018-11-23T08:06:09.000Z","comments":true,"path":"post/4a310db5.html","link":"","permalink":"https://www.zuoyangblog.com/post/4a310db5.html","excerpt":"","text":"基于上一篇，我们搭建好了一个健康的ceph集群： 3个mon节点组成的mon集群 9个osd节点组成的osd集群 3个mgr节点(ceph luminous版本才有的) 3个mds服务(cephfs使用) 123456789101112131415[root@ceph-1 ceph]# ceph -s cluster: id: c165f9d0-88df-48a7-8cc5-11da82f99c93 health: HEALTH_OK services: mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3 mgr: ceph-1(active), standbys: admin, ceph-2, ceph-3 osd: 9 osds: 9 up, 9 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0B usage: 965MiB used, 18.0TiB / 18.0TiB avail pgs: 本篇主要讲如何基于ceph集群搭建cephfs服务。 cephFS简介 The Ceph Filesystem (Ceph FS) is a POSIX-compliant filesystem that uses a Ceph Storage Cluster to store its data. Ceph文件系统（CephFS）提供符合POSIX标准的文件系统作为服务，该服务在基于对象的Ceph存储集群之上。 CephFS文件被映射到Ceph存储在Ceph存储集群中的对象。 Ceph客户端有两种挂载cephfs的方式：基于内核和FUSE.下图为cephfs的结构图： Ceph文件系统服务包括与Ceph存储集群一起部署的Ceph元数据服务器（MDS）。 MDS存储了文件系统里的所有元数据（目录，文件所有权，访问模式等）。 MDS（ceph-mds的守护进程）将一些简单的文件系统操作（例如列出目录或更改目录（ls，cd）等）与Ceph OSD守护进程隔离，这样可以减少对OSD进程造成不必要的负担。 因此，将元数据与数据分离意味着Ceph文件系统可以提供高性能服务，而不会对Ceph存储集群造成负担。 MDS：存储metadata(元数据) OSD：存储file data(数据) ceph-mds可以作为单个进程运行，也可以分发到多个物理机器，以实现高可用性或可伸缩性。 高可用性：集群中处于standby状态的ceph-mds进程随时可以取代失败的active状态的ceph-mds，当active状态的ceph-mds进程失败时，ceph-mon很容易就可以把standby状态的mds转换成active状态，从而维持集群的可用性 可扩展性：集群中可以有多个active状态的ceph-mds进程，它们会将目录树拆分为子树（以及单个繁忙目录的分片），从而有效地平衡所有活动服务器之间的负载。 新建ceph client虚拟机 根据第二篇的方法，新建一个虚拟机，我们命名为ceph-client. 安装好之后配置相应的网络，具体方法详见这里 修改ifcfg-enp0s3 1vi /etc/sysconfig/network-scripts/ifcfg-enp0s3 将最后一行的ONBOOT=no改为ONBOOT=yes,添加IPADDR，NETMASK，这个是网卡1，用于给虚拟机上网。 修改ifcfg-enp0s8 12345vi /etc/sysconfig/network-scripts/ifcfg-enp0s8BOOTPROTO=staticONBOOT=yesIPADDR=192.168.56.200NETMASK=255.255.255.0 重启网卡并检查联网状态： 1systemctl restart network 修改主机名hostname: 1echo ceph-client &gt; /etc/hostname 重启，通过本机终端登录 1ssh root@192.168.56.200 修改yum源 123456yum clean allcurl http://mirrors.aliyun.com/repo/Centos-7.repo &gt;/etc/yum.repos.d/CentOS-Base.repocurl http://mirrors.aliyun.com/repo/epel-7.repo &gt;/etc/yum.repos.d/epel.repo sed -i '/aliyuncs/d' /etc/yum.repos.d/CentOS-Base.reposed -i '/aliyuncs/d' /etc/yum.repos.d/epel.repoyum makecache 配置ceph源 在/etc/yum.repos.d/目录下新增一个ceph源文件ceph.repo,并写入下面内容： 1234567891011121314vim /etc/yum.repos.d/ceph.repo#写入以下内容[ceph]name=cephbaseurl=http://mirrors.aliyun.com/ceph/rpm-luminous/el7/x86_64/gpgcheck=0[ceph-noarch]name=cephnoarchbaseurl=http://mirrors.aliyun.com/ceph/rpm-luminous/el7/noarch/gpgcheck=0[ceph-source]name=ceph-sourcebaseurl=http://mirrors.aliyun.com/ceph/rpm-luminous/el7/SRPMS/gpgcheck=0 安装软件 123yum clean all &amp;&amp; yum makecacheyum -y install yum-plugin-priorities yum -y install openssh-server 创建cephFS 登录mon集群的那三台机器中的一台即可，我这里登录ceph-1 1ssh root@192.168.56.101 创建cephfs creatring pools 1234[root@ceph-1 ceph]# ceph osd pool create cephfs_data 64pool 'cephfs_data' created[root@ceph-1 ceph]# ceph osd pool create cephfs_metadata 64pool 'cephfs_metadata' created creating a filesystem 1234[root@ceph-1 ceph]# ceph fs new cephfs cephfs_metadata cephfs_datanew fs with metadata pool 2 and data pool 1[root@ceph-1 ceph]# ceph fs lsname: cephfs, metadata pool: cephfs_metadata, data pools: [cephfs_data ] 一旦文件系统创建好之后，mds的状态就会发生变化，如下所示： 12[root@ceph-1 ceph]# ceph mds statcephfs-1/1/1 up &#123;0=ceph-2=up:active&#125;, 2 up:standby 再看看集群状态： 12345678910111213141516[root@ceph-1 ceph]# ceph -s cluster: id: c165f9d0-88df-48a7-8cc5-11da82f99c93 health: HEALTH_OK services: mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3 mgr: ceph-1(active), standbys: admin, ceph-2, ceph-3 mds: cephfs-1/1/1 up &#123;0=ceph-2=up:active&#125;, 2 up:standby osd: 9 osds: 9 up, 9 in data: pools: 2 pools, 128 pgs objects: 21 objects, 3.14KiB usage: 967MiB used, 18.0TiB / 18.0TiB avail pgs: 128 active+clean mds进入active状态 生成了两个pool，128个pg 挂载cephfs cephfs支持两种方式挂载： 内核驱动 使用fuse 这是官网给出的两种挂载方式的对比： The FUSE client is the most accessible and the easiest to upgrade to the version of Ceph used by the storage cluster, while the kernel client will often give better performance. The clients do not always provide equivalent functionality, for example the fuse client supports client-enforced quotas while the kernel client does not. 内核驱动 (with kernel) ceph一个集群只支持创建一个cephfs,所以只要创建一次cephfs之后，就可以在客户端机器上创建目录并挂载到集群： 在客户端机器上进行如下操作 12[root@ceph-client ~]# mkdir -p /mycephfs[root@ceph-client ~]# mount -t ceph 192.168.56.101,192.168.56.102,192.168.56.103:6789:/ /mycephfs 查看挂载情况： 1234567891011[root@ceph-client ~]# df -h文件系统 容量 已用 可用 已用% 挂载点/dev/mapper/centos-root 50G 1.6G 49G 4% /devtmpfs 485M 0 485M 0% /devtmpfs 496M 0 496M 0% /dev/shmtmpfs 496M 6.8M 490M 2% /runtmpfs 496M 0 496M 0% /sys/fs/cgroup/dev/sda1 1014M 129M 886M 13% /boot/dev/mapper/centos-home 347G 35M 347G 1% /hometmpfs 100M 0 100M 0% /run/user/0192.168.56.101,192.168.56.102,192.168.56.103:6789:/ 5.4T 0 5.4T 0% /mycephfs 最后一行可以看到挂载成功。 使用fuse (with fuse) 使用fuse方式进行挂载，需要安装ceph-fuse工具， 12345678910[root@ceph-client ~]# yum install ceph-fuse ........已安装: ceph-fuse.x86_64 2:12.2.9-0.el7作为依赖被安装: fuse-libs.x86_64 0:2.9.2-10.el7 gperftools-libs.x86_64 0:2.6.1-1.el7 libibverbs.x86_64 0:15-7.el7_5 pciutils.x86_64 0:3.5.1-3.el7 rdma-core.x86_64 0:15-7.el7_5完毕！ 12[root@ceph-client ~]# ceph-fuse -vceph version 12.2.9 (9e300932ef8a8916fb3fda78c58691a6ab0f4217) luminous (stable) ceph-fuse安装完成。 挂载cephfs 1234[root@ceph-client ~]# mkdir /fusefs[root@ceph-client ~]# ceph-fuse -m 192.168.56.101:6789 /fusefsceph-fuse[10854]: starting ceph clientceph-fuse[10854]: starting fuse 123456789101112[root@ceph-client ~]# df -h文件系统 容量 已用 可用 已用% 挂载点/dev/mapper/centos-root 50G 1.6G 49G 4% /devtmpfs 485M 0 485M 0% /devtmpfs 496M 0 496M 0% /dev/shmtmpfs 496M 6.8M 490M 2% /runtmpfs 496M 0 496M 0% /sys/fs/cgroup/dev/sda1 1014M 129M 886M 13% /boot/dev/mapper/centos-home 347G 35M 347G 1% /hometmpfs 100M 0 100M 0% /run/user/0192.168.56.101,192.168.56.102,192.168.56.103:6789:/ 5.4T 0 5.4T 0% /mycephfsceph-fuse 5.4T 0 5.4T 0% /fusefs 查看最后一行，说明挂载成功。 总结 本篇主要介绍了cephfs的架构以及在ceph集群上挂载cephfs的流程。","categories":[{"name":"ceph","slug":"ceph","permalink":"https://www.zuoyangblog.com/categories/ceph/"}],"tags":[{"name":"ceph","slug":"ceph","permalink":"https://www.zuoyangblog.com/tags/ceph/"},{"name":"cephfs","slug":"cephfs","permalink":"https://www.zuoyangblog.com/tags/cephfs/"}]},{"title":"第三篇：手动部署Ceph集群","slug":"manual-deploy-ceph","date":"2018-11-21T12:33:05.000Z","updated":"2018-11-22T15:38:43.000Z","comments":true,"path":"post/28a4bfb3.html","link":"","permalink":"https://www.zuoyangblog.com/post/28a4bfb3.html","excerpt":"","text":"上篇介绍了部署Ceph的环境准备工作，本篇主要内容是介绍手动部署Ceph的全过程。 环境 集群环境 上一篇，我们创建了3台虚拟机，虚拟机配置如下： 12345678910111213[root@ceph-1 ~]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 100G 0 disk├─sda1 8:1 0 1G 0 part /boot└─sda2 8:2 0 99G 0 part ├─centos-root 253:0 0 50G 0 lvm / ├─centos-swap 253:1 0 2G 0 lvm [SWAP] └─centos-home 253:2 0 47G 0 lvm /homesdb 8:16 0 2T 0 disksdc 8:32 0 2T 0 disksdd 8:48 0 2T 0 disksde 8:64 0 600G 0 disksr0 11:0 1 1024M 0 rom 3块大小为2T的磁盘，sdb,sdc,sdd，用于启动osd进程 一块大小为600G的磁盘，作为osd的journal分区 集群配置如下： 主机 IP 功能 ceph-1 192.168.56.101 mon1、osd0、osd1、osd2 ceph-2 192.168.56.102 mon2、osd3、osd4、osd5 ceph-3 192.168.56.103 mon3、osd6、osd7、osd8 配置NTP服务 将NTP server放在ceph-1节点上，ceph-2/3节点是NTP client，这样可以从根本上解决时间同步问题。 修改配置文件 从本机登录到ceph-1： 1ssh root@192.168.56.101 在ceph-1节点上进行如下操作： 修改/etc/ntp.conf,注释掉默认的四个server，添加三行配置如下： 12345678910vim /etc/ntp.conf###comment following lines:#server 0.centos.pool.ntp.org iburst#server 1.centos.pool.ntp.org iburst#server 2.centos.pool.ntp.org iburst#server 3.centos.pool.ntp.org iburst###add following lines:server 127.127.1.0 minpoll 4fudge 127.127.1.0 stratum 0restrict 192.168.56.0 mask 255.255.0.0 nomodify notrap 修改/etc/ntp/step-tickers文件如下： 123# List of NTP servers used by the ntpdate service.# 0.centos.pool.ntp.org127.127.1.0 在重启ntp服务之前需要将防火墙关闭，否则客户端不能访问ntp服务： 关闭防火墙 关闭selinux&amp;firewalld 1234sed -i 's/SELINUX=.*/SELINUX=disabled/' /etc/selinux/configsetenforce 0systemctl stop firewalld systemctl disable firewalld 启动ntp服务 重启ntp服务，并查看server端是否运行正常，正常的标准就是ntpq -p指令的最下面一行是*: 1234567[root@ceph-1 ~]# systemctl enable ntpdCreated symlink from /etc/systemd/system/multi-user.target.wants/ntpd.service to /usr/lib/systemd/system/ntpd.service.[root@ceph-1 ~]# systemctl restart ntpd [root@ceph-1 ~]# ntpq -p remote refid st t when poll reach delay offset jitter==============================================================================*LOCAL(0) .LOCL. 0 l 15 16 1 0.000 0.000 0.000 NTP server端已经配置完毕，下面开始配置client端。 配置客户端ntp同步 同样的方式登录到ceph-2/ceph-3机器上： 修改/etc/ntp.conf，注释掉四行server，添加一行server指向ceph-1: 12345678vim /etc/ntp.conf#server 0.centos.pool.ntp.org iburst#server 1.centos.pool.ntp.org iburst#server 2.centos.pool.ntp.org iburst#server 3.centos.pool.ntp.org iburstserver 192.168.56.101 重启ntp服务并观察client是否正确连接到server端，同样正确连接的标准是ntpq -p的最下面一行以*号开头: 12345[root@ceph-2 ~]# systemctl stop firewalld[root@ceph-2 ~]# systemctl disable firewalld [root@ceph-2 ~]# systemctl restart ntpd[root@ceph-2 ~]# systemctl enable ntpdCreated symlink from /etc/systemd/system/multi-user.target.wants/ntpd.service to /usr/lib/systemd/system/ntpd.service. 开始的时候会显示INIT状态，然后等了几分钟之后就出现了*。 异常状态： 1234[root@ceph-2 ~]# ntpq -p remote refid st t when poll reach delay offset jitter============================================================================== ceph-1 .INIT. 16 u - 64 0 0.000 0.000 0.000 正常状态： 1234[root@ceph-2 ~]# ntpq -p remote refid st t when poll reach delay offset jitter==============================================================================*ceph-1 LOCAL(0) 3 u 45 64 77 0.323 0.060 0.034 在搭建ceph集群之前，一定要保证ntp服务能够正常运行。 手动搭建ceph集群 手动部署mon集群 主mon节点部署 （192.168.56.101，ceph-1） 登录到ceph-1机器： 1ssh root@192.168.56.101 创建ceph用户与目录 新建一个脚本文件prepare_env.sh,然后写入以下内容： 1234567891011[root@ceph-1 ~]# vim prepare_env.sh/usr/sbin/groupadd ceph -g 167 -o -r/usr/sbin/useradd ceph -u 167 -o -r -g ceph -s /sbin/nologin -c \"Ceph daemons\"mkdir -p /etc/ceph/chown -R ceph:ceph /etc/ceph/mkdir -p /var/run/cephchown -R ceph:ceph /var/run/cephmkdir -p /var/log/cephchown -R ceph:ceph /var/log/cephmkdir -p /var/lib/ceph/monchown -R ceph:ceph /var/lib/ceph 创建ceph.conf文件 新建一个conf文件ceph.conf,然后写入以下内容： 1234567891011121314151617181920[root@ceph-1 ~]# vim /etc/ceph/ceph.conf[global]fsid = c165f9d0-88df-48a7-8cc5-11da82f99c93mon initial members = ceph-1mon host = 192.168.56.101,192.168.56.102,192.168.56.103rbd default features = 1auth_cluster_required = noneauth_service_required = noneauth_client_required = nonepublic network = 192.168.56.0/24cluster network = 192.168.56.0/24osd journal size = 1024osd pool default size = 3osd pool default min size = 1osd pool default pg num = 300osd pool default pgp num = 300osd crush chooseleaf type = 1[mon]mon allow pool delete = true 这里不对各个参数的含义进行解释，对于初学者而言，先把集群搭建起来，后面再去花时间了解整个ceph的原理及配置文件各个参数对集群的影响。 其中 fsid 是为集群分配的一个 uuid, 可使用uuidgen命令生成。初始化 mon 节点其实只需要这一个配置就够了。 mon host 配置 ceph 命令行工具访问操作 ceph 集群时查找 mon 节点入口。 ceph 集群可包含多个 mon 节点实现高可用容灾, 避免单点故障。 rbd default features = 1 配置 rbd 客户端创建磁盘时禁用一些需要高版本内核才能支持的特性。 拷贝这两个文件到ceph-2,ceph-3机器上 1234scp prepare_env.sh 192.168.56.102:/homescp prepare_env.sh 192.168.56.103:/homescp /etc/ceph/ceph.conf 192.168.56.102:/etc/ceph/scp /etc/ceph/ceph.conf 192.168.56.103:/etc/ceph/ 启动mon节点 首先执行脚本,创建ceph用户及相关目录。 1sh prepare_env.sh 1、为此集群创建密钥环、并生成Monitor密钥 12[root@ceph-1 ~]# ceph-authtool --create-keyring /tmp/ceph.mon.keyring --gen-key -n mon. --cap mon 'allow *'creating /tmp/ceph.mon.keyring 2、生成管理员密钥环，生成 client.admin 用户并加入密钥环 12[root@ceph-1 ~]# ceph-authtool --create-keyring /etc/ceph/ceph.client.admin.keyring --gen-key -n client.admin --set-uid=0 --cap mon 'allow *' --cap osd 'allow *' --cap mds 'allow *' --cap mgr 'allow *'creating /etc/ceph/ceph.client.admin.keyring 3、把 client.admin 密钥加入 ceph.mon.keyring (3台机器一样) 12[root@ceph-1 ~]# ceph-authtool /tmp/ceph.mon.keyring --import-keyring /etc/ceph/ceph.client.admin.keyringimporting contents of /etc/ceph/ceph.client.admin.keyring into /tmp/ceph.mon.keyring 4、用规划好的主机名、对应 IP 地址、和 FSID 生成一个Monitor Map，并保存为 /tmp/monmap 这里的--fsid需要跟ceph.conf里面的fsid保持一致 1234[root@ceph-1 ~]# monmaptool --create --add `hostname` `hostname -i` --fsid c165f9d0-88df-48a7-8cc5-11da82f99c93 /tmp/monmap --clobbermonmaptool: monmap file /tmp/monmapmonmaptool: set fsid to c165f9d0-88df-48a7-8cc5-11da82f99c93monmaptool: writing epoch 0 to /tmp/monmap (1 monitors) 5、在Monitor主机上分别创建数据目录 123456[root@ceph-1 ~]# rm -rf /var/lib/ceph/mon/ceph-`hostname`/[root@ceph-1 ~]# mkdir /var/lib/ceph/mon/ceph-`hostname`/[root@ceph-1 ~]# chown ceph:ceph -R /var/lib/ceph/mon/ceph-`hostname`/[root@ceph-1 ~]# chown -R ceph:ceph /var/lib/ceph/[root@ceph-1 ~]# chown ceph:ceph /tmp/monmap[root@ceph-1 ~]# chown ceph:ceph /tmp/ceph.mon.keyring 6、用Monitor Map和密钥环组装守护进程所需的初始数据 1[root@ceph-1 ~]# sudo -u ceph ceph-mon --mkfs -i `hostname` --monmap /tmp/monmap --keyring /tmp/ceph.mon.keyring 7、建一个空文件 done ，表示监视器已创建、可以启动了 1[root@ceph-1 ~]# touch /var/lib/ceph/mon/ceph-`hostname`/done 8、启动Monitor 1234[root@ceph-1 ~]# cp /usr/lib/systemd/system/ceph-mon@.service /usr/lib/systemd/system/ceph-mon@`hostname`.service[root@ceph-1 ~]# sudo systemctl start ceph-mon@`hostname`[root@ceph-1 ~]# sudo systemctl enable ceph-mon@`hostname`Created symlink from /etc/systemd/system/ceph-mon.target.wants/ceph-mon@ceph-1.service to /usr/lib/systemd/system/ceph-mon@ceph-1.service. 9、确认下集群在运行 123456789101112131415[root@ceph-1 ceph]# ceph -s cluster: id: c165f9d0-88df-48a7-8cc5-11da82f99c93 health: HEALTH_OK services: mon: 1 daemons, quorum ceph-1 mgr: no daemons active osd: 0 osds: 0 up, 0 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0B usage: 0B used, 0B / 0B avail pgs: 从mon节点部署 (192.168.56.102 &amp; 192.168.56.103) 在另外两台机器ceph-2,ceph-3上，分别ssh登录上去。 创建启动脚本 新建启动脚本文件start_repo_mon.sh 1vim start_repo_mon.sh 12345678910host_name=`hostname`sudo ceph mon getmap -o /tmp/monmapsudo rm -rf /var/lib/ceph/mon/ceph-$host_namesudo ceph-mon -i $host_name --mkfs --monmap /tmp/monmapsudo chown -R ceph:ceph /var/lib/ceph/mon/ceph-$host_name/#nohup ceph-mon -f --cluster ceph --id $host_name --setuser ceph --setgroup ceph &amp;#ceph-mon -f --cluster ceph --id $host_name &amp;sudo cp /usr/lib/systemd/system/ceph-mon@.service /usr/lib/systemd/system/ceph-mon@$host_name.servicesudo systemctl start ceph-mon@$host_namesudo systemctl enable ceph-mon@$host_name 启动mon进程 ceph-2机器192.168.56.102 123456789[root@ceph-2 ceph]# sh prepare_env.shgroupadd：“ceph”组已存在useradd：用户“ceph”已存在[root@ceph-2 ceph]# sh start_repo_mon.shgot monmap epoch 1Created symlink from /etc/systemd/system/ceph-mon.target.wants/ceph-mon@ceph-2.service to /usr/lib/systemd/system/ceph-mon@ceph-2.service.[root@ceph-2 ceph]# ps -ef | grep cephceph 11852 1 0 20:47 ? 00:00:00 /usr/bin/ceph-mon -f --cluster ceph --id ceph-2 --setuser ceph --setgroup cephroot 11908 11645 0 20:47 pts/0 00:00:00 grep --color=auto ceph 1234567891011121314[root@ceph-2 ceph]# ceph -s id: c165f9d0-88df-48a7-8cc5-11da82f99c93 health: HEALTH_OK services: mon: 2 daemons, quorum ceph-1,ceph-2 mgr: no daemons active osd: 0 osds: 0 up, 0 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0B usage: 0B used, 0B / 0B avail pgs: ceph-3机器192.168.56.103 123456789[root@ceph-3 ceph]# sh prepare_env.shgroupadd：“ceph”组已存在useradd：用户“ceph”已存在[root@ceph-3 ceph]# sh start_repo_mon.shgot monmap epoch 2Created symlink from /etc/systemd/system/ceph-mon.target.wants/ceph-mon@ceph-3.service to /usr/lib/systemd/system/ceph-mon@ceph-3.service.[root@ceph-3 ceph]# ps -ef | grep cephceph 11818 1 1 20:51 ? 00:00:00 /usr/bin/ceph-mon -f --cluster ceph --id ceph-3 --setuser ceph --setgroup cephroot 11874 11081 0 20:51 pts/0 00:00:00 grep --color=auto ceph 123456789101112131415[root@ceph-3 ceph]# ceph -s cluster: id: c165f9d0-88df-48a7-8cc5-11da82f99c93 health: HEALTH_OK services: mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3 mgr: no daemons active osd: 0 osds: 0 up, 0 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0B usage: 0B used, 0B / 0B avail pgs: 至此可以看到ceph mon集群搭建完毕。 手动搭建ceph-mgr 首先在ceph-1机器上创建并启动ceph-mgr进程。 创建 MGR 监控用户 123[root@ceph-1 ceph]# ceph auth get-or-create mgr.`hostname` mon 'allow *' osd 'allow *' mds 'allow *'[mgr.ceph-1] key = AQCvovZbpUHTDBAA+/RoCVv+GTBc7lb96rOXRg== 需要将之前创建的用户密码存放至对应位置 123[root@ceph-1 ceph]# mkdir /var/lib/ceph/mgr/ceph-`hostname`[root@ceph-1 ceph]# ceph auth get mgr.`hostname` -o /var/lib/ceph/mgr/ceph-`hostname`/keyringexported keyring for mgr.ceph-1 启动mgr 1234[root@ceph-1 ceph]# cp /usr/lib/systemd/system/ceph-mgr@.service /usr/lib/systemd/system/ceph-mgr@`hostname`.service[root@ceph-1 ceph]# systemctl start ceph-mgr@`hostname`[root@ceph-1 ceph]# systemctl enable ceph-mgr@`hostname`Created symlink from /etc/systemd/system/ceph-mgr.target.wants/ceph-mgr@ceph-1.service to /usr/lib/systemd/system/ceph-mgr@ceph-1.service. 验证是否成功 12345678910[root@ceph-1 ceph]# systemctl status ceph-mgr@`hostname`● ceph-mgr@ceph-1.service - Ceph cluster manager daemon Loaded: loaded (/usr/lib/systemd/system/ceph-mgr@ceph-1.service; enabled; vendor preset: disabled) Active: active (running) since 四 2018-11-22 07:38:49 EST; 14s ago Main PID: 2050 (ceph-mgr) CGroup: /system.slice/system-ceph\\x2dmgr.slice/ceph-mgr@ceph-1.service └─2050 /usr/bin/ceph-mgr -f --cluster ceph --id ceph-1 --setuser ceph --setgroup ceph11月 22 07:38:49 ceph-1 systemd[1]: Started Ceph cluster manager daemon.11月 22 07:38:49 ceph-1 systemd[1]: Starting Ceph cluster manager daemon... 或者： 123[root@ceph-1 ceph]# ps -ef | grep ceph-mgrceph 2050 1 1 07:38 ? 00:00:00 /usr/bin/ceph-mgr -f --cluster ceph --id ceph-1 --setuser ceph --setgroup cephroot 2102 1249 0 07:39 pts/0 00:00:00 grep --color=auto ceph-mgr 说明mgr进程正常启动。 监控状态 123456789101112131415[root@ceph-1 ceph]# ceph -s cluster: id: c165f9d0-88df-48a7-8cc5-11da82f99c93 health: HEALTH_OK services: mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3 mgr: ceph-1(active), standbys: admin osd: 0 osds: 0 up, 0 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0B usage: 0B used, 0B / 0B avail pgs: 当 mgr 服务被激活之后, service 中 mgr 会显示 mgr-$name(active) data 部分信息将变得可用 脚本操作 在ceph-2,ceph-3机器上，创建脚本start_mgr.sh，写入以下内容： 123456789[root@ceph-2 ceph]# vim start_mgr.shhost_name=`hostname`sudo ceph auth get-or-create mgr.$host_name mon 'allow *' osd 'allow *' mds 'allow *'sudo rm -rf /var/lib/ceph/mgr/ceph-$host_namesudo mkdir /var/lib/ceph/mgr/ceph-$host_namesudo ceph auth get mgr.$host_name -o /var/lib/ceph/mgr/ceph-$host_name/keyringsudo cp /usr/lib/systemd/system/ceph-mgr@.service /usr/lib/systemd/system/ceph-mgr@$host_name.servicesudo systemctl start ceph-mgr@$host_namesudo systemctl enable ceph-mgr@$host_name 执行脚本： 12345[root@ceph-2 ceph]# sh start_mgr.sh[mgr.ceph-2] key = AQCTpfZbNLmpFxAACe1gMNUM4vqKMfNdUGbY/A==exported keyring for mgr.ceph-2Created symlink from /etc/systemd/system/ceph-mgr.target.wants/ceph-mgr@ceph-2.service to /usr/lib/systemd/system/ceph-mgr@ceph-2.service. 查看进程状态： 12345678910111213[root@ceph-2 ceph]# ps -ef | grep ceph-mgrceph 12101 1 0 07:48 ? 00:00:00 /usr/bin/ceph-mgr -f --cluster ceph --id ceph-2 --setuser ceph --setgroup cephroot 12173 11645 0 07:50 pts/0 00:00:00 grep --color=auto ceph-mgr[root@ceph-2 ceph]# systemctl status ceph-mgr*● ceph-mgr@ceph-2.service - Ceph cluster manager daemon Loaded: loaded (/usr/lib/systemd/system/ceph-mgr@ceph-2.service; enabled; vendor preset: disabled) Active: active (running) since 四 2018-11-22 07:48:19 EST; 2min 33s ago Main PID: 12101 (ceph-mgr) CGroup: /system.slice/system-ceph\\x2dmgr.slice/ceph-mgr@ceph-2.service └─12101 /usr/bin/ceph-mgr -f --cluster ceph --id ceph-2 --setuser ceph --setgroup ceph11月 22 07:48:19 ceph-2 systemd[1]: Started Ceph cluster manager daemon.11月 22 07:48:19 ceph-2 systemd[1]: Starting Ceph cluster manager daemon... 123456789101112131415[root@ceph-2 ceph]# ceph -s cluster: id: c165f9d0-88df-48a7-8cc5-11da82f99c93 health: HEALTH_OK services: mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3 mgr: ceph-1(active), standbys: admin, ceph-2 osd: 0 osds: 0 up, 0 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0B usage: 0B used, 0B / 0B avail pgs: 可以看到在ceph-2机器上，ceph-mgr进程正常启动。 最后再ceph-3上进行同样的操作。 所有mgr进程创建完成之后，集群的状态如下： 123456789101112131415[root@ceph-3 ceph]# ceph -s cluster: id: c165f9d0-88df-48a7-8cc5-11da82f99c93 health: HEALTH_OK services: mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3 mgr: ceph-1(active), standbys: admin, ceph-2, ceph-3 osd: 0 osds: 0 up, 0 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0B usage: 0B used, 0B / 0B avail pgs: health是处于OK状态 3个mon daemons mgr进程：ceph-1是active状态，剩下的ceph-2,ceph-3处于standby 手动搭建osd集群 磁盘分区 每个osd对应一块磁盘，是ceph集群存储数据的物理单位，在搭建osd集群之前，先要对三台机器的磁盘进行处理，这里每台机器都是相同的操作，这里只演示ceph-1上的操作： 查看磁盘分布情况 12345678910111213[root@ceph-1 ceph]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 100G 0 disk├─sda1 8:1 0 1G 0 part /boot└─sda2 8:2 0 99G 0 part ├─centos-root 253:0 0 50G 0 lvm / ├─centos-swap 253:1 0 2G 0 lvm [SWAP] └─centos-home 253:2 0 47G 0 lvm /homesdb 8:16 0 2T 0 disksdc 8:32 0 2T 0 disksdd 8:48 0 2T 0 disksde 8:64 0 600G 0 disksr0 11:0 1 1024M 0 rom 这里我们可以看到有三块2T的磁盘:sdb,sdc,sdd,用来部署osd;一块600G的磁盘用作每个osd的journal分区。 sde进行分区： 123456789101112131415161718192021222324252627282930313233343536373839[root@ceph-1 ceph]# fdisk /dev/sde欢迎使用 fdisk (util-linux 2.23.2)。更改将停留在内存中，直到您决定将更改写入磁盘。使用写入命令前请三思。Device does not contain a recognized partition table使用磁盘标识符 0x986f9840 创建新的 DOS 磁盘标签。命令(输入 m 获取帮助)：gBuilding a new GPT disklabel (GUID: E7350C3E-586A-424E-ABAB-73860654C2C8)命令(输入 m 获取帮助)：n分区号 (1-128，默认 1)：第一个扇区 (2048-1258279965，默认 2048)：Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-1258279965，默认 1258279965)：+200G已创建分区 1命令(输入 m 获取帮助)：n分区号 (2-128，默认 2)：第一个扇区 (419432448-1258279965，默认 419432448)：Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (419432448-1258279965，默认 1258279965)：+200G已创建分区 2命令(输入 m 获取帮助)：n分区号 (3-128，默认 3)：第一个扇区 (838862848-1258279965，默认 838862848)：Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (838862848-1258279965，默认 1258279965)：已创建分区 3命令(输入 m 获取帮助)：wThe partition table has been altered!Calling ioctl() to re-read partition table.正在同步磁盘。 sde磁盘分区好之后，如下图所示： 创建xfs文件系统 分别对磁盘sdb,sdc,sdd,sde1,sde2,sde3进行如下操作： 12345678910[root@ceph-1 ceph]# mkfs.xfs /dev/sdb # 之后将sdb替换为sdc,sdd,sde1,sde2,sde3meta-data=/dev/sdb isize=512 agcount=4, agsize=134211328 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0, sparse=0data = bsize=4096 blocks=536845310, imaxpct=5 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=1log =internal log bsize=4096 blocks=262131, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0 对这几个磁盘操作完之后，查看每个磁盘的uuid 123456789101112[root@ceph-1 ceph]# blkid/dev/sda1: UUID=\"b66ddda6-8a4c-48d8-bb8a-9a3183094c5d\" TYPE=\"xfs\"/dev/sda2: UUID=\"Iylyc4-LvIV-TnAg-FZK6-xz2D-3gaY-hx17eb\" TYPE=\"LVM2_member\"/dev/sdb: UUID=\"104c6fd4-58e7-468f-a003-266d9a7fb9ba\" TYPE=\"xfs\"/dev/sdc: UUID=\"1a06d53d-0f76-4931-9add-fe3494510edc\" TYPE=\"xfs\"/dev/sdd: UUID=\"30a5527d-e7b6-4c13-b735-c9e086775d51\" TYPE=\"xfs\"/dev/sde1: UUID=\"58793fce-298c-417c-85dc-b0d913f8cd63\" TYPE=\"xfs\" PARTUUID=\"ca1a9c40-e020-4bf8-a17b-5716b3e1d453\"/dev/sde2: UUID=\"1c7ef6a8-58a6-47c0-9d2d-ff086a3d81f7\" TYPE=\"xfs\" PARTUUID=\"c458e242-716d-42f7-9a2e-5f21c291987a\"/dev/sde3: UUID=\"0581b33a-321d-42af-9b5f-272a775fccc1\" TYPE=\"xfs\" PARTUUID=\"651f90d2-9697-4474-b3d8-a0e980b125a4\"/dev/mapper/centos-root: UUID=\"0fc63cb7-c2e6-46e8-8db9-2c31fdd20310\" TYPE=\"xfs\"/dev/mapper/centos-swap: UUID=\"a8605f7e-5049-4cd4-bd6d-805c98543f38\" TYPE=\"swap\"/dev/mapper/centos-home: UUID=\"7fc267af-b141-4140-afb9-388453097422\" TYPE=\"xfs\" 可以看到这些磁盘都有独立的UUID，且TYPE都为“xfs”。说明创建成功。 启动osd进程 创建osd id 添加一个新osd，id可以省略，ceph会自动使用最小可用整数，第一个osd从0开始 12[root@ceph-1 ceph]# ceph osd create0 初始化osd目录 创建osd.0目录，目录名格式{cluster-name}-{id} 12#mkdir /var/lib/ceph/osd/&#123;cluster-name&#125;-&#123;id&#125;[root@ceph-1 ceph]# mkdir /var/lib/ceph/osd/ceph-0 挂载osd.0的数据盘/dev/sdb 1[root@ceph-1 ceph]# mount /dev/sdb /var/lib/ceph/osd/ceph-0 查看挂载结果： 12345678910111213141516[root@ceph-1 ceph]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 100G 0 disk├─sda1 8:1 0 1G 0 part /boot└─sda2 8:2 0 99G 0 part ├─centos-root 253:0 0 50G 0 lvm / ├─centos-swap 253:1 0 2G 0 lvm [SWAP] └─centos-home 253:2 0 47G 0 lvm /homesdb 8:16 0 2T 0 disk /var/lib/ceph/osd/ceph-0sdc 8:32 0 2T 0 disksdd 8:48 0 2T 0 disksde 8:64 0 600G 0 disk├─sde1 8:65 0 200G 0 part├─sde2 8:66 0 200G 0 part└─sde3 8:67 0 200G 0 partsr0 11:0 1 1024M 0 rom 初始化osd数据目录 12345678910# sudo ceph-osd -i &#123;id&#125; --mkfs --mkkey[root@ceph-1 ceph]# ceph-osd -i 0 --mkfs --mkkey2018-11-22 08:26:54.255294 7fb2734e6d80 -1 auth: error reading file: /var/lib/ceph/osd/ceph-0/keyring: can't open /var/lib/ceph/osd/ceph-0/keyring: (2) No such file or directory2018-11-22 08:26:54.257686 7fb2734e6d80 -1 created new key in keyring /var/lib/ceph/osd/ceph-0/keyring2018-11-22 08:26:54.306488 7fb2734e6d80 -1 journal FileJournal::_open: disabling aio for non-block journal. Use journal_force_aio to force use of aio anyway2018-11-22 08:26:54.341905 7fb2734e6d80 -1 journal FileJournal::_open: disabling aio for non-block journal. Use journal_force_aio to force use of aio anyway2018-11-22 08:26:54.342312 7fb2734e6d80 -1 journal do_read_entry(4096): bad header magic2018-11-22 08:26:54.342327 7fb2734e6d80 -1 journal do_read_entry(4096): bad header magic2018-11-22 08:26:54.342704 7fb2734e6d80 -1 read_settings error reading settings: (2) No such file or directory2018-11-22 08:26:54.395459 7fb2734e6d80 -1 created object store /var/lib/ceph/osd/ceph-0 for osd.0 fsid c165f9d0-88df-48a7-8cc5-11da82f99c93 创建journal 生成journal分区，一般选ssd盘作为journal分区，这里使用/dev/sde1分区作为osd.0的journal。 123456789101112131415161718192021#查看分区对应的partuuid， 找出/dev/sde1对应的partuuid[root@ceph-1 ceph]# rm -f /var/lib/ceph/osd/ceph-0/journal[root@ceph-1 ceph]# blkid/dev/sda1: UUID=\"b66ddda6-8a4c-48d8-bb8a-9a3183094c5d\" TYPE=\"xfs\"/dev/sda2: UUID=\"Iylyc4-LvIV-TnAg-FZK6-xz2D-3gaY-hx17eb\" TYPE=\"LVM2_member\"/dev/sdb: UUID=\"104c6fd4-58e7-468f-a003-266d9a7fb9ba\" TYPE=\"xfs\"/dev/sdc: UUID=\"1a06d53d-0f76-4931-9add-fe3494510edc\" TYPE=\"xfs\"/dev/sdd: UUID=\"30a5527d-e7b6-4c13-b735-c9e086775d51\" TYPE=\"xfs\"/dev/sde1: UUID=\"58793fce-298c-417c-85dc-b0d913f8cd63\" TYPE=\"xfs\" PARTUUID=\"ca1a9c40-e020-4bf8-a17b-5716b3e1d453\"/dev/sde2: UUID=\"1c7ef6a8-58a6-47c0-9d2d-ff086a3d81f7\" TYPE=\"xfs\" PARTUUID=\"c458e242-716d-42f7-9a2e-5f21c291987a\"/dev/sde3: UUID=\"0581b33a-321d-42af-9b5f-272a775fccc1\" TYPE=\"xfs\" PARTUUID=\"651f90d2-9697-4474-b3d8-a0e980b125a4\"/dev/mapper/centos-root: UUID=\"0fc63cb7-c2e6-46e8-8db9-2c31fdd20310\" TYPE=\"xfs\"/dev/mapper/centos-swap: UUID=\"a8605f7e-5049-4cd4-bd6d-805c98543f38\" TYPE=\"swap\"/dev/mapper/centos-home: UUID=\"7fc267af-b141-4140-afb9-388453097422\" TYPE=\"xfs\"[root@ceph-1 ceph]# ln -s /dev/disk/by-partuuid/ca1a9c40-e020-4bf8-a17b-5716b3e1d453 /var/lib/ceph/osd/ceph-0/journal[root@ceph-1 ceph]# chown ceph:ceph -R /var/lib/ceph/osd/ceph-0[root@ceph-1 ceph]# chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal[root@ceph-1 ceph]# ceph-osd --mkjournal -i 02018-11-22 08:31:06.832760 7f97505afd80 -1 journal read_header error decoding journal header[root@ceph-1 ceph]# ceph-osd --mkjournal -i 0[root@ceph-1 ceph]# chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal 注册osd.{id}，id为osd编号，默认从0开始 123# sudo ceph auth add osd.&#123;id&#125; osd 'allow *' mon 'allow profile osd' -i /var/lib/ceph/osd/ceph-&#123;id&#125;/keyring[root@ceph-1 ceph]# ceph auth add osd.0 osd 'allow *' mon 'allow profile osd' -i /var/lib/ceph/osd/ceph-0/keyringadded key for osd.0 加入crush map 这是ceph-1上新创建的第一个osd，CRUSH map中还没有ceph-1节点，因此首先要把ceph-1节点加入CRUSH map，同理，ceph-2/ceph-3节点也需要加入CRUSH map 12[root@ceph-1 ceph]# ceph osd crush add-bucket `hostname` hostadded bucket ceph-1 type host to crush map 然后把三个节点移动到默认的root default下面 12[root@ceph-1 ceph]# ceph osd crush move `hostname` root=defaultmoved item id -2 name 'ceph-1' to location &#123;root=default&#125; in crush map 添加osd.0到CRUSH map中的ceph-1节点下面，加入后，osd.0就能够接收数据 1234#ceph osd crush add osd.&#123;id&#125; 0.4 root=sata rack=sata-rack01 host=sata-node5#0.4为此osd在CRUSH map中的权重值，它表示数据落在此osd上的比重，是一个相对值，一般按照1T磁盘比重值为1来计算，这里的osd数据盘1.7，所以值为1.7 [root@ceph-1 ceph]# ceph osd crush add osd.0 2.0 root=default host=`hostname`add item id 0 name 'osd.0' weight 2 at location &#123;host=ceph-1,root=default&#125; to crush map 此时osd.0状态是down且in，in表示此osd位于CRUSH map，已经准备好接受数据，down表示osd进程运行异常，因为我们还没有启动osd.0进程 启动ceph-osd进程 需要向systemctl传递osd的id以启动指定的osd进程，如下，我们准备启动osd.0进程 1234[root@ceph-1 ceph]# cp /usr/lib/systemd/system/ceph-osd@.service /usr/lib/systemd/system/ceph-osd@0.service[root@ceph-1 ceph]# systemctl start ceph-osd@0[root@ceph-1 ceph]# systemctl enable ceph-osd@0Created symlink from /etc/systemd/system/ceph-osd.target.wants/ceph-osd@0.service to /usr/lib/systemd/system/ceph-osd@0.service. 上面就是添加osd.0的步骤，然后可以接着在其他hostname节点上添加osd.{1,2}，添加了这3个osd后，可以查看集群状态 ceph -s。 验证osd进程是否成功启动 123[root@ceph-1 ceph]# ps -ef | grep ceph-osdceph 2593 1 0 08:55 ? 00:00:00 /usr/bin/ceph-osd -f --cluster ceph --id 0 --setuser ceph --setgroup cephroot 2697 1249 0 08:55 pts/0 00:00:00 grep --color=auto ceph-osd 说明osd.0已经启动成功 查看集群状态 123456789101112131415[root@ceph-1 ceph]# ceph -s cluster: id: c165f9d0-88df-48a7-8cc5-11da82f99c93 health: HEALTH_OK services: mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3 mgr: ceph-1(active), standbys: admin, ceph-2, ceph-3 osd: 1 osds: 1 up, 1 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0B usage: 107MiB used, 2.00TiB / 2.00TiB avail pgs: osd已经有一个处于up跟in状态了。 按照上面的步骤重复操作，添加剩下的osd。 也可以执行如下脚本进行启动osd 1234567891011121314151617181920212223242526272829303132333435363738[root@ceph-1 ceph]# vim start_osd.sh#执行脚本时需要输入三个参数,顺序依次为：osd.num, osd数据存储分区，osd journal存储分区#例如：sudo sh start_osd.sh 0 /dev/sdc2 /dev/sdc1#获取参数host_name=`hostname`id=$1data_disk=$2journal_disk=$3#创建osd dataceph osd create $idsudo rm -rf /var/lib/ceph/osd/ceph-$idsudo mkdir /var/lib/ceph/osd/ceph-$id#sudo mkfs.xfs $data_disk -fsudo mount $data_disk /var/lib/ceph/osd/ceph-$idsudo ceph-osd -i $id --mkfs --mkkey#创建 journal#sudo mkfs.xfs $journal_disk -fuuid=`sudo blkid | grep $journal_disk | awk -F\\\" '&#123;print $6&#125;'`sudo rm -f /var/lib/ceph/osd/ceph-$id/journal sudo ln -s /dev/disk/by-partuuid/$uuid /var/lib/ceph/osd/ceph-$id/journalsudo chown ceph:ceph -R /var/lib/ceph/osd/ceph-$idsudo chown ceph:ceph /var/lib/ceph/osd/ceph-$id/journal#初始化新的journalsudo ceph-osd --mkjournal -i $idsudo chown ceph:ceph /var/lib/ceph/osd/ceph-$id/journal# 添加osd到crushmapsudo ceph auth add osd.$id osd 'allow *' mon 'allow profile osd' -i /var/lib/ceph/osd/ceph-$id/keyringsudo ceph osd crush add-bucket $host_name hostsudo ceph osd crush move $host_name root=defaultsudo ceph osd crush add osd.$id 1.7 root=default host=$host_name# 启动osdsudo cp /usr/lib/systemd/system/ceph-osd@.service /usr/lib/systemd/system/ceph-osd@$id.servicesudo systemctl start ceph-osd@$idsudo systemctl enable ceph-osd@$id 执行实例： 1234567891011121314151617# 第一个参数：osd的id, 第二个参数： osd数据分区 第三个参数： osd的journal[root@ceph-1 ceph]# sh start_osd.sh 1 /dev/sdc /dev/sde212018-11-22 09:31:18.144721 7fc56f8b5d80 -1 auth: error reading file: /var/lib/ceph/osd/ceph-1/keyring: can't open /var/lib/ceph/osd/ceph-1/keyring: (2) No such file or directory2018-11-22 09:31:18.147361 7fc56f8b5d80 -1 created new key in keyring /var/lib/ceph/osd/ceph-1/keyring2018-11-22 09:31:18.184083 7fc56f8b5d80 -1 journal FileJournal::_open: disabling aio for non-block journal. Use journal_force_aio to force use of aio anyway2018-11-22 09:31:18.208952 7fc56f8b5d80 -1 journal FileJournal::_open: disabling aio for non-block journal. Use journal_force_aio to force use of aio anyway2018-11-22 09:31:18.209302 7fc56f8b5d80 -1 journal do_read_entry(4096): bad header magic2018-11-22 09:31:18.209321 7fc56f8b5d80 -1 journal do_read_entry(4096): bad header magic2018-11-22 09:31:18.209700 7fc56f8b5d80 -1 read_settings error reading settings: (2) No such file or directory2018-11-22 09:31:18.246674 7fc56f8b5d80 -1 created object store /var/lib/ceph/osd/ceph-1 for osd.1 fsid c165f9d0-88df-48a7-8cc5-11da82f99c932018-11-22 09:31:18.480406 7fce4eeb4d80 -1 journal read_header error decoding journal headeradded key for osd.1bucket 'ceph-1' already existsno need to move item id -2 name 'ceph-1' to location &#123;root=default&#125; in crush mapadd item id 1 name 'osd.1' weight 2 at location &#123;host=ceph-1,root=default&#125; to crush mapCreated symlink from /etc/systemd/system/ceph-osd.target.wants/ceph-osd@1.service to /usr/lib/systemd/system/ceph-osd@1.service. 按照上面的方法添加所有的osd之后，可以得到如下的集群： 123456789101112131415[root@ceph-3 ceph]# ceph -s cluster: id: c165f9d0-88df-48a7-8cc5-11da82f99c93 health: HEALTH_OK services: mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3 mgr: ceph-1(active), standbys: admin, ceph-2, ceph-3 osd: 9 osds: 9 up, 9 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0B usage: 858MiB used, 16.0TiB / 16.0TiB avail pgs: 手动搭建MDS (仅cephfs使用) 创建目录： 12[root@ceph-1 ceph]# mkdir /var/lib/ceph/mds/ceph-`hostname`[root@ceph-1 ceph]# chown ceph:ceph -R /var/lib/ceph/mds/ceph-`hostname` 在ceph.conf中添加如下信息： 123456[mds.ceph-1]host = ceph-1[mds.ceph-2]host = ceph-2[mds.ceph-3]host = ceph-3 重启ceph-mon 1[root@ceph-1 ceph]# systemctl restart ceph-mon@`hostname` 启动mds 1234[root@ceph-1 ceph]# cp /usr/lib/systemd/system/ceph-mds@.service /usr/lib/systemd/system/ceph-mds@`hostname`.service[root@ceph-1 ceph]# systemctl start ceph-mds@`hostname`[root@ceph-1 ceph]# systemctl enable ceph-mds@`hostname`Created symlink from /etc/systemd/system/ceph-mds.target.wants/ceph-mds@ceph-1.service to /usr/lib/systemd/system/ceph-mds@ceph-1.service. 查看mds状态 12[root@ceph-1 ceph]# ceph mds stat, 1 up:standby 在ceph-2,ceph-3上执行以上相同操作即可。 最终mds的状态为： 12[root@ceph-3 ceph]# ceph mds stat, 3 up:standby Ceph集群搭建完成 最终的ceph集群状态如下： 123456789101112131415[root@ceph-3 ceph]# ceph -s cluster: id: c165f9d0-88df-48a7-8cc5-11da82f99c93 health: HEALTH_OK services: mon: 3 daemons, quorum ceph-1,ceph-2,ceph-3 mgr: ceph-1(active), standbys: admin, ceph-2, ceph-3 osd: 9 osds: 9 up, 9 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0B usage: 965MiB used, 18.0TiB / 18.0TiB avail pgs: 至此ceph集群搭建完成。","categories":[{"name":"ceph","slug":"ceph","permalink":"https://www.zuoyangblog.com/categories/ceph/"}],"tags":[{"name":"ceph","slug":"ceph","permalink":"https://www.zuoyangblog.com/tags/ceph/"},{"name":"ceph-mon","slug":"ceph-mon","permalink":"https://www.zuoyangblog.com/tags/ceph-mon/"},{"name":"ceph-osd","slug":"ceph-osd","permalink":"https://www.zuoyangblog.com/tags/ceph-osd/"},{"name":"ceph-mgr","slug":"ceph-mgr","permalink":"https://www.zuoyangblog.com/tags/ceph-mgr/"}]},{"title":"第二篇：Ceph集群环境准备","slug":"ceph-enviroment-set","date":"2018-11-20T10:28:27.000Z","updated":"2018-11-23T04:03:56.000Z","comments":true,"path":"post/ad293d8.html","link":"","permalink":"https://www.zuoyangblog.com/post/ad293d8.html","excerpt":"","text":"第一篇简单介绍了Ceph的架构，让我们对Ceph有了一个初步的印象。 接下来，我将在MAC上介绍如何基于本机搭建ceph集群及cephfs、cephrgw、cephrbd服务。 集群规划： 生产环境 至少3台物理机组成Ceph集群 双网卡 测试环境 1台主机也可以 单网卡也可以 本文使用虚拟机搭建集群，集群设置如下： mon集群： 3台虚拟机组成mon集群 osd集群： 3台虚拟机组成osd集群 每台虚拟机上3个osd进程 mgr集群： 3个mgr进程 在部署之前，首先需要介绍前期环境的准备工作： 软件准备：VirtualBox，CentOS 安装虚拟机 克隆虚拟机 软件准备 安装VirtualBox 点击 VirtualBox Mac版本，下载VirtualBox，然后双击下载好的软件，按照提示一直安装即可。 添加网络 安装好之后，需要添加一个网络，这样可以保证在虚拟机里也能正常上网。具体操作如下： 点击左上角的VirtualBox-&gt;偏好设置-&gt;网络-&gt;仅主机(Host-Only)网络-&gt;点击右边的绿色➕，一般会默认添加了vboxnet0，双击vboxnet0，可以看到网络的IP信息，默认为192.168.56.1，如下图： 下载CentOS镜像 点击CentOS 7.5 镜像Minimal ，这里我们下载Minimal版本，后面操作的时候，我们直接通过配置虚拟机IP，使得本机可以直接ssh访问虚拟机进行操作。 安装CentOS虚拟机 创建虚拟机 打开VirtualBox，点击新建，这时会新建一个虚拟机，命名为ceph-1,类型选择Linux，版本选择Linux 2.6/3.x/4.x 64bit，具体见下图： 内存设置：默认值为1G，直接下一步即可，如下图: 创建虚拟硬盘：选择创建VDI，然后下一步，如下图: 存储在物理盘：这里有两个选项-动态分配或固定大小，这里选择动态分配，见下图: 动态分配，这种方式下，创建一个2T的磁盘，实际只会占用计算机几十MB的空间，实际使用多少空间，才会占用多少空间，相当于用时分配。 固定大小，这种方式下，创建多大的盘就会占用多大的空间。 文件位置与大小：将空间大小设置为100G，这是用于系统盘。然后点击创建即可: 至此，虚拟机创建完成。 配置虚拟机 添加CentOS镜像 选择刚刚创建好的虚拟机，点击设置-&gt;存储-&gt;控制器:IDE-&gt;没有盘片，点击右侧的光盘按钮，将刚刚下载的CentOS的镜像添加进来，如下图所示： 添加3个2T磁盘 点击控制器:SATA旁边的方形加号，添加SATA盘，创建新的虚拟盘-&gt; VHD-&gt; 动态分配 -&gt; 2TB. 步骤如下图： 配置网络 点击设置-&gt; 网络-&gt; 网卡 1-&gt; 连接方式 -&gt; 网络地址转换(NAT)，用于给VM上网，如下图所示： 点击网卡2 -&gt; 勾选启用网络连接 -&gt; 连接方式 -&gt; 仅主机(Host-only)网络 -&gt; 界面名称 -&gt; vboxnet0这里的vboxnet0是在上一步中添加的，如下图所示： 虚拟机配置完成，接下来进行安装CentOS。 安装CentOS 启动刚刚创建的虚拟机，Install CentOS 7，一直往下点，然后出现下面的页面： 点击红框中的选项，然后Begin Install： 之后再设置root密码： 之后一直等就可以了，最后重启机器，安装完成。 配置网卡 修改ifcfg-enp0s3 1vi /etc/sysconfig/network-scripts/ifcfg-enp0s3 将最后一行的ONBOOT=no改为ONBOOT=yes,添加IPADDR，NETMASK，这个是网卡1，用于给虚拟机上网。 修改ifcfg-enp0s8 123456vi /etc/sysconfig/network-scripts/ifcfg-enp0s8#修改以下几个配置项BOOTPROTO=staticONBOOT=yesIPADDR=192.168.56.101 #因为vboxnet0的IP为192.168.56.1NETMASK=255.255.255.0 重启网卡并检查联网状态： 123456789systemctl restart networkping www.baidu.comPING www.a.shifen.com (115.239.211.112) 56(84) bytes of data.64 bytes from 115.239.211.112 (115.239.211.112): icmp_seq=1 ttl=63 time=2.79 ms64 bytes from 115.239.211.112 (115.239.211.112): icmp_seq=2 ttl=63 time=25.7 ms64 bytes from 115.239.211.112 (115.239.211.112): icmp_seq=3 ttl=63 time=3.58 ms64 bytes from 115.239.211.112 (115.239.211.112): icmp_seq=5 ttl=63 time=3.62 ms64 bytes from 115.239.211.112 (115.239.211.112): icmp_seq=6 ttl=63 time=2.97 ms64 bytes from 115.239.211.112 (115.239.211.112): icmp_seq=7 ttl=63 time=2.99 ms 修改主机名hostname: 1echo ceph-1 &gt; /etc/hostname 然后重启机器，这样配置的hostname跟IP就会生效 然后就可以通过本机终端直接ssh到虚拟机进行操作，可以方便的进行复制黏贴。 登录到虚拟机： 12345678ssh root@192.168.56.101The authenticity of host '192.168.56.101 (192.168.56.101)' can't be established.ECDSA key fingerprint is SHA256:uuwVZ9O8+0KypxxJUgZLANVYMOFKY2QAd1Jv7Fa2fQE.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.56.101' (ECDSA) to the list of known hosts.root@192.168.56.101's password:Last login: Wed Nov 21 01:08:21 2018[root@ceph-1 ~]# 登录成功之后开始进行下面的操作。 修改yum源 这里将yum源修改成aliyun的源，指令如下: 123456yum clean allcurl http://mirrors.aliyun.com/repo/Centos-7.repo &gt;/etc/yum.repos.d/CentOS-Base.repocurl http://mirrors.aliyun.com/repo/epel-7.repo &gt;/etc/yum.repos.d/epel.repo sed -i '/aliyuncs/d' /etc/yum.repos.d/CentOS-Base.reposed -i '/aliyuncs/d' /etc/yum.repos.d/epel.repoyum makecache 安装软件： 1yum -y install wget ntp vim 虚拟机ceph软件安装 配置ceph源 在/etc/yum.repos.d/目录下新增一个ceph源文件ceph.repo,并写入下面内容： 1234567891011121314vim /etc/yum.repos.d/ceph.repo#写入以下内容[ceph]name=cephbaseurl=http://mirrors.aliyun.com/ceph/rpm-luminous/el7/x86_64/gpgcheck=0[ceph-noarch]name=cephnoarchbaseurl=http://mirrors.aliyun.com/ceph/rpm-luminous/el7/noarch/gpgcheck=0[ceph-source]name=ceph-sourcebaseurl=http://mirrors.aliyun.com/ceph/rpm-luminous/el7/SRPMS/gpgcheck=0 安装ceph 执行以下命令安装ceph: 1234yum clean all &amp;&amp; yum makecacheyum -y install yum-plugin-priorities yum -y install openssh-serveryum -y install ceph ceph-radosgw 验证ceph是否安装完成： 12[root@ceph-1 ~]# ceph -vceph version 12.2.9 (9e300932ef8a8916fb3fda78c58691a6ab0f4217) luminous (stable) 说明ceph安装成功。 至此，第一台虚拟机创建完成，然后关机。 克隆虚拟机 克隆机器 点击刚刚创建好的虚拟机，然后右键点击复制， 重命名虚拟机为ceph-2，并勾选重新初始化MAC和网卡选项。 点击继续，然后勾选完全复制 修改机器配置 在VM上登陆ceph-2，修改enp0s8的IP。 12vim /etc/sysconfig/network-scripts/ifcfg-enp0s8IPADDR=192.168.56.102 修改hostname 1echo ceph-2 &gt; /etc/hostname 修改好之后重启，就可以通过本机终端ssh访问了 12345678ssh root@192.168.56.102The authenticity of host '192.168.56.102 (192.168.56.102)' can't be established.ECDSA key fingerprint is SHA256:uuwVZ9O8+0KypxxJUgZLANVYMOFKY2QAd1Jv7Fa2fQE.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.56.102' (ECDSA) to the list of known hosts.root@192.168.56.102's password:Last login: Wed Nov 21 02:14:58 2018[root@ceph-2 ~]# 说明克隆成功。 同样的方法克隆ceph-3，将修改IP为192.168.56.103。 最后，将各个主机的IP加入各自的/etc/hosts中: 123456vim /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.56.101 ceph-1192.168.56.102 ceph-2192.168.56.103 ceph-3 最后重启所有主机。 本篇结束，下一篇将重点介绍ceph集群的手工搭建。","categories":[{"name":"ceph","slug":"ceph","permalink":"https://www.zuoyangblog.com/categories/ceph/"}],"tags":[{"name":"ceph","slug":"ceph","permalink":"https://www.zuoyangblog.com/tags/ceph/"},{"name":"virtualBox","slug":"virtualBox","permalink":"https://www.zuoyangblog.com/tags/virtualBox/"}]},{"title":"第一篇：Ceph简介","slug":"Ceph_introduction","date":"2018-11-19T12:15:07.000Z","updated":"2018-11-19T13:33:19.000Z","comments":true,"path":"post/3a6a8a8c.html","link":"","permalink":"https://www.zuoyangblog.com/post/3a6a8a8c.html","excerpt":"","text":"Ceph架构简介 最近工作中要使用ceph作为底层存储架构，故对其进行了一番调研，本篇乃ceph系列的第一篇。 Ceph Ceph是一个统一的分布式存储系统，设计初衷是提供较好的性能、可靠性和可扩展性。 Ceph项目最早起源于Sage就读博士期间的工作（最早的成果于2004年发表），并随后贡献给开源社区。在经过了数年的发展之后，目前已得到众多云计算厂商的支持并被广泛应用。RedHat及OpenStack都可与Ceph整合以支持虚拟机镜像的后端存储。 Ceph is a distributed object, block, and file storage platform. 使用Ceph系统可以提供对象存储、块设备存储和文件系统服务. Ceph底层提供了分布式的RADOS存储，用与支撑上层的librados和RGW、RBD、CephFS等服务。Ceph实现了非常底层的object storage，是纯粹的SDS，并且支持通用的ZFS、BtrFS和Ext4文件系统，能轻易得Scale，没有单点故障。 Ceph特点 高性能 a. 摒弃了传统的集中式存储元数据寻址的方案，采用CRUSH算法，数据分布均衡，并行度高。 b.考虑了容灾域的隔离，能够实现各类负载的副本放置规则，例如跨机房、机架感知等。 c. 能够支持上千个存储节点的规模，支持TB到PB级的数据。 高可用性 a. 副本数可以灵活控制。 b. 支持故障域分隔，数据强一致性。 c. 多种故障场景自动进行修复自愈。 d. 没有单点故障，自动管理。 高可扩展性 a. 去中心化。 b. 扩展灵活。 c. 随着节点增加而线性增长。 特性丰富 a. 支持三种存储接口：块存储、文件存储、对象存储。 b. 支持自定义接口，支持多种语言驱动。 Ceph架构 支持三种接口： Object：有原生的API，而且也兼容Swift和S3的API。 Block：支持精简配置、快照、克隆。 File：Posix接口，支持快照。 Ceph核心组件及概念介绍 Monitor 一个Ceph集群需要多个Monitor组成的小集群，它们通过Paxos同步数据，用来保存OSD的元数据。 OSD OSD全称Object Storage Device，也就是负责响应客户端请求返回具体数据的进程。一个Ceph集群一般都有很多个OSD。 MDS MDS全称Ceph Metadata Server，是CephFS服务依赖的元数据服务。 Object Ceph最底层的存储单元是Object对象，每个Object包含元数据和原始数据。 PG PG全称Placement Grouops，是一个逻辑的概念，一个PG包含多个OSD。引入PG这一层其实是为了更好的分配数据和定位数据。 RADOS RADOS全称Reliable Autonomic Distributed Object Store，是Ceph集群的精华，用户实现数据分配、Failover等集群操作。 Libradio Librados是Rados提供库，因为RADOS是协议很难直接访问，因此上层的RBD、RGW和CephFS都是通过librados访问的，目前提供PHP、Ruby、Java、Python、C和C++支持。 CRUSH CRUSH是Ceph使用的数据分布算法，类似一致性哈希，让数据分配到预期的地方。 RBD RBD全称RADOS block device，是Ceph对外提供的块设备服务。 RGW RGW全称RADOS gateway，是Ceph对外提供的对象存储服务，接口与S3和Swift兼容。 CephFS CephFS全称Ceph File System，是Ceph对外提供的文件系统服务。 CEPH Filesystem 文件存储 典型设备： FTP、NFS服务器 为了克服块存储文件无法共享的问题，所以有了文件存储。 在服务器上架设FTP与NFS服务，就是文件存储。 优点： 造价低，随便一台机器就可以了。 方便文件共享。 缺点： 读写速率低。 传输速率慢。 使用场景： 日志存储。 有目录结构的文件存储。 … Ceph 文件系统 Ceph 文件系统（ Ceph FS ）是个 POSIX 兼容的文件系统，它使用 Ceph 存储集群来存储数据。 Ceph 文件系统与 Ceph 块设备、同时提供 S3 和 Swift API 的 Ceph 对象存储、或者原生库（ librados ）一样，都使用着相同的 Ceph 存储集群系统。 Ceph 文件系统要求 Ceph 存储集群内至少有一个 Ceph 元数据服务器。 当前， CephFS 还缺乏健壮得像 ‘fsck’ 这样的检查和修复功能。存储重要数据时需小心使用，因为灾难恢复工具还没开发完。 cephfs目前发展比较慢，之前一直没有稳定版本，2016年4月21日官方发布的jewel V10.2.0才公布第一个稳定版本，当前在生产环节中使用很少，所以还是建议谨慎使用，如果要使用需要进行严格的测试后才能上线。 CEPH Block Device 块存储 典型设备： 磁盘阵列，硬盘 主要是将裸磁盘空间映射给主机使用的。 优点： 通过Raid与LVM等手段，对数据提供了保护。 多块廉价的硬盘组合起来，提高容量。 多块磁盘组合出来的逻辑盘，提升读写效率。 缺点： 采用SAN架构组网时，光纤交换机，造价成本高。 主机之间无法共享数据。 使用场景： docker容器、虚拟机磁盘存储分配。 日志存储。 文件存储。 … Ceph 块设备 (RBD) 块是一个字节序列（例如，一个 512 字节的数据块）。基于块的存储接口是最常见的存储数据方法，它们基于旋转介质，像硬盘、 CD 、软盘、甚至传统的 9 磁道磁带。无处不在的块设备接口使虚拟块设备成为与 Ceph 这样的海量存储系统交互的理想之选。 Ceph 块设备是精简配置的、大小可调且将数据条带化存储到集群内的多个 OSD 。 Ceph 块设备利用 RADOS 的多种能力，如快照、复制和一致性。 Ceph 的 RADOS 块设备（ RBD ）使用内核模块或 librbd 库与 OSD 交互。 内核模块可使用 Linux 页缓存。对基于 librbd 的应用程序， Ceph 可提供 RBD 缓存。 客户端可以通过内核模块挂在rbd使用，客户端使用rbd块设备就像使用普通硬盘一样，可以对其就行格式化然后使用；客户应用也可以通过librbd使用ceph块，典型的是云平台的块存储服务（如下图），云平台可以使用rbd作为云的存储后端提供镜像存储、volume块或者客户的系统引导盘等。 Ceph 块设备靠无限伸缩性提供了高性能，如向内核模块、或向 abbr:KVM (kernel virtual machines) （如 Qemu 、 OpenStack 和 CloudStack等云计算系统通过 libvirt 和 Qemu 可与 Ceph 块设备集成）。你可以用同一个集群同时运行 Ceph RADOS gateway、 Ceph FS 文件系统、和 Ceph 块设备。 目前ceph rbd在云平台使用比较广泛而且也很稳定，社区的支持力度也非常大。 CEPH Object Gateway 对象存储 对象存储是提供restful接口并数据组织形式扁平化的存储方法，对象存储同兼具块存储高速直接访问磁盘及文件存储的分布式共享特点。 典型设备： 内置大容量硬盘的分布式服务器(swift, s3) 多台服务器内置大容量硬盘，安装上对象存储管理软件，对外提供读写访问功能。 优点： 具备块存储的读写高速。 具备文件存储的共享等特性。 使用场景： (适合更新变动较少的数据) 图片存储。 视频存储。 … Ceph 对象存储 (radosgw) Ceph 对象网关是一个构建在 librados 之上的对象存储接口，它为应用程序访问Ceph 存储集群提供了一个 RESTful 风格的网关 。 Ceph 对象存储支持 2 种接口： 兼容S3: 提供了对象存储接口，兼容大部分 亚马逊S3 RESTful 接口。 兼容Swift: 提供了对象存储接口，兼容大部分 Openstack Swift 接口。 Ceph 对象存储使用 Ceph 对象网关守护进程（ radosgw ），它是个与 Ceph 存储集群交互的 FastCGI 模块。因为它提供了与 OpenStack Swift 和 Amazon S3 兼容的接口， RADOS 要有它自己的用户管理。 Ceph 对象网关可与 Ceph FS 客户端或 Ceph 块设备客户端共用一个存储集群。 S3 和 Swift 接口共用一个通用命名空间，所以你可以用一个接口写入数据、然后用另一个接口取出数据。 Ceph 对象存储不使用 Ceph 元数据服务器。 对象存储的应用场景： 1）资源分发下载 网站或者app需要上传、下载和分发视频图片等 分发和下载app安装包等 2）网盘 可以对用户提供网盘服务，用户可以通过网盘存储自己任何格式的文件 ceph对象存储目前已经有厂商在使用，但是大多会基于网关等做些优化以适应自己的使用场景。","categories":[{"name":"ceph","slug":"ceph","permalink":"https://www.zuoyangblog.com/categories/ceph/"}],"tags":[{"name":"ceph","slug":"ceph","permalink":"https://www.zuoyangblog.com/tags/ceph/"}]},{"title":"Single Number","slug":"Single-Number","date":"2018-11-15T16:49:48.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/f249b7a1.html","link":"","permalink":"https://www.zuoyangblog.com/post/f249b7a1.html","excerpt":"","text":"问题描述： Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解决思路： 本题主要是求出一组数组中唯一个没有相同元素的数字，这里要求时间复杂度为O(n)，空间复杂度为O(1)，所以我们只需遍历一次数组就必须得到结果，并且不能使用其他额外的内存空间。这里采用异或运算，能够保证相同的元素运算结果为0，所以最终便能找个那个唯一的数字。 代码： 1234567891011121314151617class Solution &#123; public: int singleNumber(int A[], int n) &#123; int result = 0; for(int i = 0;i &lt; n; i++) result ^= A[i]; return result; &#125; &#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Best Time to Buy and Sell Stock II","slug":"Best-Time-to-Buy-and-Sell-Stock-II","date":"2018-11-15T16:48:29.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/a10d34fe.html","link":"","permalink":"https://www.zuoyangblog.com/post/a10d34fe.html","excerpt":"","text":"问题描述： Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 解决思路： 依次将相邻的元素相减（后面减去前面）得到新的数组，再取新数组正数相加即可 代码： 12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; if(prices.empty()) return 0; vector&lt;int&gt; price_d(prices.size()); for(int i = 0; i &lt; prices.size()-1; i++) &#123; price_d[i] = prices[i+1] - prices[i]; &#125; int max = 0; for(int i = 0; i &lt; price_d.size(); i ++) &#123; if(price_d[i] &gt; 0) max += price_d[i]; &#125; return max; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Maximum Depth of Binary Tree","slug":"Maximum-Depth-of-Binary-Tree","date":"2018-11-15T16:47:11.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/2c2d1f13.html","link":"","permalink":"https://www.zuoyangblog.com/post/2c2d1f13.html","excerpt":"","text":"问题描述： Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 解决思路： DFS分别求出左子树和右子树的最大深度然后比较即可 代码： 1234567891011121314151617181920/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode *root) &#123; if (root == NULL) return 0; int l = maxDepth(root-&gt;left); int r = maxDepth(root-&gt;right); return l&gt;r?1+l:1+r; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"},{"name":"DFS","slug":"DFS","permalink":"https://www.zuoyangblog.com/tags/DFS/"}]},{"title":"Same Tree","slug":"Same-Tree","date":"2018-11-15T16:45:40.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/f4467b0e.html","link":"","permalink":"https://www.zuoyangblog.com/post/f4467b0e.html","excerpt":"","text":"问题描述： Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 解决思路： DFS遍历两颗二叉树的结点，只要有一个不同就返回false 12345678910111213141516171819202122232425262728293031323334/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSameTree(TreeNode *p, TreeNode *q) &#123; if(p == NULL) &#123; if (q == NULL) return true; return false; &#125; if(q == NULL) &#123; if (p == NULL) return true; return false; &#125; if (p-&gt;val != q-&gt;val) return false; bool lsame = isSameTree(p-&gt;left,q-&gt;left); bool rsame = isSameTree(p-&gt;right,q-&gt;right); if(lsame==false||rsame==false) return false; return true; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"},{"name":"DFS","slug":"DFS","permalink":"https://www.zuoyangblog.com/tags/DFS/"}]},{"title":"Unique Binary Search Trees","slug":"Unique-Binary-Search-Trees","date":"2018-11-15T16:42:32.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/20d2cb13.html","link":"","permalink":"https://www.zuoyangblog.com/post/20d2cb13.html","excerpt":"","text":"问题描述： Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example, Given n = 3, there are a total of 5 unique BST’s. 123451 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\2 1 2 3 解决思路： 首先分析一下当n=0,1,2这三种情况下BTS个数，我们可以得到当n=0,1时，BTS个数为1，当n=2时，BTS个数为2.这就可以转化为一个递归求解的问题，我们将根结点从1到n依次代替，这样左右子树结点的个数就会发生变化，我们在分别求解左右子树BTS的个数，以此递归求解便可得到BTS的总数目。 代码： 1234567891011class Solution &#123;public: int numTrees(int n) &#123; if(n == 1 || n == 0) return 1; int num = 0; for(int i = 1; i &lt;= n; i++) num += numTrees(i-1) * numTrees(n-i); return num; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"},{"name":"BST","slug":"BST","permalink":"https://www.zuoyangblog.com/tags/BST/"}]},{"title":"Binary Tree Level Order Traversal II","slug":"Binary-Tree-Level-Order-Traversal-II","date":"2018-11-15T16:40:06.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/8adb33dd.html","link":"","permalink":"https://www.zuoyangblog.com/post/8adb33dd.html","excerpt":"","text":"问题描述： Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree {3,9,20,#,#,15,7}, 3 / \\ 9 20 / \\ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ. OJ’s Binary Tree Serialization: The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below. Here’s an example: 1234567 1 / \\2 3 / 4 \\ 5 The above binary tree is serialized as “{1,2,3,#,#,4,#,#,5}”. 解决思路： 和前面一样 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; levelOrderBottom(TreeNode *root) &#123; vector&lt;vector&lt;int&gt;&gt; LOB; if (root == NULL) return LOB; int level = 0; int count = 1; queue&lt;TreeNode *&gt; node; node.push(root); stack&lt;vector&lt;int&gt;&gt; stk; vector&lt;int&gt; sub(0); while(!node.empty())&#123; sub.clear(); level = 0; for(int i = 0; i &lt; count; i++)&#123; root = node.front(); node.pop(); sub.push_back(root-&gt;val); if(root-&gt;left != NULL)&#123; node.push(root-&gt;left); ++level; &#125; if(root-&gt;right != NULL)&#123; node.push(root-&gt;right); ++level; &#125; &#125; stk.push(sub); count = level; &#125; while(!stk.empty())&#123; vector&lt;int&gt; tmp = stk.top(); LOB.push_back(tmp); stk.pop(); &#125; return LOB; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Binary Tree Level Order Traversal","slug":"Binary-Tree-Level-Order-Traversal","date":"2018-11-15T16:37:35.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/a971a08f.html","link":"","permalink":"https://www.zuoyangblog.com/post/a971a08f.html","excerpt":"","text":"问题描述： Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example: Given binary tree {3,9,20,#,#,15,7}, 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ. OJ’s Binary Tree Serialization: The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below. Here’s an example: 1234567 1 / \\2 3 / 4 \\ 5 The above binary tree is serialized as “{1,2,3,#,#,4,#,#,5}”. 解决思路： 这里需要用到队列，因为根据题意要求，我们的输出结果应该是包含vector的vector，里面的每个vector包含的是该层的所有节点的值。由于队列是先进先出的，所以首先建立一个节点队列，从根节点开始插入，另外用count记录每层节点的总个数，level计算每层节点的个数。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt;&gt; LO; if(root == NULL) return LO; queue&lt;TreeNode *&gt; node; node.push(root); int count = 1; int level = 0; vector&lt;int&gt; sub(0); while(!node.empty())&#123; sub.clear(); level = 0; for(int i = 0; i &lt; count; i++)&#123; root = node.front(); node.pop(); sub.push_back(root-&gt;val); if(root-&gt;left != NULL)&#123; node.push(root-&gt;left); ++level; &#125; if(root-&gt;right != NULL)&#123; node.push(root-&gt;right); ++level; &#125; &#125; count = level; LO.push_back(sub); &#125; return LO; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Binary Tree Preorder Traversal","slug":"Binary-Tree-Preorder-Traversal","date":"2018-11-15T16:35:34.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/d13d2726.html","link":"","permalink":"https://www.zuoyangblog.com/post/d13d2726.html","excerpt":"","text":"问题描述： Given a binary tree, return the preorder traversal of its nodes’ values. For example: Given binary tree {1,#,2,3}, 1 ​ ​ 2 ​ / 3 return [1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? 非递归实现，不过超时了。 123456789101112131415161718192021222324252627/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; pretr; if(root == NULL) return pretr; stack&lt;TreeNode *&gt; node; node.push(root); while(!node.empty())&#123; TreeNode *p = node.top(); pretr.push_back(p-&gt;val); node.pop(); if(p-&gt;right) node.push(p); if(p-&gt;left) node.push(p); &#125; return pretr; &#125;&#125;; 递归实现 1234567891011121314151617181920212223242526/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; pretr; process(root,pretr); return pretr; &#125; void process(TreeNode *root,vector&lt;int&gt; &amp;pretr)&#123; if(root == NULL) return; TreeNode *p; p = root; pretr.push_back(p-&gt;val); process(p-&gt;left,pretr); process(p-&gt;right,pretr); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Binary Tree Inorder Traversal","slug":"Binary-Tree-Inorder-Traversal","date":"2018-11-15T16:33:28.000Z","updated":"2018-11-15T16:50:59.000Z","comments":true,"path":"post/8a5e7d39.html","link":"","permalink":"https://www.zuoyangblog.com/post/8a5e7d39.html","excerpt":"","text":"问题描述： Given a binary tree, return the inorder traversal of its nodes’ values. For example: Given binary tree {1,#,2,3}, 1 ​ ​ 2 ​ / 3 return [1,3,2]. Note: Recursive solution is trivial, could you do it iteratively? confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ. 解决思路： 本想用栈去实现，但是这上面好像没有栈的定义，没办法只好用vector去解决了。 代码： 123456789101112131415161718192021222324252627282930313233/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; intr; if (root == NULL) return intr; vector&lt;TreeNode*&gt; node; TreeNode *p; p = root; while(p != NULL || !node.empty())&#123; if(p != NULL)&#123; node.push_back(p); p =p-&gt;left; &#125; else&#123; TreeNode *t = node.back(); node.pop_back(); intr.push_back(t-&gt;val); p = t-&gt;right; &#125; &#125; return intr; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Linked List Cycle","slug":"Linked-List-Cycle","date":"2018-11-15T16:20:05.000Z","updated":"2018-11-15T16:25:35.000Z","comments":true,"path":"post/c94099d8.html","link":"","permalink":"https://www.zuoyangblog.com/post/c94099d8.html","excerpt":"","text":"问题描述： Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 解决思路： 采用快慢指针的方法，快指针一次走两步，慢指针一次走一步，如果链表中有环的话，经过走一定的步数之后快慢指针一定会相遇的，当然如果没有环就需考虑循环结束的条件，这里主要要考虑快指针的情况即可。 代码： 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == NULL) return false; if(head-&gt;next == NULL) return false; ListNode *p,*q; p = head; q = head; while(p != NULL &amp;&amp; p-&gt;next != NULL) &#123; p = p-&gt;next-&gt;next; q = q-&gt;next; if(p == q) return true; &#125; return false; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"List","slug":"List","permalink":"https://www.zuoyangblog.com/tags/List/"}]},{"title":"Remove Duplicates from Sorted List","slug":"Remove-Duplicates-from-Sorted-List","date":"2018-11-15T16:18:19.000Z","updated":"2018-11-15T16:28:43.000Z","comments":true,"path":"post/1d8b65b1.html","link":"","permalink":"https://www.zuoyangblog.com/post/1d8b65b1.html","excerpt":"","text":"问题描述： Given a sorted linked list, delete all duplicates such that each element appear only once. For example, Given 1-&gt;1-&gt;2, return 1-&gt;2. Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 解决思路： 定义两个指针base和cmp,base指针指向被比较的结点，cmp指向base的后一个结点，由于链表是有序的，所以cmp找到第一个不等于base的结点之后，就分别将base和cmp后移。如果相等，只要将相等的结点删除即可。 代码: 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *deleteDuplicates(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *base,*cmp; base = head; cmp = base-&gt;next; while(cmp != NULL)&#123; ListNode *tmp; tmp = cmp-&gt;next; if(cmp-&gt;val == base-&gt;val)&#123; base-&gt;next = tmp; free(cmp); cmp = tmp; &#125; else&#123; base = cmp; cmp = tmp; &#125; &#125; return head; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"List","slug":"List","permalink":"https://www.zuoyangblog.com/tags/List/"}]},{"title":"ZigZag Conversion","slug":"ZigZag-Conversion","date":"2018-11-15T16:16:46.000Z","updated":"2018-11-15T16:25:35.000Z","comments":true,"path":"post/61984fa2.html","link":"","permalink":"https://www.zuoyangblog.com/post/61984fa2.html","excerpt":"","text":"问题描述： The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: &quot;PAHNAPLSIIGYIR&quot; Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows); convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”. 解决思路： 找出规律即可，每次的周期为2nRows-2,但是在1到nRows-1的行数还需要判断周期为2（nRows-1-i）的元素，i是处于1到nRows-1的行数。 代码： 12345678910111213141516171819class Solution &#123;public: string convert(string s, int nRows) &#123; if(s.empty() || nRows &lt;= 1 || s.length() &lt; nRows) return s; string result; int cycle = 2 * nRows - 2; for(int i = 0; i &lt; nRows; i++)&#123; for(int j = i; j &lt; s.length(); j += cycle)&#123; result.push_back(s[j]); if( i &gt; 0 &amp;&amp; i &lt; nRows-1)&#123; if (j + 2 *(nRows - 1 - i) &lt; s.length()) result.push_back(s[j + 2 *(nRows - 1 - i)]); &#125; &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Balanced Binary Tree","slug":"Balanced-Binary-Tree","date":"2018-11-15T16:14:50.000Z","updated":"2018-11-15T16:28:07.000Z","comments":true,"path":"post/5c1c4dd0.html","link":"","permalink":"https://www.zuoyangblog.com/post/5c1c4dd0.html","excerpt":"","text":"问题描述： Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 解决思路： 首先设计一个求二叉树高度的函数，然后调用该函数比较左右子树的高度差即可。 123456789101112131415161718192021222324252627282930313233/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int height(TreeNode *root)&#123; if(root == NULL) return 0; int hr,hl; hl = height(root-&gt;left); hr = height(root-&gt;right); int h; h =1 + (hl &gt; hr ? hl : hr); return h; &#125; bool isBalanced(TreeNode *root) &#123; if(root == NULL) return true; int hl = height(root-&gt;left); int hr = height(root-&gt;right); int diff = hl - hr; if(diff &gt; 1 || diff &lt; -1) return false; return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://www.zuoyangblog.com/tags/Binary-Tree/"}]},{"title":"Majority Element","slug":"Majority-Element","date":"2018-11-15T16:12:02.000Z","updated":"2018-11-15T16:14:30.000Z","comments":true,"path":"post/ed8e0613.html","link":"","permalink":"https://www.zuoyangblog.com/post/ed8e0613.html","excerpt":"","text":"问题描述： Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 解决思路： 这是一个求解数组主元素的题目，数组的主元素是指数组中出现次数超过一半的元素。此题是假设数组非空并且主元素存在，所以比较简单。主元素总会比其他元素多，我们设置两个变量maj_index用于记录主元素的位置，count用于记录主元素出现的次数，然后一次比较数组元素，如果相同则count加1，不同则减1，若count为零，则替换maj_index，并将count置为1. 代码： 12345678910111213141516171819class Solution &#123;public: int majorityElement(vector&lt;int&gt; &amp;num) &#123; int maj_index,count; maj_index = 0; count = 1; for(int i =1; i &lt; num.size(); i++)&#123; if (num[i] == num[maj_index]) count ++; else count --; if (count == 0)&#123; maj_index = i; count = 1; &#125; &#125; return num[maj_index]; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Intersection of Two Linked Lists","slug":"Intersection-of-Two-Linked-Lists","date":"2018-11-15T16:09:39.000Z","updated":"2018-11-15T16:28:26.000Z","comments":true,"path":"post/42870ae4.html","link":"","permalink":"https://www.zuoyangblog.com/post/42870ae4.html","excerpt":"","text":"问题描述： For example, the following two linked lists: A: a1 → a2 ​ ↘ ​ c1 → c2 → c3 ​ ↗ B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 解决思路： 这题要求的时间复杂度是O(n)和空间复杂度O(1)，所以只能用以下方法解决：(1)首先分别求出两个单链表的长度lenA和lenB；(2)求出两个链表的长度差，然后将长链表的比较位置移到长度差的位置，因为这些位置上的两个链表的元素是肯定不相同的；(3)此时，两个链表的长度一致，在分别依次比较元素即可 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if(headA == NULL || headB == NULL) return NULL; int lenA,lenB; lenA = 0,lenB = 0; ListNode *p,*q; for(p = headA;p != NULL;p=p-&gt;next) lenA ++; for(q = headB;q != NULL;q=q-&gt;next) lenB ++; int diff = abs(lenB-lenA); if(lenA &gt; lenB)&#123; p = headA; for(int i = 0;i &lt; diff;i++) p = p-&gt;next; q = headB; while(p != NULL &amp;&amp; q != NULL)&#123; if(p-&gt;val == q-&gt;val) return p; else&#123; p = p-&gt;next; q = q-&gt;next; &#125; &#125; return NULL; &#125; else&#123; p = headB; for(int i = 0;i &lt; diff;i++) p = p-&gt;next; q = headA; while(p != NULL &amp;&amp; q != NULL)&#123; if(p-&gt;val == q-&gt;val) return p; else&#123; p = p-&gt;next; q = q-&gt;next; &#125; &#125; return NULL; &#125; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"List","slug":"List","permalink":"https://www.zuoyangblog.com/tags/List/"}]},{"title":"Palindrome Number","slug":"Palindrome-Number","date":"2018-11-15T16:06:52.000Z","updated":"2018-11-15T16:14:30.000Z","comments":true,"path":"post/b216f26b.html","link":"","permalink":"https://www.zuoyangblog.com/post/b216f26b.html","excerpt":"","text":"问题描述： Determine whether an integer is a palindrome. Do this without extra space. click to show spoilers. Some hints: Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 解决思路： 这里要求不能使用额外的空间，基本思路是首先求出数据的位数，然后编写一个函数能够求出每一位的数字，然后遍历比较即可。 代码1： 123456789101112131415161718192021222324class Solution &#123;public: bool isPalindrome(int x) &#123; if (x &lt; 0) return false; int num = 0; int y = x; while( y != 0)&#123; num ++; y /= 10; &#125; int i,j; for(i = 1, j = num; i &lt; j;i++,j--)&#123; if (search(x,num,i) != search(x,num,j)) return false; &#125; return true; &#125; int search(int x,int n,int index)&#123; int d = pow(10,n-index); int y = x/d; return y%10; &#125;&#125;; 代码2： 123456789101112131415161718class Solution &#123;public: bool isPalindrome(int x) &#123; if (x &lt; 0) return false; int z = x; int y = 0; while( x != 0)&#123; y *= 10; y += x%10; x /= 10; &#125; if(z == y) return true; else return false; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"Excel Sheet Column Number","slug":"Excel-Sheet-Column-Number","date":"2018-11-15T16:03:44.000Z","updated":"2018-11-15T16:14:30.000Z","comments":true,"path":"post/50445eba.html","link":"","permalink":"https://www.zuoyangblog.com/post/50445eba.html","excerpt":"","text":"问题描述： Related to question Excel Sheet Column Title Given a column title as appear in an Excel sheet, return its corresponding column number. For example: 1234567A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 解决思路： 本题类似于进制转换，将一个字符串转化为一个十进制的数字，而要求的字符串可以看作是一个26进制的数字。 代码： 12345678910111213class Solution &#123;public: int titleToNumber(string s) &#123; if(s.empty()) return 0; int n = 0; for(int i = 0; i &lt; s.length()-1; i ++)&#123; n = (int(s[i]-'A')+1+n) * 26; &#125; n += int(s[s.length()-1]-'A')+1; return n; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"2Sum","slug":"2Sum","date":"2018-11-15T15:50:54.000Z","updated":"2018-11-16T08:53:36.000Z","comments":true,"path":"post/74d7ef89.html","link":"","permalink":"https://www.zuoyangblog.com/post/74d7ef89.html","excerpt":"","text":"问题描述： Given an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2 解决思路： 本题主要是在给定的一个数组中找到两个数的下标，使得这个两个数和为给定的值，要求给出的下标从1 开始，且满足递增顺序，有三种解决方法，复杂度分别为O(n^2),O(nlogn),O(n),具体实现如下： 复杂度为O(n^2) 代码： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; // Start typing your C/C++ solution below // DO NOT write int main() function vector&lt;int&gt; ret(2, 0); int len = numbers.size(); for(int i = 0; i &lt; len; i++) &#123; int tmp = target - numbers[i]; // another number for(int j = i + 1; j &lt; len; j++) &#123; if(tmp == numbers[j]) &#123; ret[0] = i + 1; // +1 for not zero-based ret[1] = j + 1; return ret; &#125; &#125; &#125; return ret; &#125;&#125;; 复杂度O(nlogn)代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; vector&lt;int&gt; index; int len = numbers.size(); vector&lt;int&gt; bak = numbers; sort(bak.begin(),bak.end()); int l = 0,r = len-1; int sum = 0; while(l &lt; r)&#123; sum = bak[l]+bak[r]; if(sum == target) &#123; for(int i = 0; i &lt; len;i++) &#123; if (bak[l] == numbers[i]) &#123; index.push_back(i+1); &#125; else if(bak[r] == numbers[i]) &#123; index.push_back(i+1); &#125; if(index.size() == 2) &#123; break; &#125; &#125; break; &#125; else if(sum &lt; target) &#123; ++l; &#125; else &#123; --r; &#125; &#125; return index; &#125;&#125;; 复杂度O(n)代码: 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; int len = numbers.size(); assert(len &gt;= 2); vector&lt;int&gt; ret(2, 0); map&lt;int, int&gt; mapping; // default all are 0 vector&lt;long long&gt; mul(len, 0); for(int i = 0; i &lt; len; i++)&#123; mul[i] = (target - numbers[i]) * numbers[i]; if(mapping[mul[i]] &gt; 0)&#123; // not default 0 if(numbers[i] + numbers[mapping[mul[i]] - 1] == target)&#123; ret[0] = mapping[mul[i]]; ret[1] = i + 1; break; &#125; &#125; else &#123; mapping[mul[i]] = i + 1; // larger than 0 &#125; &#125; return ret; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"3Sum","slug":"3Sum","date":"2018-11-15T15:50:50.000Z","updated":"2018-11-15T16:28:12.000Z","comments":true,"path":"post/cc6b88ec.html","link":"","permalink":"https://www.zuoyangblog.com/post/cc6b88ec.html","excerpt":"","text":"问题描述： Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c) The solution set must not contain duplicate triplets. ​ For example, given array S = {-1 0 1 2 -1 -4}, A solution set is: (-1, 0, 1) (-1, -1, 2) 解决思路： 3sum的时候，先整体排一次序，然后枚举第三个数字的时候不需要重复， 比如排好序以后的数字是 a b c d e f, 那么第一次枚举a, 在剩下的b c d e f中进行2 sum, 完了以后第二次枚举b, 只需要在 c d e f中进行2sum好了，而不是在a c d e f中进行2sum, 这个大家可以自己体会一下，想通了还是挺有帮助的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123; sort(num.begin(),num.end()); int len = num.size(); vector&lt;vector&lt;int&gt;&gt; result; if(len &lt; 3) return result; int iCount = len - 2; vector&lt;int&gt; truple(3,0); int CurrentVal = num[0]; for(int i = 0; i &lt; iCount;i++) &#123; if(i &amp;&amp; num[i] == CurrentVal) &#123; continue; &#125; truple[0] = num[i]; int l = i + 1; int r = len - 1; while(l&lt;r) &#123; int iSum = num[l] + num[r]; if(iSum + truple[0] == 0) &#123; truple[1] = num[l]; truple[2] = num[r]; if(result.size() == 0 || truple != result[result.size()-1]) result.push_back(truple); ++l; --r; &#125; else if(iSum + truple[0] &lt; 0) &#123; ++l; &#125; else &#123; --r; &#125; &#125; CurrentVal = num[i]; &#125; return result; &#125; &#125;; 这是一篇关于kSum问题的总结性文章。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"3Sum Closest","slug":"3Sum-Closest","date":"2018-11-15T15:44:35.000Z","updated":"2018-11-15T16:28:11.000Z","comments":true,"path":"post/c85f0a37.html","link":"","permalink":"https://www.zuoyangblog.com/post/c85f0a37.html","excerpt":"","text":"问题描述： Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. For example, given array S = {-1 2 1 -4}, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 解决思路： 我们可以在 2sum问题 的基础上来解决3sum问题，假设3sum问题的目标是target。每次从数组中选出一个数k，从剩下的数中求目标等于target-k的2sum问题。这里需要注意的是有个小的trick：当我们从数组中选出第i数时，我们只需要求数值中从第i+1个到最后一个范围内字数组的2sum问题。 我们以选第一个和第二个举例，假设数组为A[],总共有n个元素A1，A2…An。很显然，当选出A1时，我们在子数组[A2An]中求目标位target-A1的2sum问题，我们要证明的是当选出A2时，我们只需要在子数组[A3An]中计算目标位target-A2的2sum问题，而不是在子数组[A1,A3~An]中，证明如下： 假设在子数组[A1,A3~An]目标位target-A2的2sum问题中，存在A1 + m = target-A2（m为A3~An中的某个数），即A2 + m = target-A1，这刚好是“对于子数组[A3~An],目标位target-A1的2sum问题”的一个解。即我们相当于对满足3sum的三个数A1+A2+m = target重复计算了。因此为了避免重复计算，在子数组[A1，A3~An]中，可以把A1去掉，再来计算目标是target-A2的2sum问题。 对于本题要求的求最接近解，只需要保存当前解以及当前解和目标的距离，如果新的解更接近，则更新解。算法复杂度为O（n^2）; 注意：我们这里是求的和是一个非确定性的数，因此2sum问题的hashtable解法就不适合这里了 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: int threeSumClosest(vector&lt;int&gt; &amp;num, int target) &#123; int n = num.size(); sort(num.begin(),num.end()); int res,dis=INT_MAX; for(int i = 0;i&lt;n-2;i++) &#123; int target2 = target - num[i]; int tmpdis; int tmpres = twoSumClosest(num,i+1,target2); if((tmpdis = abs(tmpres-target2)) &lt; dis) &#123; res = tmpres + num[i]; dis = tmpdis; if(res == target) return res; &#125; &#125; return res; &#125; int twoSumClosest(vector&lt;int&gt; &amp;sortnum,int start,int target)&#123; int res,dis=INT_MAX; int l = start,r = sortnum.size()-1; while(l&lt;r) &#123; int sum = sortnum[l]+sortnum[r]; if(sum &lt; target) &#123; if(target-sum &lt; dis) &#123; res = sum; dis = target - sum; &#125; ++l; &#125; else if(sum &gt; target) &#123; if(sum - target &lt; dis) &#123; res = sum; dis = sum - target; &#125; --r; &#125; else return target; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"4Sum","slug":"4Sum","date":"2018-11-15T15:44:12.000Z","updated":"2018-11-15T16:28:10.000Z","comments":true,"path":"post/51bcb055.html","link":"","permalink":"https://www.zuoyangblog.com/post/51bcb055.html","excerpt":"","text":"问题描述 Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: 12345[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 算法1：O(n^3) 我们可以仿照3sum的解决方法。这里枚举第一个和第二个数，然后对余下数的求2sum，算法复杂度为O（n^3） 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target) &#123; int n = num.size(); sort(num.begin(),num.end()); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; quard(4,0); for(int i = 0; i &lt; n-3; i++) &#123; if(i &gt; 0 &amp;&amp; num[i] == num[i-1]) continue; for(int j = i + 1; j &lt; n -2; j++) &#123; if(j &gt; i+1 &amp;&amp; num[j] == num[j-1]) continue; int l = j+1,r=n-1; int target2 = target - num[i] - num[j]; while(l&lt;r) &#123; int sum = num[l] + num[r]; if(sum &lt; target2) &#123; ++l; &#125; else if(sum &gt; target2) &#123; --r; &#125; else &#123; quard[0] = num[i]; quard[1] = num[j]; quard[2] = num[l]; quard[3] = num[r]; res.push_back(quard); int k = l + 1; while(k &lt; r &amp;&amp; num[k] == num[l])k++; l = k; k = r-1; while(k &gt; l &amp;&amp; num[k] == num[r])k--; r = k; &#125; &#125; &#125; &#125; return res; &#125;&#125;; 算法2：O（n^2）的算法 和前面相同，都是先对数组排序。我们先枚举出所有二个数的和存放在哈希map中，其中map的key对应的是二个数的和，因为多对元素求和可能是相同的值，故哈希map的value是一个链表（下面的代码中用数组代替），链表每个节点存的是这两个数在数组的下标；这个预处理的时间复杂度是O（n^2）。接着和算法1类似，枚举第一个和第二个元素，假设分别为v1,v2, 然后在哈希map中查找和为target-v1-v2的所有二元对（在对应的链表中），查找的时间为O（1），为了保证不重复计算，我们只保留两个数下标都大于V2的二元对（其实我们在前面3sum问题中所求得的三个数在排序后的数组中下标都是递增的），即时是这样也有可能重复：比如排好序后数组为-9 -4 -2 0 2 4 4，target = 0，当第一个和第二个元素分别是-4，-2时，我们要得到和为0-（-2）-（-4） = 6的二元对，这样的二元对有两个,都是(2,4)，且他们在数组中的下标都大于-4和-2，如果都加入结果，则(-4,-2,2,4)会出现两次，因此在加入二元对时，要判断是否和已经加入的二元对重复（由于过早二元对之前数组已经排过序，所以两个元素都相同的二元对可以保证在链表中是相邻的，链表不会出现(2,4)-&gt;(1,5)-&gt;(2,4)的情况，因此只要判断新加入的二元对和上一个加入的二元对是否重复即可），因为同一个链表中的二元对两个元素的和都是相同的，因此只要二元对的一个元素不同，则这个二元对就不同。我们可以认为哈希map中key对应的链表长度为常数，那么算法总的复杂度为O（n^2） 代码： 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target) &#123; int n = num.size(); vector&lt;vector&lt;int&gt; &gt; res; unordered_map&lt;int, vector&lt;pair&lt;int, int&gt; &gt; &gt;pairs; pairs.reserve(n*n); sort(num.begin(), num.end()); for(int i = 0; i &lt; n; i++) for(int j = i+1 ; j &lt; n; j++) pairs[num[i]+num[j]].push_back(make_pair(i,j)); for(int i = 0; i &lt; n - 3; i++) &#123; if(i != 0 &amp;&amp; num[i] == num[i-1])continue;//防止第一个元素重复 for(int j = i+1; j &lt; n - 2; j++) &#123; if(j != i+1 &amp;&amp; num[j] == num[j-1])continue;//防止第二个元素重复 if(pairs.find(target - num[i] - num[j]) != pairs.end()) &#123; vector&lt;pair&lt;int, int&gt;&gt; &amp;sum2 = pairs[target - num[i] - num[j]]; bool isFirstPush = true; for(int k = 0; k &lt; sum2.size(); k++) &#123; if(sum2[k].first &lt;= j)continue;//保证所求的四元组的数组下标是递增的 if(isFirstPush || (res.back())[2] != num[sum2[k].first]) &#123; res.push_back(vector&lt;int&gt;&#123;num[i], num[j], num[sum2[k].first], num[sum2[k].second]&#125;); isFirstPush = false; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"}]},{"title":"有效的括号序列","slug":"有效的括号序列","date":"2018-11-15T15:41:20.000Z","updated":"2018-11-15T16:28:04.000Z","comments":true,"path":"post/cf94e2fe.html","link":"","permalink":"https://www.zuoyangblog.com/post/cf94e2fe.html","excerpt":"","text":"问题描述： 给定一个字符串所表示的括号序列，包含以下字符： '(', ')', '{', '}', '[' and ']'， 判定是否是有效的括号序列。 样例 括号必须依照 &quot;()&quot; 顺序表示， &quot;()[]{}&quot; 是有效的括号，但 &quot;([)]&quot;则是无效的括号。 解题思路：使用栈 代码： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: /** * @param s A string * @return whether the string is a valid parentheses */ bool isMatch(char a, char b) &#123; if(a == '(' &amp;&amp; b == ')') return true; if(a == '[' &amp;&amp; b == ']') return true; if(a == '&#123;' &amp;&amp; b == '&#125;') return true; return false; &#125; bool isValidParentheses(string&amp; s) &#123; // Write your code here int n = s.length(); if(n &lt; 1) return true; if(n % 2) return false; stack&lt;char&gt; paren; paren.push(s[0]); int i = 1; while(i &lt; n) &#123; if(!paren.empty() &amp;&amp; isMatch(paren.top(),s[i])) paren.pop(); else paren.push(s[i]); i++; &#125; if(!paren.empty()) return false; else return true; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"Stack","slug":"Stack","permalink":"https://www.zuoyangblog.com/tags/Stack/"}]},{"title":"岛屿个数","slug":"岛屿个数","date":"2018-11-15T15:36:58.000Z","updated":"2018-11-15T16:28:09.000Z","comments":true,"path":"post/cc03a9fe.html","link":"","permalink":"https://www.zuoyangblog.com/post/cc03a9fe.html","excerpt":"","text":"问题描述： 给一个0,1矩阵，求不同的岛屿的个数。 0代表海，1代表岛，如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。 样例 在矩阵： 1234567[ [1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1]] 中有 3 个岛. 解题思路：深度遍历 dfs 代码： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: /** * @param grid a boolean 2D matrix * @return an integer */ int step[4][2] = &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;; int numIslands(vector&lt;vector&lt;bool&gt;&gt;&amp; grid) &#123; // Write your code here int n = grid.size(); if(n &lt; 1) return 0; int m = grid[0].size(); int count = 0; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(grid[i][j] == true)&#123; dfs(grid,i,j); count++; &#125; &#125; &#125; return count; &#125; void dfs(vector&lt;vector&lt;bool&gt;&gt;&amp; grid, int i, int j)&#123; grid[i][j] = false; for(int k = 0; k &lt; 4; k++)&#123; int x = step[k][0] + i; int y = step[k][1] + j; if(x &gt;= 0 &amp;&amp; x &lt; grid.size() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; grid[0].size() &amp;&amp; grid[x][y] == true)&#123; dfs(grid,x,y); &#125; &#125; return; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"DFS","slug":"DFS","permalink":"https://www.zuoyangblog.com/tags/DFS/"}]},{"title":"最后一个单词的长度","slug":"最后一个单词的长度","date":"2018-11-15T15:19:54.000Z","updated":"2018-11-15T16:28:05.000Z","comments":true,"path":"post/f055ffc7.html","link":"","permalink":"https://www.zuoyangblog.com/post/f055ffc7.html","excerpt":"","text":"问题描述： 给定一个字符串， 包含大小写字母、空格' '，请返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 样例： 给定 s = &quot;Hello World&quot;，返回 5。 代码： 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: /** * @param s A string * @return the length of last word */ int lengthOfLastWord(string&amp; s) &#123; // Write your code here int n = s.length(); int len = 0; if(n &lt; 1) return 0; int i = n - 1; while(i &gt;= 0) &#123; if(s[i] == ' ') i--; else break; &#125; if(i &gt;= 0) &#123; while(s[i] != ' ' &amp;&amp; i &gt;= 0) &#123; len++; i--; &#125; return len; &#125; else return len; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zuoyangblog.com/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.zuoyangblog.com/tags/C/"},{"name":"String","slug":"String","permalink":"https://www.zuoyangblog.com/tags/String/"}]}]}